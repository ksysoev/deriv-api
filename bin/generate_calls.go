package main

import (
	"encoding/json"
	"flag"
	"log"
	"os"
	"strings"
	"text/template"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

const (
	// API_CALLS is the file name for the api calls
	APICalls = "./calls.go"

	// SUBSCRIPTION_CALLS is the file name for the subscription calls
	SubscriptionCalls = "./subscription_calls.go"

	// SCHEMA_PATH is the path to the schema files
	DefaultSchemaPath = "./deriv-api-docs/config/v3/"

	DefaultSchemaPackage = "github.com/ksysoev/deriv-api/schema"

	fileMode = 0o600
)

var headerRawTemplate = `// Code generated by bin/generate_call.go, DO NOT EDIT.
package deriv

import (
	"context"

	"{{.SchemaPackage}}"
)

`

var apiCallRawTemplate = `// {{.Title}} {{.Description}}
func (api *Client) {{.Title}}(ctx context.Context, r schema.{{.Title}}) (resp schema.{{.Title}}Resp, err error) {
	id := api.getNextRequestID()
	r.ReqId = &id
	err = api.SendRequest(ctx, id, r, &resp)
	return
}

`

var subscriptionCallRawTemplate = `// Subscribe{{.Title}} {{.Description}}
func (api *Client) Subscribe{{.Title}}(ctx context.Context, r schema.{{.Title}}) (rsp schema.{{.Title}}Resp, s *Subsciption[schema.{{.Title}}Resp, schema.{{.Resp}}], err error) {
	id := api.getNextRequestID()
	var f schema.{{.Title}}Subscribe = 1
	r.ReqId = &id
	r.Subscribe = &f
	s = NewSubcription[schema.{{.Title}}Resp, schema.{{.Resp}}](ctx, api)
	rsp, err = s.Start(id, r)
	return
}

`

type headerData struct {
	SchemaPackage string
}

type apiCallData struct {
	Title       string
	Description string
}

type subscriptionCallData struct {
	Title       string
	Description string
	Resp        string
}

var tmplHeader, tmplAPICall, tmplSubscriptionCall *template.Template
var schemaPath, schemaPackage string

func init() {
	tmplHeader = template.Must(template.New("header").Parse(headerRawTemplate))
	tmplAPICall = template.Must(template.New("api_call").Parse(apiCallRawTemplate))
	tmplSubscriptionCall = template.Must(template.New("subscription_call").Parse(subscriptionCallRawTemplate))

	flag.StringVar(&schemaPath, "path", DefaultSchemaPath, "path to the schema files")
	flag.StringVar(&schemaPackage, "package", DefaultSchemaPackage, "package name for the schema types")
}

func main() {
	flag.Parse()

	files, err := os.ReadDir(schemaPath)
	if err != nil {
		log.Fatal(err)
	}

	var apiCalls, subcriptionCalls string

	var buf strings.Builder
	if err := tmplHeader.Execute(&buf, headerData{SchemaPackage: schemaPackage}); err != nil {
		log.Fatal(err)
	}

	apiCalls += buf.String()
	subcriptionCalls += buf.String()

	for _, file := range files {
		name := file.Name()
		request, err := os.ReadFile(schemaPath + name + "/send.json")

		if err != nil {
			log.Fatal(err)
		}

		var requestSchema map[string]any
		err = json.Unmarshal(request, &requestSchema)

		if err != nil {
			log.Fatal(err)
		}

		title := CreateTitle(name)

		description, _ := requestSchema["description"].(string)

		callRendered, err := CreateAPICallFunction(title, description)
		if err != nil {
			log.Fatal(err)
		}

		apiCalls += callRendered

		if HasSubscribe(requestSchema) {
			subcriptionRendered, err := CreateSubscriptionCallFunction(title, description)
			if err != nil {
				log.Fatal(err)
			}

			subcriptionCalls += subcriptionRendered
		}
	}

	if err := os.WriteFile(APICalls, []byte(apiCalls), fileMode); err != nil {
		log.Fatal(err)
	}

	if err := os.WriteFile(SubscriptionCalls, []byte(subcriptionCalls), fileMode); err != nil {
		log.Fatal(err)
	}
}

func HasSubscribe(r map[string]any) bool {
	rawProperties, ok := r["properties"]
	if !ok {
		return false
	}

	properties, ok := rawProperties.(map[string]any)
	if !ok {
		return false
	}

	_, ok = properties["subscribe"]

	return ok
}

func CreateTitle(name string) string {
	var title string

	for _, s := range strings.Split(name, "_") {
		if s == "p2p" {
			title += "P2P"
			continue
		}

		title += cases.Title(language.Tag{}).String(s)
	}

	return title
}

func CreateAPICallFunction(title, description string) (string, error) {
	var buf strings.Builder
	if err := tmplAPICall.Execute(&buf, apiCallData{Title: title, Description: description}); err != nil {
		return "", err
	}

	return buf.String(), nil
}

func CreateSubscriptionCallFunction(title, description string) (string, error) {
	initResp := title + "Resp"

	tmplData := subscriptionCallData{Title: title, Description: description, Resp: initResp}

	switch title {
	case "Buy":
		tmplData.Resp = "ProposalOpenContractResp"
	case "TicksHistory", "Transaction":
		// this is a special case, because the response is different depending on the style
		// logic for this api call is maintained in custom_subscription_calls.go
		return "", nil
	case "P2POrderCreate", "P2POrderList":
		tmplData.Resp = "P2POrderInfoResp"
	case "P2PAdvertiserCreate":
		tmplData.Resp = "P2PAdvertInfoResp"
	}

	var buf strings.Builder
	if err := tmplSubscriptionCall.Execute(&buf, tmplData); err != nil {
		return "", err
	}

	return buf.String(), nil
}
