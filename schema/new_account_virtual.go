// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import "reflect"

// Create a new virtual-money account.
type NewAccountVirtual struct {
	// [Optional] Affiliate token, within 100 characters.
	AffiliateToken *string `json:"affiliate_token,omitempty"`

	// Password (Accepts any printable ASCII character. Must be within 8-25
	// characters, and include numbers, lowercase and uppercase letters. Must not be
	// the same as the user's email address).
	ClientPassword *string `json:"client_password,omitempty"`

	// [Optional] Date of first contact, format: `yyyy-mm-dd` in GMT timezone.
	DateFirstContact *string `json:"date_first_contact,omitempty"`

	// [Optional] Email address for signup.
	Email *string `json:"email,omitempty"`

	// [Optional] Boolean value: 1 or 0, indicating whether the client has given
	// consent for marketing emails.
	EmailConsent *NewAccountVirtualEmailConsent `json:"email_consent,omitempty"`

	// [Optional] Google Click Identifier to track source.
	GclidUrl *string `json:"gclid_url,omitempty"`

	// [Optional] The login id of the user. Mandatory when multiple tokens were
	// provided during authorize.
	Loginid *string `json:"loginid,omitempty"`

	// Must be `1`
	NewAccountVirtual NewAccountVirtualNewAccountVirtual `json:"new_account_virtual"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough NewAccountVirtualPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// 2-letter country code (obtained from `residence_list` call).
	Residence *string `json:"residence,omitempty"`

	// [Optional] Show whether user has used mobile or desktop.
	SignupDevice *NewAccountVirtualSignupDevice `json:"signup_device,omitempty"`

	// Account type
	Type NewAccountVirtualType `json:"type,omitempty"`

	// [Optional] Identifier of particular ad. Value must match Regex pattern to be
	// recorded
	UtmAdId interface{} `json:"utm_ad_id,omitempty"`

	// [Optional] Identifier of ad group in the campaign. Value must match Regex
	// pattern to be recorded
	UtmAdgroupId interface{} `json:"utm_adgroup_id,omitempty"`

	// [Optional] Unique identifier of click on AdRoll ads platform. Value must match
	// Regex pattern to be recorded
	UtmAdrollclkId interface{} `json:"utm_adrollclk_id,omitempty"`

	// [Optional] Identifies a specific product promotion or strategic campaign such
	// as a spring sale or other promotions. Value must match Regex pattern to be
	// recorded
	UtmCampaign interface{} `json:"utm_campaign,omitempty"`

	// [Optional] Identifier of paid ad campaign. Value must match Regex pattern to be
	// recorded
	UtmCampaignId interface{} `json:"utm_campaign_id,omitempty"`

	// [Optional] Used to differentiate similar content, or links within the same ad.
	// Value must match Regex pattern to be recorded
	UtmContent interface{} `json:"utm_content,omitempty"`

	// [Optional] Unique identifier of click on Facebook ads platform. Value must
	// match Regex pattern to be recorded
	UtmFbclId interface{} `json:"utm_fbcl_id,omitempty"`

	// [Optional] Unique visitor identifier on Google Ads platform. Value must match
	// Regex pattern to be recorded
	UtmGlClientId interface{} `json:"utm_gl_client_id,omitempty"`

	// [Optional] Identifies the medium the link was used upon such as: email, CPC, or
	// other methods of sharing. Value must match Regex pattern to be recorded
	UtmMedium interface{} `json:"utm_medium,omitempty"`

	// [Optional] Unique click identifier on Microsoft Bing ads platform. Value must
	// match Regex pattern to be recorded
	UtmMsclkId interface{} `json:"utm_msclk_id,omitempty"`

	// [Optional] Identifies the source of traffic such as: search engine, newsletter,
	// or other referral. Value must match Regex pattern to be recorded
	UtmSource interface{} `json:"utm_source,omitempty"`

	// [Optional] Used to send information related to the campaign term like paid
	// search keywords. Value must match Regex pattern to be recorded
	UtmTerm interface{} `json:"utm_term,omitempty"`

	// Email verification code (received from a `verify_email` call, which must be
	// done first).
	VerificationCode *string `json:"verification_code,omitempty"`
}

type NewAccountVirtualEmailConsent int

var enumValues_NewAccountVirtualEmailConsent = []interface{}{
	1,
	0,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountVirtualEmailConsent) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountVirtualEmailConsent {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountVirtualEmailConsent, v)
	}
	*j = NewAccountVirtualEmailConsent(v)
	return nil
}

type NewAccountVirtualNewAccountVirtual int

var enumValues_NewAccountVirtualNewAccountVirtual = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountVirtualNewAccountVirtual) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountVirtualNewAccountVirtual {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountVirtualNewAccountVirtual, v)
	}
	*j = NewAccountVirtualNewAccountVirtual(v)
	return nil
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type NewAccountVirtualPassthrough map[string]interface{}

type NewAccountVirtualSignupDevice string

const NewAccountVirtualSignupDeviceDesktop NewAccountVirtualSignupDevice = "desktop"
const NewAccountVirtualSignupDeviceMobile NewAccountVirtualSignupDevice = "mobile"

var enumValues_NewAccountVirtualSignupDevice = []interface{}{
	"desktop",
	"mobile",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountVirtualSignupDevice) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountVirtualSignupDevice {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountVirtualSignupDevice, v)
	}
	*j = NewAccountVirtualSignupDevice(v)
	return nil
}

type NewAccountVirtualType string

const NewAccountVirtualTypeTrading NewAccountVirtualType = "trading"
const NewAccountVirtualTypeWallet NewAccountVirtualType = "wallet"

var enumValues_NewAccountVirtualType = []interface{}{
	"trading",
	"wallet",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountVirtualType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountVirtualType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountVirtualType, v)
	}
	*j = NewAccountVirtualType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountVirtual) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["new_account_virtual"]; raw != nil && !ok {
		return fmt.Errorf("field new_account_virtual in NewAccountVirtual: required")
	}
	type Plain NewAccountVirtual
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		plain.Type = "trading"
	}
	*j = NewAccountVirtual(plain)
	return nil
}
