// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import "reflect"

// Information of the P2P order.
type P2POrderInfoResp struct {
	// Echo of the request made.
	EchoReq P2POrderInfoRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType P2POrderInfoRespMsgType `json:"msg_type"`

	// The information of P2P order.
	P2POrderInfo *P2POrderInfoRespP2POrderInfo `json:"p2p_order_info,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// For subscription requests only.
	Subscription *P2POrderInfoRespSubscription `json:"subscription,omitempty"`
}

// Echo of the request made.
type P2POrderInfoRespEchoReq map[string]interface{}

type P2POrderInfoRespMsgType string

const P2POrderInfoRespMsgTypeP2POrderInfo P2POrderInfoRespMsgType = "p2p_order_info"

// The information of P2P order.
type P2POrderInfoRespP2POrderInfo struct {
	// The currency of order.
	AccountCurrency string `json:"account_currency"`

	// Details of the advert for this order.
	AdvertDetails P2POrderInfoRespP2POrderInfoAdvertDetails `json:"advert_details"`

	// Details of the advertiser for this order.
	AdvertiserDetails P2POrderInfoRespP2POrderInfoAdvertiserDetails `json:"advertiser_details"`

	// The amount of the order.
	Amount float64 `json:"amount"`

	// The amount of the order, formatted to appropriate decimal places.
	AmountDisplay string `json:"amount_display"`

	// The URL to be used to initialise the chat for this order.
	ChatChannelUrl string `json:"chat_channel_url"`

	// Details of the client who created the order.
	ClientDetails P2POrderInfoRespP2POrderInfoClientDetails `json:"client_details"`

	// The epoch time of the order completion.
	CompletionTime *int `json:"completion_time,omitempty"`

	// Seller contact information.
	ContactInfo string `json:"contact_info"`

	// The epoch time of the order creation.
	CreatedTime int `json:"created_time"`

	// Details of the order dispute.
	DisputeDetails P2POrderInfoRespP2POrderInfoDisputeDetails `json:"dispute_details"`

	// The epoch time in which the order will be expired.
	ExpiryTime int `json:"expiry_time"`

	// The unique identifier for this order.
	Id string `json:"id"`

	// `1` if the order is created for the advert of the current client, otherwise
	// `0`.
	IsIncoming P2POrderInfoRespP2POrderInfoIsIncoming `json:"is_incoming"`

	// `1` if a review can be given, otherwise `0`.
	IsReviewable P2POrderInfoRespP2POrderInfoIsReviewable `json:"is_reviewable"`

	// `1` if the latest order changes have been seen by the current client, otherwise
	// `0`.
	IsSeen *P2POrderInfoRespP2POrderInfoIsSeen `json:"is_seen,omitempty"`

	// Local currency for this order.
	LocalCurrency string `json:"local_currency"`

	// Payment instructions.
	PaymentInfo string `json:"payment_info"`

	// Supported payment methods. Comma separated list.
	PaymentMethod *string `json:"payment_method,omitempty"`

	// Details of available payment methods.
	PaymentMethodDetails P2POrderInfoRespP2POrderInfoPaymentMethodDetails `json:"payment_method_details,omitempty"`

	// Names of supported payment methods.
	PaymentMethodNames []string `json:"payment_method_names,omitempty"`

	// Cost in local currency.
	Price float64 `json:"price"`

	// Cost in local currency, formatted to appropriate decimal places.
	PriceDisplay string `json:"price_display"`

	// Conversion rate of the order.
	Rate float64 `json:"rate"`

	// Conversion rate of the order, formatted to appropriate decimal places.
	RateDisplay string `json:"rate_display"`

	// Details of the review you gave for this order, if any.
	ReviewDetails *P2POrderInfoRespP2POrderInfoReviewDetails `json:"review_details,omitempty"`

	// Current order status.
	Status P2POrderInfoRespP2POrderInfoStatus `json:"status"`

	// Whether this is a buy or a sell.
	Type P2POrderInfoRespP2POrderInfoType `json:"type"`

	// If blocked for too many failed verification attempts, the epoch time that the
	// block will end.
	VerificationLockoutUntil *int `json:"verification_lockout_until,omitempty"`

	// If a verification request has already been made, the epoch time that another
	// verification request can be made.
	VerificationNextRequest *int `json:"verification_next_request,omitempty"`

	// Indicates that the seller in the process of confirming the order.
	VerificationPending *P2POrderInfoRespP2POrderInfoVerificationPending `json:"verification_pending,omitempty"`

	// Epoch time that the current verification token will expire.
	VerificationTokenExpiry *int `json:"verification_token_expiry,omitempty"`
}

// Details of the advert for this order.
type P2POrderInfoRespP2POrderInfoAdvertDetails struct {
	// Indicates if this is block trade advert or not.
	BlockTrade P2POrderInfoRespP2POrderInfoAdvertDetailsBlockTrade `json:"block_trade"`

	// General information about the advert.
	Description string `json:"description"`

	// The unique identifier for the advert.
	Id string `json:"id"`

	// The payment method.
	PaymentMethod *string `json:"payment_method"`

	// Type of the advert.
	Type P2POrderInfoRespP2POrderInfoAdvertDetailsType `json:"type"`
}

type P2POrderInfoRespP2POrderInfoAdvertDetailsBlockTrade int

type P2POrderInfoRespP2POrderInfoAdvertDetailsType string

const P2POrderInfoRespP2POrderInfoAdvertDetailsTypeBuy P2POrderInfoRespP2POrderInfoAdvertDetailsType = "buy"
const P2POrderInfoRespP2POrderInfoAdvertDetailsTypeSell P2POrderInfoRespP2POrderInfoAdvertDetailsType = "sell"

// Details of the advertiser for this order.
type P2POrderInfoRespP2POrderInfoAdvertiserDetails struct {
	// The advertiser's first name.
	FirstName *string `json:"first_name,omitempty"`

	// The advertiser's unique identifier.
	Id string `json:"id"`

	// Indicates if the advertiser is currently online.
	IsOnline P2POrderInfoRespP2POrderInfoAdvertiserDetailsIsOnline `json:"is_online"`

	// Indicates that the advertiser was recommended in the most recent review by the
	// current user.
	IsRecommended *P2POrderInfoRespP2POrderInfoAdvertiserDetailsIsRecommended `json:"is_recommended,omitempty"`

	// The advertiser's last name.
	LastName *string `json:"last_name,omitempty"`

	// Epoch of the latest time the advertiser was online, up to 6 months.
	LastOnlineTime *int `json:"last_online_time"`

	// The advertiser's account identifier.
	Loginid string `json:"loginid"`

	// The advertiser's displayed name.
	Name string `json:"name"`
}

type P2POrderInfoRespP2POrderInfoAdvertiserDetailsIsOnline int

type P2POrderInfoRespP2POrderInfoAdvertiserDetailsIsRecommended struct {
	Value interface{}
}

// Details of the client who created the order.
type P2POrderInfoRespP2POrderInfoClientDetails struct {
	// The client's first name.
	FirstName *string `json:"first_name,omitempty"`

	// The client's unique P2P identifier.
	Id string `json:"id"`

	// Indicates if the advertiser is currently online.
	IsOnline *P2POrderInfoRespP2POrderInfoClientDetailsIsOnline `json:"is_online,omitempty"`

	// Indicates that the client was recommended in the most recent review by the
	// current user.
	IsRecommended *P2POrderInfoRespP2POrderInfoClientDetailsIsRecommended `json:"is_recommended,omitempty"`

	// The client's last name.
	LastName *string `json:"last_name,omitempty"`

	// Epoch of the latest time the advertiser was online, up to 6 months.
	LastOnlineTime *int `json:"last_online_time,omitempty"`

	// The client's account identifier.
	Loginid string `json:"loginid"`

	// The client's displayed name.
	Name string `json:"name"`
}

type P2POrderInfoRespP2POrderInfoClientDetailsIsOnline int

type P2POrderInfoRespP2POrderInfoClientDetailsIsRecommended struct {
	Value interface{}
}

// Details of the order dispute.
type P2POrderInfoRespP2POrderInfoDisputeDetails struct {
	// The dispute reason
	DisputeReason *string `json:"dispute_reason"`

	// The loginid of the client who's raising the dispute
	DisputerLoginid *string `json:"disputer_loginid"`
}

type P2POrderInfoRespP2POrderInfoIsIncoming int

type P2POrderInfoRespP2POrderInfoIsReviewable int

type P2POrderInfoRespP2POrderInfoIsSeen int

// Details of available payment methods.
type P2POrderInfoRespP2POrderInfoPaymentMethodDetails map[string]interface{}

// Details of the review you gave for this order, if any.
type P2POrderInfoRespP2POrderInfoReviewDetails struct {
	// The epoch time of the review.
	CreatedTime int `json:"created_time"`

	// Rating for the transaction, 1 to 5.
	Rating int `json:"rating"`

	// `1` if the advertiser is recommended, `0` if not recommended.
	Recommended P2POrderInfoRespP2POrderInfoReviewDetailsRecommended `json:"recommended"`
}

type P2POrderInfoRespP2POrderInfoReviewDetailsRecommended struct {
	Value interface{}
}

type P2POrderInfoRespP2POrderInfoStatus string

const P2POrderInfoRespP2POrderInfoStatusBlocked P2POrderInfoRespP2POrderInfoStatus = "blocked"
const P2POrderInfoRespP2POrderInfoStatusBuyerConfirmed P2POrderInfoRespP2POrderInfoStatus = "buyer-confirmed"
const P2POrderInfoRespP2POrderInfoStatusCancelled P2POrderInfoRespP2POrderInfoStatus = "cancelled"

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoAdvertDetailsType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderInfoRespP2POrderInfoAdvertDetailsType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderInfoRespP2POrderInfoAdvertDetailsType, v)
	}
	*j = P2POrderInfoRespP2POrderInfoAdvertDetailsType(v)
	return nil
}

var enumValues_P2POrderInfoRespP2POrderInfoClientDetailsIsRecommended = []interface{}{
	nil,
	0.0,
	1.0,
}

// MarshalJSON implements json.Marshaler.
func (j *P2POrderInfoRespP2POrderInfoClientDetailsIsRecommended) MarshalJSON() ([]byte, error) {
	return json.Marshal(j.Value)
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoClientDetailsIsRecommended) UnmarshalJSON(b []byte) error {
	var v struct {
		Value interface{}
	}
	if err := json.Unmarshal(b, &v.Value); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderInfoRespP2POrderInfoClientDetailsIsRecommended {
		if reflect.DeepEqual(v.Value, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderInfoRespP2POrderInfoClientDetailsIsRecommended, v.Value)
	}
	*j = P2POrderInfoRespP2POrderInfoClientDetailsIsRecommended(v)
	return nil
}

var enumValues_P2POrderInfoRespP2POrderInfoClientDetailsIsOnline = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoClientDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id in P2POrderInfoRespP2POrderInfoClientDetails: required")
	}
	if v, ok := raw["loginid"]; !ok || v == nil {
		return fmt.Errorf("field loginid in P2POrderInfoRespP2POrderInfoClientDetails: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in P2POrderInfoRespP2POrderInfoClientDetails: required")
	}
	type Plain P2POrderInfoRespP2POrderInfoClientDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderInfoRespP2POrderInfoClientDetails(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoAdvertiserDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id in P2POrderInfoRespP2POrderInfoAdvertiserDetails: required")
	}
	if v, ok := raw["is_online"]; !ok || v == nil {
		return fmt.Errorf("field is_online in P2POrderInfoRespP2POrderInfoAdvertiserDetails: required")
	}
	if v, ok := raw["last_online_time"]; !ok || v == nil {
		return fmt.Errorf("field last_online_time in P2POrderInfoRespP2POrderInfoAdvertiserDetails: required")
	}
	if v, ok := raw["loginid"]; !ok || v == nil {
		return fmt.Errorf("field loginid in P2POrderInfoRespP2POrderInfoAdvertiserDetails: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in P2POrderInfoRespP2POrderInfoAdvertiserDetails: required")
	}
	type Plain P2POrderInfoRespP2POrderInfoAdvertiserDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderInfoRespP2POrderInfoAdvertiserDetails(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoDisputeDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["dispute_reason"]; !ok || v == nil {
		return fmt.Errorf("field dispute_reason in P2POrderInfoRespP2POrderInfoDisputeDetails: required")
	}
	if v, ok := raw["disputer_loginid"]; !ok || v == nil {
		return fmt.Errorf("field disputer_loginid in P2POrderInfoRespP2POrderInfoDisputeDetails: required")
	}
	type Plain P2POrderInfoRespP2POrderInfoDisputeDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderInfoRespP2POrderInfoDisputeDetails(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoAdvertiserDetailsIsRecommended) UnmarshalJSON(b []byte) error {
	var v struct {
		Value interface{}
	}
	if err := json.Unmarshal(b, &v.Value); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderInfoRespP2POrderInfoAdvertiserDetailsIsRecommended {
		if reflect.DeepEqual(v.Value, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderInfoRespP2POrderInfoAdvertiserDetailsIsRecommended, v.Value)
	}
	*j = P2POrderInfoRespP2POrderInfoAdvertiserDetailsIsRecommended(v)
	return nil
}

var enumValues_P2POrderInfoRespP2POrderInfoIsIncoming = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoIsIncoming) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderInfoRespP2POrderInfoIsIncoming {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderInfoRespP2POrderInfoIsIncoming, v)
	}
	*j = P2POrderInfoRespP2POrderInfoIsIncoming(v)
	return nil
}

// MarshalJSON implements json.Marshaler.
func (j *P2POrderInfoRespP2POrderInfoAdvertiserDetailsIsRecommended) MarshalJSON() ([]byte, error) {
	return json.Marshal(j.Value)
}

var enumValues_P2POrderInfoRespP2POrderInfoIsReviewable = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoIsReviewable) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderInfoRespP2POrderInfoIsReviewable {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderInfoRespP2POrderInfoIsReviewable, v)
	}
	*j = P2POrderInfoRespP2POrderInfoIsReviewable(v)
	return nil
}

var enumValues_P2POrderInfoRespP2POrderInfoAdvertiserDetailsIsRecommended = []interface{}{
	nil,
	0.0,
	1.0,
}
var enumValues_P2POrderInfoRespP2POrderInfoIsSeen = []interface{}{
	1,
	0,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoIsSeen) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderInfoRespP2POrderInfoIsSeen {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderInfoRespP2POrderInfoIsSeen, v)
	}
	*j = P2POrderInfoRespP2POrderInfoIsSeen(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoAdvertiserDetailsIsOnline) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderInfoRespP2POrderInfoAdvertiserDetailsIsOnline {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderInfoRespP2POrderInfoAdvertiserDetailsIsOnline, v)
	}
	*j = P2POrderInfoRespP2POrderInfoAdvertiserDetailsIsOnline(v)
	return nil
}

var enumValues_P2POrderInfoRespP2POrderInfoAdvertiserDetailsIsOnline = []interface{}{
	0,
	1,
}
var enumValues_P2POrderInfoRespP2POrderInfoReviewDetailsRecommended = []interface{}{
	nil,
	0.0,
	1.0,
}

// MarshalJSON implements json.Marshaler.
func (j *P2POrderInfoRespP2POrderInfoReviewDetailsRecommended) MarshalJSON() ([]byte, error) {
	return json.Marshal(j.Value)
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoReviewDetailsRecommended) UnmarshalJSON(b []byte) error {
	var v struct {
		Value interface{}
	}
	if err := json.Unmarshal(b, &v.Value); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderInfoRespP2POrderInfoReviewDetailsRecommended {
		if reflect.DeepEqual(v.Value, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderInfoRespP2POrderInfoReviewDetailsRecommended, v.Value)
	}
	*j = P2POrderInfoRespP2POrderInfoReviewDetailsRecommended(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoAdvertDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["block_trade"]; !ok || v == nil {
		return fmt.Errorf("field block_trade in P2POrderInfoRespP2POrderInfoAdvertDetails: required")
	}
	if v, ok := raw["description"]; !ok || v == nil {
		return fmt.Errorf("field description in P2POrderInfoRespP2POrderInfoAdvertDetails: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id in P2POrderInfoRespP2POrderInfoAdvertDetails: required")
	}
	if v, ok := raw["payment_method"]; !ok || v == nil {
		return fmt.Errorf("field payment_method in P2POrderInfoRespP2POrderInfoAdvertDetails: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in P2POrderInfoRespP2POrderInfoAdvertDetails: required")
	}
	type Plain P2POrderInfoRespP2POrderInfoAdvertDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderInfoRespP2POrderInfoAdvertDetails(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoReviewDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["created_time"]; !ok || v == nil {
		return fmt.Errorf("field created_time in P2POrderInfoRespP2POrderInfoReviewDetails: required")
	}
	if v, ok := raw["rating"]; !ok || v == nil {
		return fmt.Errorf("field rating in P2POrderInfoRespP2POrderInfoReviewDetails: required")
	}
	if v, ok := raw["recommended"]; !ok || v == nil {
		return fmt.Errorf("field recommended in P2POrderInfoRespP2POrderInfoReviewDetails: required")
	}
	type Plain P2POrderInfoRespP2POrderInfoReviewDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderInfoRespP2POrderInfoReviewDetails(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoClientDetailsIsOnline) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderInfoRespP2POrderInfoClientDetailsIsOnline {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderInfoRespP2POrderInfoClientDetailsIsOnline, v)
	}
	*j = P2POrderInfoRespP2POrderInfoClientDetailsIsOnline(v)
	return nil
}

var enumValues_P2POrderInfoRespP2POrderInfoStatus = []interface{}{
	"pending",
	"buyer-confirmed",
	"cancelled",
	"timed-out",
	"blocked",
	"refunded",
	"completed",
	"disputed",
	"dispute-refunded",
	"dispute-completed",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderInfoRespP2POrderInfoStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderInfoRespP2POrderInfoStatus, v)
	}
	*j = P2POrderInfoRespP2POrderInfoStatus(v)
	return nil
}

const P2POrderInfoRespP2POrderInfoStatusPending P2POrderInfoRespP2POrderInfoStatus = "pending"

var enumValues_P2POrderInfoRespP2POrderInfoAdvertDetailsType = []interface{}{
	"buy",
	"sell",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoAdvertDetailsBlockTrade) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderInfoRespP2POrderInfoAdvertDetailsBlockTrade {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderInfoRespP2POrderInfoAdvertDetailsBlockTrade, v)
	}
	*j = P2POrderInfoRespP2POrderInfoAdvertDetailsBlockTrade(v)
	return nil
}

const P2POrderInfoRespP2POrderInfoStatusTimedOut P2POrderInfoRespP2POrderInfoStatus = "timed-out"

var enumValues_P2POrderInfoRespP2POrderInfoAdvertDetailsBlockTrade = []interface{}{
	0,
	1,
}

const P2POrderInfoRespP2POrderInfoStatusRefunded P2POrderInfoRespP2POrderInfoStatus = "refunded"
const P2POrderInfoRespP2POrderInfoStatusCompleted P2POrderInfoRespP2POrderInfoStatus = "completed"
const P2POrderInfoRespP2POrderInfoStatusDisputed P2POrderInfoRespP2POrderInfoStatus = "disputed"
const P2POrderInfoRespP2POrderInfoStatusDisputeRefunded P2POrderInfoRespP2POrderInfoStatus = "dispute-refunded"
const P2POrderInfoRespP2POrderInfoStatusDisputeCompleted P2POrderInfoRespP2POrderInfoStatus = "dispute-completed"

type P2POrderInfoRespP2POrderInfoType string

var enumValues_P2POrderInfoRespP2POrderInfoType = []interface{}{
	"buy",
	"sell",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderInfoRespP2POrderInfoType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderInfoRespP2POrderInfoType, v)
	}
	*j = P2POrderInfoRespP2POrderInfoType(v)
	return nil
}

const P2POrderInfoRespP2POrderInfoTypeBuy P2POrderInfoRespP2POrderInfoType = "buy"
const P2POrderInfoRespP2POrderInfoTypeSell P2POrderInfoRespP2POrderInfoType = "sell"

type P2POrderInfoRespP2POrderInfoVerificationPending int

var enumValues_P2POrderInfoRespP2POrderInfoVerificationPending = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoVerificationPending) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderInfoRespP2POrderInfoVerificationPending {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderInfoRespP2POrderInfoVerificationPending, v)
	}
	*j = P2POrderInfoRespP2POrderInfoVerificationPending(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderInfoRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderInfoRespMsgType, v)
	}
	*j = P2POrderInfoRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["account_currency"]; !ok || v == nil {
		return fmt.Errorf("field account_currency in P2POrderInfoRespP2POrderInfo: required")
	}
	if v, ok := raw["advert_details"]; !ok || v == nil {
		return fmt.Errorf("field advert_details in P2POrderInfoRespP2POrderInfo: required")
	}
	if v, ok := raw["advertiser_details"]; !ok || v == nil {
		return fmt.Errorf("field advertiser_details in P2POrderInfoRespP2POrderInfo: required")
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount in P2POrderInfoRespP2POrderInfo: required")
	}
	if v, ok := raw["amount_display"]; !ok || v == nil {
		return fmt.Errorf("field amount_display in P2POrderInfoRespP2POrderInfo: required")
	}
	if v, ok := raw["chat_channel_url"]; !ok || v == nil {
		return fmt.Errorf("field chat_channel_url in P2POrderInfoRespP2POrderInfo: required")
	}
	if v, ok := raw["client_details"]; !ok || v == nil {
		return fmt.Errorf("field client_details in P2POrderInfoRespP2POrderInfo: required")
	}
	if v, ok := raw["contact_info"]; !ok || v == nil {
		return fmt.Errorf("field contact_info in P2POrderInfoRespP2POrderInfo: required")
	}
	if v, ok := raw["created_time"]; !ok || v == nil {
		return fmt.Errorf("field created_time in P2POrderInfoRespP2POrderInfo: required")
	}
	if v, ok := raw["dispute_details"]; !ok || v == nil {
		return fmt.Errorf("field dispute_details in P2POrderInfoRespP2POrderInfo: required")
	}
	if v, ok := raw["expiry_time"]; !ok || v == nil {
		return fmt.Errorf("field expiry_time in P2POrderInfoRespP2POrderInfo: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id in P2POrderInfoRespP2POrderInfo: required")
	}
	if v, ok := raw["is_incoming"]; !ok || v == nil {
		return fmt.Errorf("field is_incoming in P2POrderInfoRespP2POrderInfo: required")
	}
	if v, ok := raw["is_reviewable"]; !ok || v == nil {
		return fmt.Errorf("field is_reviewable in P2POrderInfoRespP2POrderInfo: required")
	}
	if v, ok := raw["local_currency"]; !ok || v == nil {
		return fmt.Errorf("field local_currency in P2POrderInfoRespP2POrderInfo: required")
	}
	if v, ok := raw["payment_info"]; !ok || v == nil {
		return fmt.Errorf("field payment_info in P2POrderInfoRespP2POrderInfo: required")
	}
	if v, ok := raw["price"]; !ok || v == nil {
		return fmt.Errorf("field price in P2POrderInfoRespP2POrderInfo: required")
	}
	if v, ok := raw["price_display"]; !ok || v == nil {
		return fmt.Errorf("field price_display in P2POrderInfoRespP2POrderInfo: required")
	}
	if v, ok := raw["rate"]; !ok || v == nil {
		return fmt.Errorf("field rate in P2POrderInfoRespP2POrderInfo: required")
	}
	if v, ok := raw["rate_display"]; !ok || v == nil {
		return fmt.Errorf("field rate_display in P2POrderInfoRespP2POrderInfo: required")
	}
	if v, ok := raw["status"]; !ok || v == nil {
		return fmt.Errorf("field status in P2POrderInfoRespP2POrderInfo: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in P2POrderInfoRespP2POrderInfo: required")
	}
	type Plain P2POrderInfoRespP2POrderInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderInfoRespP2POrderInfo(plain)
	return nil
}

// For subscription requests only.
type P2POrderInfoRespSubscription struct {
	// A per-connection unique identifier. Can be passed to the `forget` API call to
	// unsubscribe.
	Id string `json:"id"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespSubscription) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id in P2POrderInfoRespSubscription: required")
	}
	type Plain P2POrderInfoRespSubscription
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderInfoRespSubscription(plain)
	return nil
}

var enumValues_P2POrderInfoRespMsgType = []interface{}{
	"p2p_order_info",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req in P2POrderInfoResp: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type in P2POrderInfoResp: required")
	}
	type Plain P2POrderInfoResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderInfoResp(plain)
	return nil
}
