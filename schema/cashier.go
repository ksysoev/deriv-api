// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import "reflect"

// Request the cashier info for the specified type.
type Cashier struct {
	// [Optional] Address for crypto withdrawal. Only applicable for `api` type.
	Address *string `json:"address,omitempty"`

	// [Optional] Amount for crypto withdrawal. Only applicable for `api` type.
	Amount *float64 `json:"amount,omitempty"`

	// Operation which needs to be requested from cashier
	Cashier CashierCashier `json:"cashier"`

	// [Optional] If set to `1`, only validation is performed. Only applicable for
	// `withdraw` using `crypto` provider and `api` type.
	DryRun CashierDryRun `json:"dry_run,omitempty"`

	// [Optional] The login id of the user. If left unspecified, it defaults to the
	// initial authorized token's login id.
	Loginid *string `json:"loginid,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough CashierPassthrough `json:"passthrough,omitempty"`

	// [Optional] Cashier provider. `crypto` will be default option for crypto
	// currency accounts.
	Provider CashierProvider `json:"provider,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// [Optional] Data need to be returned from cashier. `api` is supported only for
	// `crypto` provider.
	Type CashierType `json:"type,omitempty"`

	// [Optional] Email verification code (received from a `verify_email` call, which
	// must be done first)
	VerificationCode *string `json:"verification_code,omitempty"`
}

type CashierCashier string

const CashierCashierDeposit CashierCashier = "deposit"
const CashierCashierWithdraw CashierCashier = "withdraw"

type CashierDryRun int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type CashierPassthrough map[string]interface{}

type CashierProvider string

const CashierProviderCrypto CashierProvider = "crypto"
const CashierProviderDoughflow CashierProvider = "doughflow"

type CashierType string

const CashierTypeApi CashierType = "api"
const CashierTypeUrl CashierType = "url"

var enumValues_CashierCashier = []interface{}{
	"deposit",
	"withdraw",
}
var enumValues_CashierDryRun = []interface{}{
	0,
	1,
}
var enumValues_CashierProvider = []interface{}{
	"doughflow",
	"crypto",
}
var enumValues_CashierType = []interface{}{
	"url",
	"api",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CashierType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CashierType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CashierType, v)
	}
	*j = CashierType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CashierProvider) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CashierProvider {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CashierProvider, v)
	}
	*j = CashierProvider(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CashierDryRun) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CashierDryRun {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CashierDryRun, v)
	}
	*j = CashierDryRun(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CashierCashier) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CashierCashier {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CashierCashier, v)
	}
	*j = CashierCashier(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Cashier) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Cashier
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["cashier"]; !ok || v == nil {
		plain.Cashier = "deposit"
	}
	if v, ok := raw["dry_run"]; !ok || v == nil {
		plain.DryRun = 0.0
	}
	if v, ok := raw["provider"]; !ok || v == nil {
		plain.Provider = "doughflow"
	}
	if v, ok := raw["type"]; !ok || v == nil {
		plain.Type = "url"
	}
	*j = Cashier(plain)
	return nil
}
