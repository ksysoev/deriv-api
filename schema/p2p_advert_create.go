// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import "reflect"

// Creates a P2P (Peer to Peer) advert. Can only be used by an approved P2P
// advertiser.
type P2PAdvertCreate struct {
	// The total amount of the advert, in advertiser's account currency.
	Amount float64 `json:"amount"`

	// [Optional] Indicates if this is block trade ad or not. Default: 0.
	BlockTrade P2PAdvertCreateBlockTrade `json:"block_trade,omitempty"`

	// [Optional] Advertiser contact information.
	ContactInfo *string `json:"contact_info,omitempty"`

	// [Optional] General information about the advert.
	Description *string `json:"description,omitempty"`

	// [Optional] 2 letter country codes. Counterparties who do not live in these
	// countries will not be allowed to place orders against the advert.
	EligibleCountries []string `json:"eligible_countries,omitempty"`

	// [Optional] Local currency for this advert. If not provided, will use the
	// currency of client's residence by default.
	LocalCurrency *string `json:"local_currency,omitempty"`

	// [Optional] The login id of the user. If left unspecified, it defaults to the
	// initial authorized token's login id.
	Loginid *string `json:"loginid,omitempty"`

	// Maximum allowed amount for the orders of this advert, in advertiser's
	// `account_currency`. Should be more than or equal to `min_order_amount`
	MaxOrderAmount float64 `json:"max_order_amount"`

	// [Optional] Counterparties who have a 30 day completion rate less than this
	// value will not be allowed to place orders against the advert.
	MinCompletionRate *float64 `json:"min_completion_rate,omitempty"`

	// [Optional] Counterparties who joined less than this number of days ago will not
	// be allowed to place orders against the advert.
	MinJoinDays *int `json:"min_join_days,omitempty"`

	// Minimum allowed amount for the orders of this advert, in advertiser's
	// `account_currency`. Should be less than or equal to `max_order_amount`.
	MinOrderAmount float64 `json:"min_order_amount"`

	// [Optional] Counterparties who have an average rating less than this value will
	// not be allowed to place orders against the advert.
	MinRating *float64 `json:"min_rating,omitempty"`

	// [Optional] Expiry period (seconds) for order created against this ad.
	OrderExpiryPeriod *int `json:"order_expiry_period,omitempty"`

	// Must be 1
	P2PAdvertCreate P2PAdvertCreateP2PAdvertCreate `json:"p2p_advert_create"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough P2PAdvertCreatePassthrough `json:"passthrough,omitempty"`

	// [Optional] Payment instructions.
	PaymentInfo *string `json:"payment_info,omitempty"`

	// [Optional] Payment method name (deprecated).
	PaymentMethod *string `json:"payment_method,omitempty"`

	// IDs of previously saved payment methods as returned from
	// p2p_advertiser_payment_methods, only applicable for sell ads.
	PaymentMethodIds []int `json:"payment_method_ids,omitempty"`

	// Payment method identifiers as returned from p2p_payment_methods, only
	// applicable for buy ads.
	PaymentMethodNames []string `json:"payment_method_names,omitempty"`

	// Conversion rate from advertiser's account currency to `local_currency`. An
	// absolute rate value (fixed), or percentage offset from current market rate
	// (floating).
	Rate float64 `json:"rate"`

	// Type of rate, fixed or floating.
	RateType P2PAdvertCreateRateType `json:"rate_type,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// The advertisement represents the intention to perform this action on your Deriv
	// account funds.
	Type P2PAdvertCreateType `json:"type"`
}

type P2PAdvertCreateBlockTrade int

var enumValues_P2PAdvertCreateBlockTrade = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreateBlockTrade) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertCreateBlockTrade {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertCreateBlockTrade, v)
	}
	*j = P2PAdvertCreateBlockTrade(v)
	return nil
}

type P2PAdvertCreateP2PAdvertCreate int

var enumValues_P2PAdvertCreateP2PAdvertCreate = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreateP2PAdvertCreate) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertCreateP2PAdvertCreate {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertCreateP2PAdvertCreate, v)
	}
	*j = P2PAdvertCreateP2PAdvertCreate(v)
	return nil
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type P2PAdvertCreatePassthrough map[string]interface{}

type P2PAdvertCreateRateType string

const P2PAdvertCreateRateTypeFixed P2PAdvertCreateRateType = "fixed"
const P2PAdvertCreateRateTypeFloat P2PAdvertCreateRateType = "float"

var enumValues_P2PAdvertCreateRateType = []interface{}{
	"fixed",
	"float",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreateRateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertCreateRateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertCreateRateType, v)
	}
	*j = P2PAdvertCreateRateType(v)
	return nil
}

type P2PAdvertCreateType string

const P2PAdvertCreateTypeBuy P2PAdvertCreateType = "buy"
const P2PAdvertCreateTypeSell P2PAdvertCreateType = "sell"

var enumValues_P2PAdvertCreateType = []interface{}{
	"buy",
	"sell",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertCreateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertCreateType, v)
	}
	*j = P2PAdvertCreateType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["amount"]; raw != nil && !ok {
		return fmt.Errorf("field amount in P2PAdvertCreate: required")
	}
	if _, ok := raw["max_order_amount"]; raw != nil && !ok {
		return fmt.Errorf("field max_order_amount in P2PAdvertCreate: required")
	}
	if _, ok := raw["min_order_amount"]; raw != nil && !ok {
		return fmt.Errorf("field min_order_amount in P2PAdvertCreate: required")
	}
	if _, ok := raw["p2p_advert_create"]; raw != nil && !ok {
		return fmt.Errorf("field p2p_advert_create in P2PAdvertCreate: required")
	}
	if _, ok := raw["rate"]; raw != nil && !ok {
		return fmt.Errorf("field rate in P2PAdvertCreate: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in P2PAdvertCreate: required")
	}
	type Plain P2PAdvertCreate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["block_trade"]; !ok || v == nil {
		plain.BlockTrade = 0.0
	}
	if len(plain.EligibleCountries) > 250 {
		return fmt.Errorf("field %s length: must be <= %d", "eligible_countries", 250)
	}
	if len(plain.PaymentMethodIds) > 3 {
		return fmt.Errorf("field %s length: must be <= %d", "payment_method_ids", 3)
	}
	if len(plain.PaymentMethodNames) > 3 {
		return fmt.Errorf("field %s length: must be <= %d", "payment_method_names", 3)
	}
	if v, ok := raw["rate_type"]; !ok || v == nil {
		plain.RateType = "fixed"
	}
	*j = P2PAdvertCreate(plain)
	return nil
}
