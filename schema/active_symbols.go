// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import "reflect"

// Retrieve a list of all currently active symbols (underlying markets upon which
// contracts are available for trading).
type ActiveSymbols struct {
	// If you use `brief`, only a subset of fields will be returned.
	ActiveSymbols ActiveSymbolsActiveSymbols `json:"active_symbols"`

	// [Optional] Category of barrier.
	BarrierCategory []ActiveSymbolsBarrierCategoryElem `json:"barrier_category,omitempty"`

	// [Optional] The proposed contract type
	ContractType []ActiveSymbolsContractTypeElem `json:"contract_type,omitempty"`

	// Deprecated - replaced by landing_company_short.
	LandingCompany *ActiveSymbolsLandingCompany `json:"landing_company,omitempty"`

	// [Optional] If you specify this field, only symbols available for trading by
	// that landing company will be returned. If you are logged in, only symbols
	// available for trading by your landing company will be returned regardless of
	// what you specify in this field.
	LandingCompanyShort *ActiveSymbolsLandingCompanyShort `json:"landing_company_short,omitempty"`

	// [Optional] The login id of the user. Mandatory when multiple tokens were
	// provided during authorize.
	Loginid *string `json:"loginid,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough ActiveSymbolsPassthrough `json:"passthrough,omitempty"`

	// [Optional] If you specify this field, only symbols that can be traded through
	// that product type will be returned.
	ProductType *ActiveSymbolsProductType `json:"product_type,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type ActiveSymbolsActiveSymbols string

const ActiveSymbolsActiveSymbolsBrief ActiveSymbolsActiveSymbols = "brief"
const ActiveSymbolsActiveSymbolsFull ActiveSymbolsActiveSymbols = "full"

var enumValues_ActiveSymbolsActiveSymbols = []interface{}{
	"brief",
	"full",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ActiveSymbolsActiveSymbols) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ActiveSymbolsActiveSymbols {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ActiveSymbolsActiveSymbols, v)
	}
	*j = ActiveSymbolsActiveSymbols(v)
	return nil
}

type ActiveSymbolsBarrierCategoryElem string

const ActiveSymbolsBarrierCategoryElemAmerican ActiveSymbolsBarrierCategoryElem = "american"
const ActiveSymbolsBarrierCategoryElemAsian ActiveSymbolsBarrierCategoryElem = "asian"
const ActiveSymbolsBarrierCategoryElemEuroAtm ActiveSymbolsBarrierCategoryElem = "euro_atm"
const ActiveSymbolsBarrierCategoryElemEuroNonAtm ActiveSymbolsBarrierCategoryElem = "euro_non_atm"
const ActiveSymbolsBarrierCategoryElemLookback ActiveSymbolsBarrierCategoryElem = "lookback"
const ActiveSymbolsBarrierCategoryElemNonFinancial ActiveSymbolsBarrierCategoryElem = "non_financial"
const ActiveSymbolsBarrierCategoryElemReset ActiveSymbolsBarrierCategoryElem = "reset"

var enumValues_ActiveSymbolsBarrierCategoryElem = []interface{}{
	"american",
	"asian",
	"euro_atm",
	"euro_non_atm",
	"non_financial",
	"lookback",
	"reset",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ActiveSymbolsBarrierCategoryElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ActiveSymbolsBarrierCategoryElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ActiveSymbolsBarrierCategoryElem, v)
	}
	*j = ActiveSymbolsBarrierCategoryElem(v)
	return nil
}

type ActiveSymbolsContractTypeElem string

const ActiveSymbolsContractTypeElemACCU ActiveSymbolsContractTypeElem = "ACCU"
const ActiveSymbolsContractTypeElemASIAND ActiveSymbolsContractTypeElem = "ASIAND"
const ActiveSymbolsContractTypeElemASIANU ActiveSymbolsContractTypeElem = "ASIANU"
const ActiveSymbolsContractTypeElemCALL ActiveSymbolsContractTypeElem = "CALL"
const ActiveSymbolsContractTypeElemCALLE ActiveSymbolsContractTypeElem = "CALLE"
const ActiveSymbolsContractTypeElemCALLSPREAD ActiveSymbolsContractTypeElem = "CALLSPREAD"
const ActiveSymbolsContractTypeElemDIGITDIFF ActiveSymbolsContractTypeElem = "DIGITDIFF"
const ActiveSymbolsContractTypeElemDIGITEVEN ActiveSymbolsContractTypeElem = "DIGITEVEN"
const ActiveSymbolsContractTypeElemDIGITMATCH ActiveSymbolsContractTypeElem = "DIGITMATCH"
const ActiveSymbolsContractTypeElemDIGITODD ActiveSymbolsContractTypeElem = "DIGITODD"
const ActiveSymbolsContractTypeElemDIGITOVER ActiveSymbolsContractTypeElem = "DIGITOVER"
const ActiveSymbolsContractTypeElemDIGITUNDER ActiveSymbolsContractTypeElem = "DIGITUNDER"
const ActiveSymbolsContractTypeElemEXPIRYMISS ActiveSymbolsContractTypeElem = "EXPIRYMISS"
const ActiveSymbolsContractTypeElemEXPIRYMISSE ActiveSymbolsContractTypeElem = "EXPIRYMISSE"
const ActiveSymbolsContractTypeElemEXPIRYRANGE ActiveSymbolsContractTypeElem = "EXPIRYRANGE"
const ActiveSymbolsContractTypeElemEXPIRYRANGEE ActiveSymbolsContractTypeElem = "EXPIRYRANGEE"
const ActiveSymbolsContractTypeElemLBFLOATCALL ActiveSymbolsContractTypeElem = "LBFLOATCALL"
const ActiveSymbolsContractTypeElemLBFLOATPUT ActiveSymbolsContractTypeElem = "LBFLOATPUT"
const ActiveSymbolsContractTypeElemLBHIGHLOW ActiveSymbolsContractTypeElem = "LBHIGHLOW"
const ActiveSymbolsContractTypeElemMULTDOWN ActiveSymbolsContractTypeElem = "MULTDOWN"
const ActiveSymbolsContractTypeElemMULTUP ActiveSymbolsContractTypeElem = "MULTUP"
const ActiveSymbolsContractTypeElemNOTOUCH ActiveSymbolsContractTypeElem = "NOTOUCH"
const ActiveSymbolsContractTypeElemONETOUCH ActiveSymbolsContractTypeElem = "ONETOUCH"
const ActiveSymbolsContractTypeElemPUT ActiveSymbolsContractTypeElem = "PUT"
const ActiveSymbolsContractTypeElemPUTE ActiveSymbolsContractTypeElem = "PUTE"
const ActiveSymbolsContractTypeElemPUTSPREAD ActiveSymbolsContractTypeElem = "PUTSPREAD"
const ActiveSymbolsContractTypeElemRANGE ActiveSymbolsContractTypeElem = "RANGE"
const ActiveSymbolsContractTypeElemRESETCALL ActiveSymbolsContractTypeElem = "RESETCALL"
const ActiveSymbolsContractTypeElemRESETPUT ActiveSymbolsContractTypeElem = "RESETPUT"
const ActiveSymbolsContractTypeElemRUNHIGH ActiveSymbolsContractTypeElem = "RUNHIGH"
const ActiveSymbolsContractTypeElemRUNLOW ActiveSymbolsContractTypeElem = "RUNLOW"
const ActiveSymbolsContractTypeElemTICKHIGH ActiveSymbolsContractTypeElem = "TICKHIGH"
const ActiveSymbolsContractTypeElemTICKLOW ActiveSymbolsContractTypeElem = "TICKLOW"
const ActiveSymbolsContractTypeElemTURBOSLONG ActiveSymbolsContractTypeElem = "TURBOSLONG"
const ActiveSymbolsContractTypeElemTURBOSSHORT ActiveSymbolsContractTypeElem = "TURBOSSHORT"
const ActiveSymbolsContractTypeElemUPORDOWN ActiveSymbolsContractTypeElem = "UPORDOWN"
const ActiveSymbolsContractTypeElemVANILLALONGCALL ActiveSymbolsContractTypeElem = "VANILLALONGCALL"
const ActiveSymbolsContractTypeElemVANILLALONGPUT ActiveSymbolsContractTypeElem = "VANILLALONGPUT"

var enumValues_ActiveSymbolsContractTypeElem = []interface{}{
	"MULTUP",
	"MULTDOWN",
	"UPORDOWN",
	"EXPIRYRANGE",
	"ONETOUCH",
	"CALLE",
	"LBHIGHLOW",
	"ASIAND",
	"EXPIRYRANGEE",
	"DIGITDIFF",
	"DIGITMATCH",
	"DIGITOVER",
	"PUTE",
	"DIGITUNDER",
	"NOTOUCH",
	"CALL",
	"RANGE",
	"LBFLOATPUT",
	"DIGITODD",
	"PUT",
	"ASIANU",
	"LBFLOATCALL",
	"EXPIRYMISSE",
	"EXPIRYMISS",
	"DIGITEVEN",
	"TICKHIGH",
	"TICKLOW",
	"RESETCALL",
	"RESETPUT",
	"CALLSPREAD",
	"PUTSPREAD",
	"RUNHIGH",
	"RUNLOW",
	"ACCU",
	"VANILLALONGCALL",
	"VANILLALONGPUT",
	"TURBOSLONG",
	"TURBOSSHORT",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ActiveSymbolsContractTypeElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ActiveSymbolsContractTypeElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ActiveSymbolsContractTypeElem, v)
	}
	*j = ActiveSymbolsContractTypeElem(v)
	return nil
}

type ActiveSymbolsLandingCompany string

const ActiveSymbolsLandingCompanyIom ActiveSymbolsLandingCompany = "iom"
const ActiveSymbolsLandingCompanyMalta ActiveSymbolsLandingCompany = "malta"
const ActiveSymbolsLandingCompanyMaltainvest ActiveSymbolsLandingCompany = "maltainvest"

type ActiveSymbolsLandingCompanyShort string

const ActiveSymbolsLandingCompanyShortIom ActiveSymbolsLandingCompanyShort = "iom"
const ActiveSymbolsLandingCompanyShortMalta ActiveSymbolsLandingCompanyShort = "malta"
const ActiveSymbolsLandingCompanyShortMaltainvest ActiveSymbolsLandingCompanyShort = "maltainvest"
const ActiveSymbolsLandingCompanyShortSvg ActiveSymbolsLandingCompanyShort = "svg"
const ActiveSymbolsLandingCompanyShortVanuatu ActiveSymbolsLandingCompanyShort = "vanuatu"
const ActiveSymbolsLandingCompanyShortVirtual ActiveSymbolsLandingCompanyShort = "virtual"

var enumValues_ActiveSymbolsLandingCompanyShort = []interface{}{
	"iom",
	"malta",
	"maltainvest",
	"svg",
	"virtual",
	"vanuatu",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ActiveSymbolsLandingCompanyShort) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ActiveSymbolsLandingCompanyShort {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ActiveSymbolsLandingCompanyShort, v)
	}
	*j = ActiveSymbolsLandingCompanyShort(v)
	return nil
}

const ActiveSymbolsLandingCompanySvg ActiveSymbolsLandingCompany = "svg"
const ActiveSymbolsLandingCompanyVanuatu ActiveSymbolsLandingCompany = "vanuatu"
const ActiveSymbolsLandingCompanyVirtual ActiveSymbolsLandingCompany = "virtual"

var enumValues_ActiveSymbolsLandingCompany = []interface{}{
	"iom",
	"malta",
	"maltainvest",
	"svg",
	"virtual",
	"vanuatu",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ActiveSymbolsLandingCompany) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ActiveSymbolsLandingCompany {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ActiveSymbolsLandingCompany, v)
	}
	*j = ActiveSymbolsLandingCompany(v)
	return nil
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type ActiveSymbolsPassthrough map[string]interface{}

type ActiveSymbolsProductType string

const ActiveSymbolsProductTypeBasic ActiveSymbolsProductType = "basic"

var enumValues_ActiveSymbolsProductType = []interface{}{
	"basic",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ActiveSymbolsProductType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ActiveSymbolsProductType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ActiveSymbolsProductType, v)
	}
	*j = ActiveSymbolsProductType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ActiveSymbols) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["active_symbols"]; raw != nil && !ok {
		return fmt.Errorf("field active_symbols in ActiveSymbols: required")
	}
	type Plain ActiveSymbols
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ActiveSymbols(plain)
	return nil
}
