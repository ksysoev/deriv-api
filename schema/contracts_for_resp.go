// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import "reflect"

// Get the list of currently available contracts
type ContractsForResp struct {
	// List of available contracts. Note: if the user is authenticated, then only
	// contracts allowed under his account will be returned.
	ContractsFor *ContractsForRespContractsFor `json:"contracts_for,omitempty"`

	// Echo of the request made.
	EchoReq ContractsForRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType ContractsForRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// List of available contracts. Note: if the user is authenticated, then only
// contracts allowed under his account will be returned.
type ContractsForRespContractsFor struct {
	// Array of available contracts details
	Available []ContractsForRespContractsForAvailableElem `json:"available"`

	// Symbol's next market-close time as an epoch value
	Close *int `json:"close,omitempty"`

	// Indicates the feed license for symbol, for example whether its realtime or
	// delayed
	FeedLicense *string `json:"feed_license,omitempty"`

	// Count of contracts available
	HitCount *float64 `json:"hit_count,omitempty"`

	// Array of non_available contracts details
	NonAvailable []interface{} `json:"non_available,omitempty"`

	// Symbol's next market-open time as an epoch value
	Open *int `json:"open,omitempty"`

	// Current spot price for this underlying
	Spot *float64 `json:"spot,omitempty"`
}

type ContractsForRespContractsForAvailableElem struct {
	// Array of available barriers for a predefined trading period
	AvailableBarriers []interface{} `json:"available_barriers,omitempty"`

	// Barrier Details.
	Barrier *string `json:"barrier,omitempty"`

	// Category of barrier.
	BarrierCategory string `json:"barrier_category"`

	// [Only for Vanilla] Barrier Choices
	BarrierChoices []interface{} `json:"barrier_choices,omitempty"`

	// Number of barriers.
	Barriers float64 `json:"barriers"`

	// Cancellation range
	CancellationRange []interface{} `json:"cancellation_range,omitempty"`

	// Category of contract.
	ContractCategory string `json:"contract_category"`

	// Category of the contract.
	ContractCategoryDisplay string `json:"contract_category_display"`

	// Display name for the type of contract.
	ContractDisplay *string `json:"contract_display,omitempty"`

	// Type of contract.
	ContractType string `json:"contract_type"`

	// Name of exchange
	ExchangeName string `json:"exchange_name"`

	// Array of barriers already expired
	ExpiredBarriers []interface{} `json:"expired_barriers,omitempty"`

	// Expiry Type.
	ExpiryType string `json:"expiry_type"`

	// Array of returned forward starting options
	ForwardStartingOptions []ContractsForRespContractsForAvailableElemForwardStartingOptionsElem `json:"forward_starting_options,omitempty"`

	// Growth rate range.
	GrowthRateRange []interface{} `json:"growth_rate_range,omitempty"`

	// High barrier Details.
	HighBarrier *string `json:"high_barrier,omitempty"`

	// Last digit range
	LastDigitRange []interface{} `json:"last_digit_range,omitempty"`

	// Low barrier Details.
	LowBarrier *string `json:"low_barrier,omitempty"`

	// Type of market.
	Market string `json:"market"`

	// Maximum contract duration
	MaxContractDuration string `json:"max_contract_duration"`

	// [Only for turbos options] Maximum contract stake
	MaxStake *float64 `json:"max_stake,omitempty"`

	// Minimum contract duration.
	MinContractDuration string `json:"min_contract_duration"`

	// [Only for turbos options] Minimum contract stake
	MinStake *float64 `json:"min_stake,omitempty"`

	// Multiplier range.
	MultiplierRange []interface{} `json:"multiplier_range,omitempty"`

	// Maximum payout.
	PayoutLimit *float64 `json:"payout_limit,omitempty"`

	// Type of sentiment.
	Sentiment string `json:"sentiment"`

	// Start Type.
	StartType string `json:"start_type"`

	// Type of submarket.
	Submarket string `json:"submarket"`

	// A hash of predefined trading period
	TradingPeriod ContractsForRespContractsForAvailableElemTradingPeriod `json:"trading_period,omitempty"`

	// Symbol code
	UnderlyingSymbol string `json:"underlying_symbol"`
}

type ContractsForRespContractsForAvailableElemForwardStartingOptionsElem struct {
	// The epoch value for the blackouts of forward starting session.
	Blackouts []interface{} `json:"blackouts,omitempty"`

	// The epoch value for the closing date of forward starting session.
	Close *string `json:"close,omitempty"`

	// The epoch value for the date of forward starting session.
	Date *string `json:"date,omitempty"`

	// The epoch value for the opening date of forward starting session.
	Open *string `json:"open,omitempty"`
}

// A hash of predefined trading period
type ContractsForRespContractsForAvailableElemTradingPeriod map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractsForRespContractsForAvailableElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["barrier_category"]; raw != nil && !ok {
		return fmt.Errorf("field barrier_category in ContractsForRespContractsForAvailableElem: required")
	}
	if _, ok := raw["barriers"]; raw != nil && !ok {
		return fmt.Errorf("field barriers in ContractsForRespContractsForAvailableElem: required")
	}
	if _, ok := raw["contract_category"]; raw != nil && !ok {
		return fmt.Errorf("field contract_category in ContractsForRespContractsForAvailableElem: required")
	}
	if _, ok := raw["contract_category_display"]; raw != nil && !ok {
		return fmt.Errorf("field contract_category_display in ContractsForRespContractsForAvailableElem: required")
	}
	if _, ok := raw["contract_type"]; raw != nil && !ok {
		return fmt.Errorf("field contract_type in ContractsForRespContractsForAvailableElem: required")
	}
	if _, ok := raw["exchange_name"]; raw != nil && !ok {
		return fmt.Errorf("field exchange_name in ContractsForRespContractsForAvailableElem: required")
	}
	if _, ok := raw["expiry_type"]; raw != nil && !ok {
		return fmt.Errorf("field expiry_type in ContractsForRespContractsForAvailableElem: required")
	}
	if _, ok := raw["market"]; raw != nil && !ok {
		return fmt.Errorf("field market in ContractsForRespContractsForAvailableElem: required")
	}
	if _, ok := raw["max_contract_duration"]; raw != nil && !ok {
		return fmt.Errorf("field max_contract_duration in ContractsForRespContractsForAvailableElem: required")
	}
	if _, ok := raw["min_contract_duration"]; raw != nil && !ok {
		return fmt.Errorf("field min_contract_duration in ContractsForRespContractsForAvailableElem: required")
	}
	if _, ok := raw["sentiment"]; raw != nil && !ok {
		return fmt.Errorf("field sentiment in ContractsForRespContractsForAvailableElem: required")
	}
	if _, ok := raw["start_type"]; raw != nil && !ok {
		return fmt.Errorf("field start_type in ContractsForRespContractsForAvailableElem: required")
	}
	if _, ok := raw["submarket"]; raw != nil && !ok {
		return fmt.Errorf("field submarket in ContractsForRespContractsForAvailableElem: required")
	}
	if _, ok := raw["underlying_symbol"]; raw != nil && !ok {
		return fmt.Errorf("field underlying_symbol in ContractsForRespContractsForAvailableElem: required")
	}
	type Plain ContractsForRespContractsForAvailableElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.AvailableBarriers != nil && len(plain.AvailableBarriers) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "available_barriers", 1)
	}
	if plain.ForwardStartingOptions != nil && len(plain.ForwardStartingOptions) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "forward_starting_options", 1)
	}
	*j = ContractsForRespContractsForAvailableElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractsForRespContractsFor) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["available"]; raw != nil && !ok {
		return fmt.Errorf("field available in ContractsForRespContractsFor: required")
	}
	type Plain ContractsForRespContractsFor
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Available != nil && len(plain.Available) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "available", 1)
	}
	*j = ContractsForRespContractsFor(plain)
	return nil
}

// Echo of the request made.
type ContractsForRespEchoReq map[string]interface{}

type ContractsForRespMsgType string

const ContractsForRespMsgTypeContractsFor ContractsForRespMsgType = "contracts_for"

var enumValues_ContractsForRespMsgType = []interface{}{
	"contracts_for",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractsForRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ContractsForRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ContractsForRespMsgType, v)
	}
	*j = ContractsForRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractsForResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["echo_req"]; raw != nil && !ok {
		return fmt.Errorf("field echo_req in ContractsForResp: required")
	}
	if _, ok := raw["msg_type"]; raw != nil && !ok {
		return fmt.Errorf("field msg_type in ContractsForResp: required")
	}
	type Plain ContractsForResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ContractsForResp(plain)
	return nil
}
