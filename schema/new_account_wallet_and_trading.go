// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import "reflect"

// Create a new account real-money wallet and trading accounts
type NewAccountWalletAndTrading struct {
	// Show whether client has accepted risk disclaimer.
	AcceptRisk *NewAccountWalletAndTradingAcceptRisk `json:"accept_risk,omitempty"`

	// [Optional] Purpose and reason for requesting the account opening.
	AccountOpeningReason *NewAccountWalletAndTradingAccountOpeningReason `json:"account_opening_reason,omitempty"`

	// To set the wallets type - only doughflow and crptyo wallets are allowed for
	// initial phase, other types will be added later
	AccountType NewAccountWalletAndTradingAccountType `json:"account_type"`

	// [Optional] Within 35 characters.
	AddressCity *string `json:"address_city,omitempty"`

	// [Optional] Mailing address.
	AddressLine1 *string `json:"address_line_1,omitempty"`

	// [Optional] Within 70 characters.
	AddressLine2 *string `json:"address_line_2,omitempty"`

	// [Optional] Within 20 characters and may not contain '+'.
	AddressPostcode *string `json:"address_postcode,omitempty"`

	// [Optional] Possible value receive from `states_list` call.
	AddressState *string `json:"address_state,omitempty"`

	// [Optional] Affiliate token, within 32 characters.
	AffiliateToken *string `json:"affiliate_token,omitempty"`

	// [Optional] The phone's calling country code. Don't include the `+` sign. Up to
	// 4 digits.
	CallingCountryCode *string `json:"calling_country_code,omitempty"`

	// [Optional] Country of legal citizenship, 2-letter country code. Possible value
	// receive from `residence_list` call.
	Citizen *string `json:"citizen,omitempty"`

	// [Optional] Indicates whether this is for a client requesting an account with
	// professional status.
	ClientType NewAccountWalletAndTradingClientType `json:"client_type,omitempty"`

	// To set currency of the account. List of supported currencies can be acquired
	// with `payout_currencies` call.
	Currency string `json:"currency"`

	// [Optional] Date of birth format: `yyyy-mm-dd`.
	DateOfBirth *string `json:"date_of_birth,omitempty"`

	// Employment Status.
	EmploymentStatus *string `json:"employment_status,omitempty"`

	// [Optional] Indicates client's self-declaration of FATCA.
	FatcaDeclaration *NewAccountWalletAndTradingFatcaDeclaration `json:"fatca_declaration,omitempty"`

	// Required for maltainvest
	FinancialAssessment NewAccountWalletAndTradingFinancialAssessment `json:"financial_assessment,omitempty"`

	// [Optional] Within 1-50 characters, use only letters, spaces, hyphens,
	// full-stops or apostrophes.
	FirstName *string `json:"first_name,omitempty"`

	// [Optional] Set the landing company of the wallet. Default value is 'svg' if
	// company not provided
	LandingCompanyShort *NewAccountWalletAndTradingLandingCompanyShort `json:"landing_company_short,omitempty"`

	// [Optional] Within 1-50 characters, use only letters, spaces, hyphens,
	// full-stops or apostrophes.
	LastName *string `json:"last_name,omitempty"`

	// [Optional] The login id of the user. Mandatory when multiple tokens were
	// provided during authorize.
	Loginid *string `json:"loginid,omitempty"`

	// Must be `1`
	NewAccountWalletAndTrading NewAccountWalletAndTradingNewAccountWalletAndTrading `json:"new_account_wallet_and_trading"`

	// [Optional] Indicates client's self-declaration of not being a PEP/RCA
	// (Politically Exposed Person/Relatives and Close Associates).
	NonPepDeclaration *int `json:"non_pep_declaration,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough NewAccountWalletAndTradingPassthrough `json:"passthrough,omitempty"`

	// [Optional] The phone's national format, don't include the `+` sign nor the
	// calling country code. Up to 15 digits are allowed.
	Phone *string `json:"phone,omitempty"`

	// [Optional] Place of birth, 2-letter country code.
	PlaceOfBirth *string `json:"place_of_birth,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// 2-letter country code, possible value receive from `residence_list` call.
	Residence *string `json:"residence,omitempty"`

	// [Optional] Indicates client's self declaration for opening account under own
	// initiative, must be 1
	ResidentSelfDeclaration *NewAccountWalletAndTradingResidentSelfDeclaration `json:"resident_self_declaration,omitempty"`

	// Accept any value in enum list.
	Salutation *NewAccountWalletAndTradingSalutation `json:"salutation,omitempty"`

	// Tax identification number. Only applicable for real money account. Required for
	// `maltainvest` landing company.
	TaxIdentificationNumber *string `json:"tax_identification_number,omitempty"`

	// Residence for tax purpose. Comma separated iso country code if multiple
	// jurisdictions. Only applicable for real money account. Required for
	// `maltainvest` landing company.
	TaxResidence *string `json:"tax_residence,omitempty"`

	// [Optional] Whether the client has skipped the TIN form. Only applicable for
	// real money account.
	TinSkipped *NewAccountWalletAndTradingTinSkipped `json:"tin_skipped,omitempty"`

	// The tnc acceptance status of the user.
	TncAcceptance *NewAccountWalletAndTradingTncAcceptance `json:"tnc_acceptance,omitempty"`
}

type NewAccountWalletAndTradingAcceptRisk int

var enumValues_NewAccountWalletAndTradingAcceptRisk = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountWalletAndTradingAcceptRisk) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountWalletAndTradingAcceptRisk {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountWalletAndTradingAcceptRisk, v)
	}
	*j = NewAccountWalletAndTradingAcceptRisk(v)
	return nil
}

type NewAccountWalletAndTradingAccountOpeningReason string

const NewAccountWalletAndTradingAccountOpeningReasonAdditionalRevenue NewAccountWalletAndTradingAccountOpeningReason = "Additional revenue"
const NewAccountWalletAndTradingAccountOpeningReasonHedging NewAccountWalletAndTradingAccountOpeningReason = "Hedging"
const NewAccountWalletAndTradingAccountOpeningReasonIncomeEarning NewAccountWalletAndTradingAccountOpeningReason = "Income Earning"
const NewAccountWalletAndTradingAccountOpeningReasonPeerToPeerExchange NewAccountWalletAndTradingAccountOpeningReason = "Peer-to-peer exchange"
const NewAccountWalletAndTradingAccountOpeningReasonSavings NewAccountWalletAndTradingAccountOpeningReason = "Savings"
const NewAccountWalletAndTradingAccountOpeningReasonSpeculative NewAccountWalletAndTradingAccountOpeningReason = "Speculative"

var enumValues_NewAccountWalletAndTradingAccountOpeningReason = []interface{}{
	"Speculative",
	"Income Earning",
	"Hedging",
	"Peer-to-peer exchange",
	"Additional revenue",
	"Savings",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountWalletAndTradingAccountOpeningReason) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountWalletAndTradingAccountOpeningReason {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountWalletAndTradingAccountOpeningReason, v)
	}
	*j = NewAccountWalletAndTradingAccountOpeningReason(v)
	return nil
}

type NewAccountWalletAndTradingAccountType string

const NewAccountWalletAndTradingAccountTypeCrypto NewAccountWalletAndTradingAccountType = "crypto"
const NewAccountWalletAndTradingAccountTypeDoughflow NewAccountWalletAndTradingAccountType = "doughflow"

var enumValues_NewAccountWalletAndTradingAccountType = []interface{}{
	"doughflow",
	"crypto",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountWalletAndTradingAccountType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountWalletAndTradingAccountType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountWalletAndTradingAccountType, v)
	}
	*j = NewAccountWalletAndTradingAccountType(v)
	return nil
}

type NewAccountWalletAndTradingClientType string

const NewAccountWalletAndTradingClientTypeProfessional NewAccountWalletAndTradingClientType = "professional"
const NewAccountWalletAndTradingClientTypeRetail NewAccountWalletAndTradingClientType = "retail"

var enumValues_NewAccountWalletAndTradingClientType = []interface{}{
	"professional",
	"retail",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountWalletAndTradingClientType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountWalletAndTradingClientType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountWalletAndTradingClientType, v)
	}
	*j = NewAccountWalletAndTradingClientType(v)
	return nil
}

type NewAccountWalletAndTradingFatcaDeclaration int

var enumValues_NewAccountWalletAndTradingFatcaDeclaration = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountWalletAndTradingFatcaDeclaration) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountWalletAndTradingFatcaDeclaration {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountWalletAndTradingFatcaDeclaration, v)
	}
	*j = NewAccountWalletAndTradingFatcaDeclaration(v)
	return nil
}

// Required for maltainvest
type NewAccountWalletAndTradingFinancialAssessment map[string]interface{}

type NewAccountWalletAndTradingLandingCompanyShort string

const NewAccountWalletAndTradingLandingCompanyShortMaltainvest NewAccountWalletAndTradingLandingCompanyShort = "maltainvest"
const NewAccountWalletAndTradingLandingCompanyShortSvg NewAccountWalletAndTradingLandingCompanyShort = "svg"

var enumValues_NewAccountWalletAndTradingLandingCompanyShort = []interface{}{
	"maltainvest",
	"svg",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountWalletAndTradingLandingCompanyShort) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountWalletAndTradingLandingCompanyShort {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountWalletAndTradingLandingCompanyShort, v)
	}
	*j = NewAccountWalletAndTradingLandingCompanyShort(v)
	return nil
}

type NewAccountWalletAndTradingNewAccountWalletAndTrading int

var enumValues_NewAccountWalletAndTradingNewAccountWalletAndTrading = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountWalletAndTradingNewAccountWalletAndTrading) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountWalletAndTradingNewAccountWalletAndTrading {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountWalletAndTradingNewAccountWalletAndTrading, v)
	}
	*j = NewAccountWalletAndTradingNewAccountWalletAndTrading(v)
	return nil
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type NewAccountWalletAndTradingPassthrough map[string]interface{}

type NewAccountWalletAndTradingResidentSelfDeclaration int

var enumValues_NewAccountWalletAndTradingResidentSelfDeclaration = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountWalletAndTradingResidentSelfDeclaration) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountWalletAndTradingResidentSelfDeclaration {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountWalletAndTradingResidentSelfDeclaration, v)
	}
	*j = NewAccountWalletAndTradingResidentSelfDeclaration(v)
	return nil
}

type NewAccountWalletAndTradingSalutation string

const NewAccountWalletAndTradingSalutationMiss NewAccountWalletAndTradingSalutation = "Miss"
const NewAccountWalletAndTradingSalutationMr NewAccountWalletAndTradingSalutation = "Mr"
const NewAccountWalletAndTradingSalutationMrs NewAccountWalletAndTradingSalutation = "Mrs"
const NewAccountWalletAndTradingSalutationMs NewAccountWalletAndTradingSalutation = "Ms"

var enumValues_NewAccountWalletAndTradingSalutation = []interface{}{
	"Mr",
	"Ms",
	"Miss",
	"Mrs",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountWalletAndTradingSalutation) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountWalletAndTradingSalutation {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountWalletAndTradingSalutation, v)
	}
	*j = NewAccountWalletAndTradingSalutation(v)
	return nil
}

type NewAccountWalletAndTradingTinSkipped int

var enumValues_NewAccountWalletAndTradingTinSkipped = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountWalletAndTradingTinSkipped) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountWalletAndTradingTinSkipped {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountWalletAndTradingTinSkipped, v)
	}
	*j = NewAccountWalletAndTradingTinSkipped(v)
	return nil
}

type NewAccountWalletAndTradingTncAcceptance int

var enumValues_NewAccountWalletAndTradingTncAcceptance = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountWalletAndTradingTncAcceptance) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountWalletAndTradingTncAcceptance {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountWalletAndTradingTncAcceptance, v)
	}
	*j = NewAccountWalletAndTradingTncAcceptance(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountWalletAndTrading) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["account_type"]; raw != nil && !ok {
		return fmt.Errorf("field account_type in NewAccountWalletAndTrading: required")
	}
	if _, ok := raw["currency"]; raw != nil && !ok {
		return fmt.Errorf("field currency in NewAccountWalletAndTrading: required")
	}
	if _, ok := raw["new_account_wallet_and_trading"]; raw != nil && !ok {
		return fmt.Errorf("field new_account_wallet_and_trading in NewAccountWalletAndTrading: required")
	}
	type Plain NewAccountWalletAndTrading
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["client_type"]; !ok || v == nil {
		plain.ClientType = "retail"
	}
	*j = NewAccountWalletAndTrading(plain)
	return nil
}
