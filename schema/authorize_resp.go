// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import "reflect"

// A message containing account information for the holder of that token.
type AuthorizeResp struct {
	// Account information for the holder of the token.
	Authorize *AuthorizeRespAuthorize `json:"authorize,omitempty"`

	// Echo of the request made.
	EchoReq AuthorizeRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType AuthorizeRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Account information for the holder of the token.
type AuthorizeRespAuthorize struct {
	// List of accounts for current user. This is also available from the
	// `account_list` call.
	AccountList []AuthorizeRespAuthorizeAccountListElem `json:"account_list,omitempty"`

	// Cash balance of the account.
	Balance *float64 `json:"balance,omitempty"`

	// 2-letter country code (ISO standard).
	Country *string `json:"country,omitempty"`

	// Currency of the account.
	Currency *string `json:"currency,omitempty"`

	// User email.
	Email *string `json:"email,omitempty"`

	// User's full name. Will be empty for virtual accounts.
	Fullname *string `json:"fullname,omitempty"`

	// Boolean value: 1 or 0, indicating whether the account is a virtual-money
	// account.
	IsVirtual *AuthorizeRespAuthorizeIsVirtual `json:"is_virtual,omitempty"`

	// Landing company name the account belongs to.
	LandingCompanyFullname *string `json:"landing_company_fullname,omitempty"`

	// Landing company shortcode the account belongs to.
	LandingCompanyName *string `json:"landing_company_name,omitempty"`

	// Details of the list of Trading accounts linked to the Wallet account.
	LinkedTo []AuthorizeRespAuthorizeLinkedToElem `json:"linked_to,omitempty"`

	// Currencies in client's residence country
	LocalCurrencies AuthorizeRespAuthorizeLocalCurrencies `json:"local_currencies,omitempty"`

	// The account ID that the token was issued for.
	Loginid *string `json:"loginid,omitempty"`

	// User's preferred language, ISO standard code of language
	PreferredLanguage *string `json:"preferred_language,omitempty"`

	// Scopes available to the token.
	Scopes []string `json:"scopes,omitempty"`

	// List of landing company shortcodes the account can upgrade to.
	UpgradeableLandingCompanies []interface{} `json:"upgradeable_landing_companies,omitempty"`

	// The internal user ID for this account.
	UserId *int `json:"user_id,omitempty"`
}

type AuthorizeRespAuthorizeAccountListElem struct {
	// Account category.
	AccountCategory *AuthorizeRespAuthorizeAccountListElemAccountCategory `json:"account_category,omitempty"`

	// Account type.
	AccountType *string `json:"account_type,omitempty"`

	// 2 letter broker code.
	Broker *string `json:"broker,omitempty"`

	// Creation time of the account as epoch.
	CreatedAt *int `json:"created_at,omitempty"`

	// Currency of specified account.
	Currency *string `json:"currency,omitempty"`

	// Epoch of date till client has excluded him/herself from the website, only
	// present if client is self excluded.
	ExcludedUntil *int `json:"excluded_until,omitempty"`

	// Boolean value: 1 or 0, indicating whether the account is marked as disabled or
	// not.
	IsDisabled *AuthorizeRespAuthorizeAccountListElemIsDisabled `json:"is_disabled,omitempty"`

	// Boolean value: 1 or 0, indicating whether the account is a virtual-money
	// account.
	IsVirtual *AuthorizeRespAuthorizeAccountListElemIsVirtual `json:"is_virtual,omitempty"`

	// Landing company shortcode the account belongs to.
	LandingCompanyName *string `json:"landing_company_name,omitempty"`

	// Details of the list of Trading accounts linked to the Wallet account.
	LinkedTo []AuthorizeRespAuthorizeAccountListElemLinkedToElem `json:"linked_to,omitempty"`

	// The account ID of specified account.
	Loginid *string `json:"loginid,omitempty"`
}

type AuthorizeRespAuthorizeAccountListElemAccountCategory string

const AuthorizeRespAuthorizeAccountListElemAccountCategoryTrading AuthorizeRespAuthorizeAccountListElemAccountCategory = "trading"
const AuthorizeRespAuthorizeAccountListElemAccountCategoryWallet AuthorizeRespAuthorizeAccountListElemAccountCategory = "wallet"

type AuthorizeRespAuthorizeAccountListElemIsDisabled int

type AuthorizeRespAuthorizeAccountListElemIsVirtual int

type AuthorizeRespAuthorizeAccountListElemLinkedToElem struct {
	// Account ID.
	Loginid *string `json:"loginid,omitempty"`

	// Account platform name.
	Platform *AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatform `json:"platform,omitempty"`
}

type AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatform string

const AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatformCtrader AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatform = "ctrader"
const AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatformDerivez AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatform = "derivez"
const AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatformDtrade AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatform = "dtrade"
const AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatformDwallet AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatform = "dwallet"
const AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatformDxtrade AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatform = "dxtrade"
const AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatformMt5 AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatform = "mt5"

type AuthorizeRespAuthorizeIsVirtual int

type AuthorizeRespAuthorizeLinkedToElem struct {
	// Account ID.
	Loginid *string `json:"loginid,omitempty"`

	// Account platform name.
	Platform *AuthorizeRespAuthorizeLinkedToElemPlatform `json:"platform,omitempty"`
}

type AuthorizeRespAuthorizeLinkedToElemPlatform string

const AuthorizeRespAuthorizeLinkedToElemPlatformCtrader AuthorizeRespAuthorizeLinkedToElemPlatform = "ctrader"
const AuthorizeRespAuthorizeLinkedToElemPlatformDerivez AuthorizeRespAuthorizeLinkedToElemPlatform = "derivez"
const AuthorizeRespAuthorizeLinkedToElemPlatformDtrade AuthorizeRespAuthorizeLinkedToElemPlatform = "dtrade"
const AuthorizeRespAuthorizeLinkedToElemPlatformDwallet AuthorizeRespAuthorizeLinkedToElemPlatform = "dwallet"
const AuthorizeRespAuthorizeLinkedToElemPlatformDxtrade AuthorizeRespAuthorizeLinkedToElemPlatform = "dxtrade"
const AuthorizeRespAuthorizeLinkedToElemPlatformMt5 AuthorizeRespAuthorizeLinkedToElemPlatform = "mt5"

// Currencies in client's residence country
type AuthorizeRespAuthorizeLocalCurrencies map[string]interface{}

// Echo of the request made.
type AuthorizeRespEchoReq map[string]interface{}

type AuthorizeRespMsgType string

const AuthorizeRespMsgTypeAuthorize AuthorizeRespMsgType = "authorize"

var enumValues_AuthorizeRespAuthorizeAccountListElemAccountCategory = []interface{}{
	"trading",
	"wallet",
}
var enumValues_AuthorizeRespAuthorizeAccountListElemIsDisabled = []interface{}{
	1,
	0,
}
var enumValues_AuthorizeRespAuthorizeAccountListElemIsVirtual = []interface{}{
	1,
	0,
}
var enumValues_AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatform = []interface{}{
	"ctrader",
	"derivez",
	"dtrade",
	"dwallet",
	"dxtrade",
	"mt5",
}
var enumValues_AuthorizeRespAuthorizeIsVirtual = []interface{}{
	0,
	1,
}
var enumValues_AuthorizeRespAuthorizeLinkedToElemPlatform = []interface{}{
	"ctrader",
	"derivez",
	"dtrade",
	"dwallet",
	"dxtrade",
	"mt5",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatform) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatform {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatform, v)
	}
	*j = AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatform(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuthorizeRespAuthorizeAccountListElemAccountCategory) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AuthorizeRespAuthorizeAccountListElemAccountCategory {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AuthorizeRespAuthorizeAccountListElemAccountCategory, v)
	}
	*j = AuthorizeRespAuthorizeAccountListElemAccountCategory(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuthorizeRespAuthorizeAccountListElemIsDisabled) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AuthorizeRespAuthorizeAccountListElemIsDisabled {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AuthorizeRespAuthorizeAccountListElemIsDisabled, v)
	}
	*j = AuthorizeRespAuthorizeAccountListElemIsDisabled(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuthorizeRespAuthorizeAccountListElemIsVirtual) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AuthorizeRespAuthorizeAccountListElemIsVirtual {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AuthorizeRespAuthorizeAccountListElemIsVirtual, v)
	}
	*j = AuthorizeRespAuthorizeAccountListElemIsVirtual(v)
	return nil
}

var enumValues_AuthorizeRespMsgType = []interface{}{
	"authorize",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuthorizeRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AuthorizeRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AuthorizeRespMsgType, v)
	}
	*j = AuthorizeRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuthorizeRespAuthorizeIsVirtual) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AuthorizeRespAuthorizeIsVirtual {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AuthorizeRespAuthorizeIsVirtual, v)
	}
	*j = AuthorizeRespAuthorizeIsVirtual(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuthorizeRespAuthorizeLinkedToElemPlatform) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AuthorizeRespAuthorizeLinkedToElemPlatform {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AuthorizeRespAuthorizeLinkedToElemPlatform, v)
	}
	*j = AuthorizeRespAuthorizeLinkedToElemPlatform(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuthorizeResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req in AuthorizeResp: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type in AuthorizeResp: required")
	}
	type Plain AuthorizeResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AuthorizeResp(plain)
	return nil
}
