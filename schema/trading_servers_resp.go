// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import "reflect"

// Get list of servers for the platform provided.
type TradingServersResp struct {
	// Echo of the request made.
	EchoReq TradingServersRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType TradingServersRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// Array containing platform server objects.
	TradingServers []TradingServersRespTradingServersElem `json:"trading_servers,omitempty"`
}

// Echo of the request made.
type TradingServersRespEchoReq map[string]interface{}

type TradingServersRespMsgType string

const TradingServersRespMsgTypeTradingServers TradingServersRespMsgType = "trading_servers"

var enumValues_TradingServersRespMsgType = []interface{}{
	"trading_servers",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingServersRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TradingServersRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TradingServersRespMsgType, v)
	}
	*j = TradingServersRespMsgType(v)
	return nil
}

type TradingServersRespTradingServersElem struct {
	// Supported trading account type.
	AccountType *TradingServersRespTradingServersElemAccountType `json:"account_type,omitempty"`

	// Flag to represent if this server is currently disabled or not
	Disabled *TradingServersRespTradingServersElemDisabled `json:"disabled,omitempty"`

	// Current environment (installation instance) where servers are deployed.
	// Currently, there are one demo and two real environments.
	Environment *TradingServersRespTradingServersElemEnvironment `json:"environment,omitempty"`

	// Object containing geolocation information of the server.
	Geolocation *TradingServersRespTradingServersElemGeolocation `json:"geolocation,omitempty"`

	// Server unique id.
	Id *TradingServersRespTradingServersElemId `json:"id,omitempty"`

	// Market type
	MarketType *string `json:"market_type,omitempty"`

	// Error message to client when server is disabled
	MessageToClient *string `json:"message_to_client,omitempty"`

	// Flag to represent if this is server is recommended based on client's country of
	// residence.
	Recommended *TradingServersRespTradingServersElemRecommended `json:"recommended,omitempty"`

	// Account type supported by the server.
	SupportedAccounts []string `json:"supported_accounts,omitempty"`
}

type TradingServersRespTradingServersElemAccountType string

const TradingServersRespTradingServersElemAccountTypeDemo TradingServersRespTradingServersElemAccountType = "demo"
const TradingServersRespTradingServersElemAccountTypeReal TradingServersRespTradingServersElemAccountType = "real"

var enumValues_TradingServersRespTradingServersElemAccountType = []interface{}{
	"demo",
	"real",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingServersRespTradingServersElemAccountType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TradingServersRespTradingServersElemAccountType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TradingServersRespTradingServersElemAccountType, v)
	}
	*j = TradingServersRespTradingServersElemAccountType(v)
	return nil
}

type TradingServersRespTradingServersElemDisabled int

var enumValues_TradingServersRespTradingServersElemDisabled = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingServersRespTradingServersElemDisabled) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TradingServersRespTradingServersElemDisabled {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TradingServersRespTradingServersElemDisabled, v)
	}
	*j = TradingServersRespTradingServersElemDisabled(v)
	return nil
}

type TradingServersRespTradingServersElemEnvironment string

const TradingServersRespTradingServersElemEnvironmentDerivDemo TradingServersRespTradingServersElemEnvironment = "Deriv-Demo"
const TradingServersRespTradingServersElemEnvironmentDerivServer TradingServersRespTradingServersElemEnvironment = "Deriv-Server"
const TradingServersRespTradingServersElemEnvironmentDerivServer02 TradingServersRespTradingServersElemEnvironment = "Deriv-Server-02"
const TradingServersRespTradingServersElemEnvironmentDerivServer03 TradingServersRespTradingServersElemEnvironment = "Deriv-Server-03"

var enumValues_TradingServersRespTradingServersElemEnvironment = []interface{}{
	"Deriv-Demo",
	"Deriv-Server",
	"Deriv-Server-02",
	"Deriv-Server-03",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingServersRespTradingServersElemEnvironment) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TradingServersRespTradingServersElemEnvironment {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TradingServersRespTradingServersElemEnvironment, v)
	}
	*j = TradingServersRespTradingServersElemEnvironment(v)
	return nil
}

// Object containing geolocation information of the server.
type TradingServersRespTradingServersElemGeolocation struct {
	// Internal server grouping.
	Group *string `json:"group,omitempty"`

	// Geolocation country or place where server is located.
	Location *string `json:"location,omitempty"`

	// Geolocation region where server is located.
	Region *string `json:"region,omitempty"`

	// Sequence number of the server in that region.
	Sequence *int `json:"sequence,omitempty"`
}

type TradingServersRespTradingServersElemId string

const TradingServersRespTradingServersElemIdP01Ts01 TradingServersRespTradingServersElemId = "p01_ts01"
const TradingServersRespTradingServersElemIdP01Ts02 TradingServersRespTradingServersElemId = "p01_ts02"
const TradingServersRespTradingServersElemIdP01Ts03 TradingServersRespTradingServersElemId = "p01_ts03"
const TradingServersRespTradingServersElemIdP01Ts04 TradingServersRespTradingServersElemId = "p01_ts04"
const TradingServersRespTradingServersElemIdP02Ts02 TradingServersRespTradingServersElemId = "p02_ts02"
const TradingServersRespTradingServersElemIdP03Ts01 TradingServersRespTradingServersElemId = "p03_ts01"

var enumValues_TradingServersRespTradingServersElemId = []interface{}{
	"p01_ts01",
	"p01_ts02",
	"p01_ts03",
	"p01_ts04",
	"p02_ts02",
	"p03_ts01",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingServersRespTradingServersElemId) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TradingServersRespTradingServersElemId {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TradingServersRespTradingServersElemId, v)
	}
	*j = TradingServersRespTradingServersElemId(v)
	return nil
}

type TradingServersRespTradingServersElemRecommended int

var enumValues_TradingServersRespTradingServersElemRecommended = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingServersRespTradingServersElemRecommended) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TradingServersRespTradingServersElemRecommended {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TradingServersRespTradingServersElemRecommended, v)
	}
	*j = TradingServersRespTradingServersElemRecommended(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingServersResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["echo_req"]; raw != nil && !ok {
		return fmt.Errorf("field echo_req in TradingServersResp: required")
	}
	if _, ok := raw["msg_type"]; raw != nil && !ok {
		return fmt.Errorf("field msg_type in TradingServersResp: required")
	}
	type Plain TradingServersResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TradingServersResp(plain)
	return nil
}
