// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import "reflect"

// Echo of the request made.
type ProfitTableRespEchoReq map[string]interface{}

type ProfitTableRespMsgType string

var enumValues_ProfitTableRespMsgType = []interface{}{
	"profit_table",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProfitTableRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProfitTableRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProfitTableRespMsgType, v)
	}
	*j = ProfitTableRespMsgType(v)
	return nil
}

// A summary of account profit table is received
type ProfitTableResp struct {
	// Echo of the request made.
	EchoReq ProfitTableRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType ProfitTableRespMsgType `json:"msg_type"`

	// Account Profit Table.
	ProfitTable *ProfitTableRespProfitTable `json:"profit_table,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

const ProfitTableRespMsgTypeProfitTable ProfitTableRespMsgType = "profit_table"

// Account Profit Table.
type ProfitTableRespProfitTable struct {
	// Number of transactions returned in this call
	Count *float64 `json:"count,omitempty"`

	// Array of returned transactions
	Transactions []ProfitTableRespProfitTableTransactionsElem `json:"transactions,omitempty"`
}

type ProfitTableRespProfitTableTransactionsElem struct {
	// ID of the application where this contract was purchased.
	AppId *int `json:"app_id,omitempty"`

	// The buy price
	BuyPrice *float64 `json:"buy_price,omitempty"`

	// The unique contract identifier.
	ContractId *int `json:"contract_id,omitempty"`

	// [Optional] The contract type for the transaction if description is set to 1.
	ContractType *string `json:"contract_type,omitempty"`

	// [Optional] Duration set for deal cancellation for Multiplier contracts in
	// synthetic indices if description is set to 1.
	DealCancellationDuration *string `json:"deal_cancellation_duration,omitempty"`

	// [Optional] The duration type of the contract if description is set to 1.
	DurationType *string `json:"duration_type,omitempty"`

	// [Optional] The growth rate for Accumulators contract if description is set to
	// 1.
	GrowthRate *string `json:"growth_rate,omitempty"`

	// [Optional] The description of contract purchased if description is set to 1
	Longcode *string `json:"longcode,omitempty"`

	// [Optional] The multiplier for Multiplier contracts if description is set to 1.
	Multiplier *string `json:"multiplier,omitempty"`

	// Payout price
	Payout *float64 `json:"payout,omitempty"`

	// Epoch purchase time of the transaction
	PurchaseTime *int `json:"purchase_time,omitempty"`

	// The price the contract sold for.
	SellPrice *float64 `json:"sell_price,omitempty"`

	// Epoch sell time of the transaction
	SellTime *int `json:"sell_time,omitempty"`

	// [Optional] Compact description of the contract purchased if description is set
	// to 1
	Shortcode *string `json:"shortcode,omitempty"`

	// The transaction Identifier. Every contract (buy or sell) and every payment has
	// a unique transaction identifier.
	TransactionId *int `json:"transaction_id,omitempty"`

	// [Optional] Symbol code if description is set to 1
	UnderlyingSymbol *string `json:"underlying_symbol,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProfitTableResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req in ProfitTableResp: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type in ProfitTableResp: required")
	}
	type Plain ProfitTableResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ProfitTableResp(plain)
	return nil
}
