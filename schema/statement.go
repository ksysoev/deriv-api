// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import "reflect"

// Retrieve a summary of account transactions, according to given search criteria
type Statement struct {
	// [Optional] To filter the statement according to the type of transaction.
	ActionType *StatementActionType `json:"action_type,omitempty"`

	// [Optional] Start date (epoch)
	DateFrom *int `json:"date_from,omitempty"`

	// [Optional] End date (epoch)
	DateTo *int `json:"date_to,omitempty"`

	// [Optional] If set to 1, will return full contracts description.
	Description *StatementDescription `json:"description,omitempty"`

	// [Optional] Maximum number of transactions to receive.
	Limit float64 `json:"limit,omitempty"`

	// [Optional] The login id of the user. If left unspecified, it defaults to the
	// initial authorized token's login id.
	Loginid *string `json:"loginid,omitempty"`

	// [Optional] Number of transactions to skip.
	Offset *int `json:"offset,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough StatementPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// Must be `1`
	Statement StatementStatement `json:"statement"`
}

type StatementActionType string

const StatementActionTypeAdjustment StatementActionType = "adjustment"
const StatementActionTypeBuy StatementActionType = "buy"
const StatementActionTypeDeposit StatementActionType = "deposit"
const StatementActionTypeEscrow StatementActionType = "escrow"
const StatementActionTypeSell StatementActionType = "sell"
const StatementActionTypeTransfer StatementActionType = "transfer"
const StatementActionTypeVirtualCredit StatementActionType = "virtual_credit"
const StatementActionTypeWithdrawal StatementActionType = "withdrawal"

// UnmarshalJSON implements json.Unmarshaler.
func (j *StatementActionType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_StatementActionType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_StatementActionType, v)
	}
	*j = StatementActionType(v)
	return nil
}

type StatementDescription int

var enumValues_StatementDescription = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StatementDescription) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_StatementDescription {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_StatementDescription, v)
	}
	*j = StatementDescription(v)
	return nil
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type StatementPassthrough map[string]interface{}

type StatementStatement int

var enumValues_StatementStatement = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StatementStatement) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_StatementStatement {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_StatementStatement, v)
	}
	*j = StatementStatement(v)
	return nil
}

var enumValues_StatementActionType = []interface{}{
	"buy",
	"sell",
	"deposit",
	"withdrawal",
	"escrow",
	"adjustment",
	"virtual_credit",
	"transfer",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Statement) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["statement"]; !ok || v == nil {
		return fmt.Errorf("field statement in Statement: required")
	}
	type Plain Statement
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["limit"]; !ok || v == nil {
		plain.Limit = 100.0
	}
	*j = Statement(plain)
	return nil
}
