// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import "reflect"

// Latest spot price for a group symbols. Continuous responses with a frequency of
// up to one second.
type TicksBatchResp struct {
	// Echo of the request made.
	EchoReq TicksBatchRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType TicksBatchRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// For subscription requests only.
	Subscription *TicksBatchRespSubscription `json:"subscription,omitempty"`

	// Tick by tick list of streamed data for a group of symbols
	TicksBatch []TicksBatchRespTicksBatchElem `json:"ticks_batch,omitempty"`
}

// Echo of the request made.
type TicksBatchRespEchoReq map[string]interface{}

type TicksBatchRespMsgType string

const TicksBatchRespMsgTypeTicksBatch TicksBatchRespMsgType = "ticks_batch"

var enumValues_TicksBatchRespMsgType = []interface{}{
	"ticks_batch",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TicksBatchRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TicksBatchRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TicksBatchRespMsgType, v)
	}
	*j = TicksBatchRespMsgType(v)
	return nil
}

// For subscription requests only.
type TicksBatchRespSubscription struct {
	// A per-connection unique identifier. Can be passed to the `forget` API call to
	// unsubscribe.
	Id string `json:"id"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TicksBatchRespSubscription) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in TicksBatchRespSubscription: required")
	}
	type Plain TicksBatchRespSubscription
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TicksBatchRespSubscription(plain)
	return nil
}

type TicksBatchRespTicksBatchElem struct {
	// Market ask at the epoch
	Ask string `json:"ask"`

	// Market bid at the epoch
	Bid string `json:"bid"`

	// Daily percentage change
	Change string `json:"change"`

	// Epoch time of the tick
	Epoch int `json:"epoch"`

	// Market value at the epoch
	Quote string `json:"quote"`

	// Symbol
	Symbol string `json:"symbol"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TicksBatchRespTicksBatchElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["ask"]; raw != nil && !ok {
		return fmt.Errorf("field ask in TicksBatchRespTicksBatchElem: required")
	}
	if _, ok := raw["bid"]; raw != nil && !ok {
		return fmt.Errorf("field bid in TicksBatchRespTicksBatchElem: required")
	}
	if _, ok := raw["change"]; raw != nil && !ok {
		return fmt.Errorf("field change in TicksBatchRespTicksBatchElem: required")
	}
	if _, ok := raw["epoch"]; raw != nil && !ok {
		return fmt.Errorf("field epoch in TicksBatchRespTicksBatchElem: required")
	}
	if _, ok := raw["quote"]; raw != nil && !ok {
		return fmt.Errorf("field quote in TicksBatchRespTicksBatchElem: required")
	}
	if _, ok := raw["symbol"]; raw != nil && !ok {
		return fmt.Errorf("field symbol in TicksBatchRespTicksBatchElem: required")
	}
	type Plain TicksBatchRespTicksBatchElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TicksBatchRespTicksBatchElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TicksBatchResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["echo_req"]; raw != nil && !ok {
		return fmt.Errorf("field echo_req in TicksBatchResp: required")
	}
	if _, ok := raw["msg_type"]; raw != nil && !ok {
		return fmt.Errorf("field msg_type in TicksBatchResp: required")
	}
	type Plain TicksBatchResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TicksBatchResp(plain)
	return nil
}
