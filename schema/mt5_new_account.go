// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import "reflect"

// This call creates new MT5 user, either demo or real money user.
type Mt5NewAccount struct {
	// Account type. If set to 'financial', setting 'mt5_account_type' is also
	// required.
	AccountType Mt5NewAccountAccountType `json:"account_type"`

	// [Optional] The address of the user. The maximum length of this address field is
	// 128 characters.
	Address *string `json:"address,omitempty"`

	// [Optional] User's city of residence.
	City *string `json:"city,omitempty"`

	// [Optional] Name of the client's company. The maximum length of the company name
	// is 64 characters.
	Company *string `json:"company,omitempty"`

	// [Optional] 2-letter country code (value received from `residence_list` call).
	Country *string `json:"country,omitempty"`

	// [Optional] MT5 account currency, the default value will be the qualified
	// account currency.
	Currency *string `json:"currency,omitempty"`

	// [Optional] If set to 1, only validation is performed.
	DryRun Mt5NewAccountDryRun `json:"dry_run,omitempty"`

	// Email address
	Email string `json:"email"`

	// [Optional] The investor password of the account. For validation (Accepts any
	// printable ASCII character. Must be within 8-25 characters, and include numbers,
	// lowercase and uppercase letters. Must not be the same as the user's email
	// address).
	InvestPassword *string `json:"investPassword,omitempty"`

	// Client leverage (from 1 to 1000).
	Leverage float64 `json:"leverage"`

	// [Optional] The login id of the user. Mandatory when multiple tokens were
	// provided during authorize.
	Loginid *string `json:"loginid,omitempty"`

	// The master password of the account. For validation (Accepts any printable ASCII
	// character. Must be within 8-25 characters, and include numbers, lowercase and
	// uppercase letters. Must not be the same as the user's email address). This
	// field is required.
	MainPassword string `json:"mainPassword"`

	// [Optional] Indicates whether the user would like to migrate his account to
	// other jurisdiction.
	Migrate *bool `json:"migrate,omitempty"`

	// [Optional] To choose whether account is conventional or swap_free. Unavailable
	// for financial_stp MT5_account_type
	Mt5AccountCategory *Mt5NewAccountMt5AccountCategory `json:"mt5_account_category,omitempty"`

	// [Optional] Financial: Variable spreads, High leverage. Financial STP: Variable
	// spreads, Medium Leverage, more products. If 'account_type' set to 'financial',
	// setting 'mt5_account_type' is also required.
	Mt5AccountType *Mt5NewAccountMt5AccountType `json:"mt5_account_type,omitempty"`

	// Must be `1`
	Mt5NewAccount Mt5NewAccountMt5NewAccount `json:"mt5_new_account"`

	// Client's name. The maximum length here is 101 characters.
	Name string `json:"name"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough Mt5NewAccountPassthrough `json:"passthrough,omitempty"`

	// [Optional] User's phone number.
	Phone *string `json:"phone,omitempty"`

	// [Optional] The user's phone password.
	PhonePassword *string `json:"phonePassword,omitempty"`

	// Product name that Deriv offer
	Product *Mt5NewAccountProduct `json:"product,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// [Optional] Trade server.
	Server *Mt5NewAccountServer `json:"server,omitempty"`

	// [Optional] User's state (region) of residence.
	State *string `json:"state,omitempty"`

	// [Optional] Indicate the additional risk management for each account
	SubAccountCategory *Mt5NewAccountSubAccountCategory `json:"sub_account_category,omitempty"`

	// [Optional] Indicate the different offerings for mt5 account
	SubAccountType *Mt5NewAccountSubAccountType `json:"sub_account_type,omitempty"`

	// [Optional] User's zip code.
	ZipCode *string `json:"zipCode,omitempty"`
}

type Mt5NewAccountAccountType string

const Mt5NewAccountAccountTypeAll Mt5NewAccountAccountType = "all"
const Mt5NewAccountAccountTypeDemo Mt5NewAccountAccountType = "demo"
const Mt5NewAccountAccountTypeFinancial Mt5NewAccountAccountType = "financial"
const Mt5NewAccountAccountTypeGaming Mt5NewAccountAccountType = "gaming"

var enumValues_Mt5NewAccountAccountType = []interface{}{
	"demo",
	"gaming",
	"financial",
	"all",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5NewAccountAccountType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5NewAccountAccountType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5NewAccountAccountType, v)
	}
	*j = Mt5NewAccountAccountType(v)
	return nil
}

type Mt5NewAccountDryRun int

var enumValues_Mt5NewAccountDryRun = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5NewAccountDryRun) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5NewAccountDryRun {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5NewAccountDryRun, v)
	}
	*j = Mt5NewAccountDryRun(v)
	return nil
}

type Mt5NewAccountMt5AccountCategory string

const Mt5NewAccountMt5AccountCategoryConventional Mt5NewAccountMt5AccountCategory = "conventional"
const Mt5NewAccountMt5AccountCategoryGold Mt5NewAccountMt5AccountCategory = "gold"
const Mt5NewAccountMt5AccountCategorySwapFree Mt5NewAccountMt5AccountCategory = "swap_free"

var enumValues_Mt5NewAccountMt5AccountCategory = []interface{}{
	"conventional",
	"swap_free",
	"gold",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5NewAccountMt5AccountCategory) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5NewAccountMt5AccountCategory {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5NewAccountMt5AccountCategory, v)
	}
	*j = Mt5NewAccountMt5AccountCategory(v)
	return nil
}

type Mt5NewAccountMt5AccountType string

const Mt5NewAccountMt5AccountTypeFinancial Mt5NewAccountMt5AccountType = "financial"
const Mt5NewAccountMt5AccountTypeFinancialStp Mt5NewAccountMt5AccountType = "financial_stp"
const Mt5NewAccountMt5AccountTypeGold Mt5NewAccountMt5AccountType = "gold"

var enumValues_Mt5NewAccountMt5AccountType = []interface{}{
	"financial",
	"financial_stp",
	"gold",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5NewAccountMt5AccountType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5NewAccountMt5AccountType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5NewAccountMt5AccountType, v)
	}
	*j = Mt5NewAccountMt5AccountType(v)
	return nil
}

type Mt5NewAccountMt5NewAccount int

var enumValues_Mt5NewAccountMt5NewAccount = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5NewAccountMt5NewAccount) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5NewAccountMt5NewAccount {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5NewAccountMt5NewAccount, v)
	}
	*j = Mt5NewAccountMt5NewAccount(v)
	return nil
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type Mt5NewAccountPassthrough map[string]interface{}

type Mt5NewAccountProduct string

const Mt5NewAccountProductBlank Mt5NewAccountProduct = ""
const Mt5NewAccountProductFinancial Mt5NewAccountProduct = "financial"
const Mt5NewAccountProductGold Mt5NewAccountProduct = "gold"
const Mt5NewAccountProductStandard Mt5NewAccountProduct = "standard"
const Mt5NewAccountProductStp Mt5NewAccountProduct = "stp"
const Mt5NewAccountProductSwapFree Mt5NewAccountProduct = "swap_free"
const Mt5NewAccountProductSynthetic Mt5NewAccountProduct = "synthetic"
const Mt5NewAccountProductZeroSpread Mt5NewAccountProduct = "zero_spread"

var enumValues_Mt5NewAccountProduct = []interface{}{
	"",
	"synthetic",
	"financial",
	"swap_free",
	"zero_spread",
	"standard",
	"stp",
	"gold",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5NewAccountProduct) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5NewAccountProduct {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5NewAccountProduct, v)
	}
	*j = Mt5NewAccountProduct(v)
	return nil
}

type Mt5NewAccountServer string

const Mt5NewAccountServerP01Ts01 Mt5NewAccountServer = "p01_ts01"
const Mt5NewAccountServerP01Ts02 Mt5NewAccountServer = "p01_ts02"
const Mt5NewAccountServerP01Ts03 Mt5NewAccountServer = "p01_ts03"
const Mt5NewAccountServerP01Ts04 Mt5NewAccountServer = "p01_ts04"
const Mt5NewAccountServerP02Ts02 Mt5NewAccountServer = "p02_ts02"
const Mt5NewAccountServerP03Ts01 Mt5NewAccountServer = "p03_ts01"
const Mt5NewAccountServerP03Ts02 Mt5NewAccountServer = "p03_ts02"

var enumValues_Mt5NewAccountServer = []interface{}{
	"p01_ts01",
	"p01_ts02",
	"p01_ts03",
	"p01_ts04",
	"p02_ts02",
	"p03_ts01",
	"p03_ts02",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5NewAccountServer) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5NewAccountServer {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5NewAccountServer, v)
	}
	*j = Mt5NewAccountServer(v)
	return nil
}

type Mt5NewAccountSubAccountCategory string

const Mt5NewAccountSubAccountCategoryAb Mt5NewAccountSubAccountCategory = "ab"
const Mt5NewAccountSubAccountCategoryBa Mt5NewAccountSubAccountCategory = "ba"
const Mt5NewAccountSubAccountCategoryBlank Mt5NewAccountSubAccountCategory = ""
const Mt5NewAccountSubAccountCategoryGold Mt5NewAccountSubAccountCategory = "gold"
const Mt5NewAccountSubAccountCategoryHr Mt5NewAccountSubAccountCategory = "hr"
const Mt5NewAccountSubAccountCategoryLim Mt5NewAccountSubAccountCategory = "lim"
const Mt5NewAccountSubAccountCategorySwapFree Mt5NewAccountSubAccountCategory = "swap_free"

var enumValues_Mt5NewAccountSubAccountCategory = []interface{}{
	"",
	"swap_free",
	"ab",
	"ba",
	"lim",
	"hr",
	"gold",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5NewAccountSubAccountCategory) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5NewAccountSubAccountCategory {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5NewAccountSubAccountCategory, v)
	}
	*j = Mt5NewAccountSubAccountCategory(v)
	return nil
}

type Mt5NewAccountSubAccountType string

const Mt5NewAccountSubAccountTypeGold Mt5NewAccountSubAccountType = "gold"
const Mt5NewAccountSubAccountTypeIbt Mt5NewAccountSubAccountType = "ibt"
const Mt5NewAccountSubAccountTypeStandard Mt5NewAccountSubAccountType = "standard"
const Mt5NewAccountSubAccountTypeStp Mt5NewAccountSubAccountType = "stp"
const Mt5NewAccountSubAccountTypeSwapFree Mt5NewAccountSubAccountType = "swap_free"
const Mt5NewAccountSubAccountTypeZeroSpread Mt5NewAccountSubAccountType = "zero_spread"

var enumValues_Mt5NewAccountSubAccountType = []interface{}{
	"standard",
	"stp",
	"ibt",
	"swap_free",
	"zero_spread",
	"gold",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5NewAccountSubAccountType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5NewAccountSubAccountType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5NewAccountSubAccountType, v)
	}
	*j = Mt5NewAccountSubAccountType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5NewAccount) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["account_type"]; raw != nil && !ok {
		return fmt.Errorf("field account_type in Mt5NewAccount: required")
	}
	if _, ok := raw["email"]; raw != nil && !ok {
		return fmt.Errorf("field email in Mt5NewAccount: required")
	}
	if _, ok := raw["leverage"]; raw != nil && !ok {
		return fmt.Errorf("field leverage in Mt5NewAccount: required")
	}
	if _, ok := raw["mainPassword"]; raw != nil && !ok {
		return fmt.Errorf("field mainPassword in Mt5NewAccount: required")
	}
	if _, ok := raw["mt5_new_account"]; raw != nil && !ok {
		return fmt.Errorf("field mt5_new_account in Mt5NewAccount: required")
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in Mt5NewAccount: required")
	}
	type Plain Mt5NewAccount
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["dry_run"]; !ok || v == nil {
		plain.DryRun = 0.0
	}
	if len(plain.Name) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "name", 1)
	}
	if len(plain.Name) > 101 {
		return fmt.Errorf("field %s length: must be <= %d", "name", 101)
	}
	if plain.PhonePassword != nil && len(*plain.PhonePassword) > 50 {
		return fmt.Errorf("field %s length: must be <= %d", "phonePassword", 50)
	}
	if plain.ZipCode != nil && len(*plain.ZipCode) > 50 {
		return fmt.Errorf("field %s length: must be <= %d", "zipCode", 50)
	}
	*j = Mt5NewAccount(plain)
	return nil
}
