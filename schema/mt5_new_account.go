// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "fmt"
import "reflect"
import "encoding/json"

// This call creates new MT5 user, either demo or real money user.
type Mt5NewAccount struct {
	// Account type. If set to 'financial', setting 'mt5_account_type' is also
	// required.
	AccountType Mt5NewAccountAccountType `json:"account_type"`

	// [Optional] The address of the user. The maximum length of this address field is
	// 128 characters.
	Address *string `json:"address,omitempty"`

	// [Optional] User's city of residence.
	City *string `json:"city,omitempty"`

	// [Optional] Name of the client's company. The maximum length of the company name
	// is 64 characters.
	Company *string `json:"company,omitempty"`

	// [Optional] 2-letter country code (value received from `residence_list` call).
	Country *string `json:"country,omitempty"`

	// [Optional] MT5 account currency, the default value will be the qualified
	// account currency.
	Currency *string `json:"currency,omitempty"`

	// [Optional] If set to 1, only validation is performed.
	DryRun Mt5NewAccountDryRun `json:"dry_run,omitempty"`

	// Email address
	Email string `json:"email"`

	// [Optional] The investor password of the account. For validation (Accepts any
	// printable ASCII character. Must be within 8-25 characters, and include numbers,
	// lowercase and uppercase letters. Must not be the same as the user's email
	// address).
	InvestPassword *string `json:"investPassword,omitempty"`

	// Client leverage (from 1 to 1000).
	Leverage float64 `json:"leverage"`

	// The master password of the account. For validation (Accepts any printable ASCII
	// character. Must be within 8-25 characters, and include numbers, lowercase and
	// uppercase letters. Must not be the same as the user's email address). This
	// field is required.
	MainPassword string `json:"mainPassword"`

	// [Optional] To choose whether account is conventional or swap_free. Unavailable
	// for financial_stp MT5_account_type
	Mt5AccountCategory *Mt5NewAccountMt5AccountCategory `json:"mt5_account_category,omitempty"`

	// [Optional] Financial: Variable spreads, High leverage. Financial STP: Variable
	// spreads, Medium Leverage, more products. If 'account_type' set to 'financial',
	// setting 'mt5_account_type' is also required.
	Mt5AccountType *Mt5NewAccountMt5AccountType `json:"mt5_account_type,omitempty"`

	// Must be `1`
	Mt5NewAccount Mt5NewAccountMt5NewAccount `json:"mt5_new_account"`

	// Client's name. The maximum length here is 101 characters.
	Name string `json:"name"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field. Maximum size is 3500 bytes.
	Passthrough Mt5NewAccountPassthrough `json:"passthrough,omitempty"`

	// [Optional] User's phone number.
	Phone interface{} `json:"phone,omitempty"`

	// [Optional] The user's phone password.
	PhonePassword *string `json:"phonePassword,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// [Optional] Trade server.
	Server *Mt5NewAccountServer `json:"server,omitempty"`

	// [Optional] User's state (region) of residence.
	State *string `json:"state,omitempty"`

	// [Optional] Indicate the sub account category that we have in the cfd group
	// naming convention.
	SubAccountCategory *Mt5NewAccountSubAccountCategory `json:"sub_account_category,omitempty"`

	// [Optional] User's zip code.
	ZipCode *string `json:"zipCode,omitempty"`
}

type Mt5NewAccountAccountType string

const Mt5NewAccountAccountTypeAll Mt5NewAccountAccountType = "all"
const Mt5NewAccountAccountTypeDemo Mt5NewAccountAccountType = "demo"
const Mt5NewAccountAccountTypeFinancial Mt5NewAccountAccountType = "financial"
const Mt5NewAccountAccountTypeGaming Mt5NewAccountAccountType = "gaming"

type Mt5NewAccountDryRun int

type Mt5NewAccountMt5AccountCategory string

const Mt5NewAccountMt5AccountCategoryConventional Mt5NewAccountMt5AccountCategory = "conventional"
const Mt5NewAccountMt5AccountCategorySwapFree Mt5NewAccountMt5AccountCategory = "swap_free"

type Mt5NewAccountMt5AccountType string

const Mt5NewAccountMt5AccountTypeFinancial Mt5NewAccountMt5AccountType = "financial"
const Mt5NewAccountMt5AccountTypeFinancialStp Mt5NewAccountMt5AccountType = "financial_stp"

type Mt5NewAccountMt5NewAccount int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field. Maximum size is 3500 bytes.
type Mt5NewAccountPassthrough map[string]interface{}

type Mt5NewAccountServer string

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5NewAccountServer) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5NewAccountServer {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5NewAccountServer, v)
	}
	*j = Mt5NewAccountServer(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5NewAccountMt5AccountType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5NewAccountMt5AccountType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5NewAccountMt5AccountType, v)
	}
	*j = Mt5NewAccountMt5AccountType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5NewAccountAccountType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5NewAccountAccountType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5NewAccountAccountType, v)
	}
	*j = Mt5NewAccountAccountType(v)
	return nil
}

var enumValues_Mt5NewAccountDryRun = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5NewAccountDryRun) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5NewAccountDryRun {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5NewAccountDryRun, v)
	}
	*j = Mt5NewAccountDryRun(v)
	return nil
}

var enumValues_Mt5NewAccountMt5NewAccount = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5NewAccountMt5NewAccount) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5NewAccountMt5NewAccount {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5NewAccountMt5NewAccount, v)
	}
	*j = Mt5NewAccountMt5NewAccount(v)
	return nil
}

var enumValues_Mt5NewAccountMt5AccountCategory = []interface{}{
	"conventional",
	"swap_free",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5NewAccountMt5AccountCategory) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5NewAccountMt5AccountCategory {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5NewAccountMt5AccountCategory, v)
	}
	*j = Mt5NewAccountMt5AccountCategory(v)
	return nil
}

var enumValues_Mt5NewAccountServer = []interface{}{
	"p01_ts01",
	"p01_ts02",
	"p01_ts03",
	"p01_ts04",
	"p02_ts02",
}
var enumValues_Mt5NewAccountMt5AccountType = []interface{}{
	"financial",
	"financial_stp",
}

const Mt5NewAccountServerP01Ts01 Mt5NewAccountServer = "p01_ts01"
const Mt5NewAccountServerP01Ts02 Mt5NewAccountServer = "p01_ts02"
const Mt5NewAccountServerP01Ts03 Mt5NewAccountServer = "p01_ts03"
const Mt5NewAccountServerP01Ts04 Mt5NewAccountServer = "p01_ts04"
const Mt5NewAccountServerP02Ts02 Mt5NewAccountServer = "p02_ts02"

type Mt5NewAccountSubAccountCategory string

var enumValues_Mt5NewAccountSubAccountCategory = []interface{}{
	"swap_free",
	"swap_free_high_risk",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5NewAccountSubAccountCategory) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5NewAccountSubAccountCategory {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5NewAccountSubAccountCategory, v)
	}
	*j = Mt5NewAccountSubAccountCategory(v)
	return nil
}

const Mt5NewAccountSubAccountCategorySwapFree Mt5NewAccountSubAccountCategory = "swap_free"
const Mt5NewAccountSubAccountCategorySwapFreeHighRisk Mt5NewAccountSubAccountCategory = "swap_free_high_risk"

var enumValues_Mt5NewAccountAccountType = []interface{}{
	"demo",
	"gaming",
	"financial",
	"all",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5NewAccount) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["account_type"]; !ok || v == nil {
		return fmt.Errorf("field account_type: required")
	}
	if v, ok := raw["email"]; !ok || v == nil {
		return fmt.Errorf("field email: required")
	}
	if v, ok := raw["leverage"]; !ok || v == nil {
		return fmt.Errorf("field leverage: required")
	}
	if v, ok := raw["mainPassword"]; !ok || v == nil {
		return fmt.Errorf("field mainPassword: required")
	}
	if v, ok := raw["mt5_new_account"]; !ok || v == nil {
		return fmt.Errorf("field mt5_new_account: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain Mt5NewAccount
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["dry_run"]; !ok || v == nil {
		plain.DryRun = 0
	}
	*j = Mt5NewAccount(plain)
	return nil
}
