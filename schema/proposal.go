// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import "reflect"

// Gets latest price for a specific contract.
type Proposal struct {
	// [Optional] Proposed contract payout or stake, or multiplier (for lookbacks).
	Amount *float64 `json:"amount,omitempty"`

	// [Optional] Barrier for the contract (or last digit prediction for digit
	// contracts). Contracts less than 24 hours in duration would need a relative
	// barrier (barriers which need +/-), where entry spot would be adjusted
	// accordingly with that amount to define a barrier, except for Synthetic Indices
	// as they support both relative and absolute barriers. Not needed for lookbacks.
	Barrier *string `json:"barrier,omitempty"`

	// [Optional] Low barrier for the contract (for contracts with two barriers).
	// Contracts less than 24 hours in duration would need a relative barrier
	// (barriers which need +/-), where entry spot would be adjusted accordingly with
	// that amount to define a barrier, except for Synthetic Indices as they support
	// both relative and absolute barriers. Not needed for lookbacks.
	Barrier2 *string `json:"barrier2,omitempty"`

	// [Optional] Barrier range for callputspread.
	BarrierRange *ProposalBarrierRange `json:"barrier_range,omitempty"`

	// [Optional] Indicates type of the `amount`.
	Basis *ProposalBasis `json:"basis,omitempty"`

	// Cancellation duration option (only for `MULTUP` and `MULTDOWN` contracts).
	Cancellation *string `json:"cancellation,omitempty"`

	// The proposed contract type
	ContractType ProposalContractType `json:"contract_type"`

	// This can only be the account-holder's currency (obtained from
	// `payout_currencies` call).
	Currency string `json:"currency"`

	// [Optional] Epoch value of the expiry time of the contract. Either date_expiry
	// or duration is required.
	DateExpiry *int `json:"date_expiry,omitempty"`

	// [Optional] Indicates epoch value of the starting time of the contract. If left
	// empty, the start time of the contract is now.
	DateStart *int `json:"date_start,omitempty"`

	// [Optional] Duration quantity. Either date_expiry or duration is required.
	Duration *int `json:"duration,omitempty"`

	// [Optional] Duration unit - `s`: seconds, `m`: minutes, `h`: hours, `d`: days,
	// `t`: ticks.
	DurationUnit ProposalDurationUnit `json:"duration_unit,omitempty"`

	// [Optional] Growth rate of an accumulator contract.
	GrowthRate *float64 `json:"growth_rate,omitempty"`

	// Add an order to close the contract once the order condition is met (only for
	// `MULTUP` and `MULTDOWN` and 'ACCU' contracts). Supported orders: `take_profit`,
	// `stop_loss`.
	LimitOrder *ProposalLimitOrder `json:"limit_order,omitempty"`

	// [Optional] The login id of the user. Mandatory when multiple tokens were
	// provided during authorize.
	Loginid *string `json:"loginid,omitempty"`

	// [Optional] The multiplier for non-binary options. E.g. lookbacks.
	Multiplier *float64 `json:"multiplier,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough ProposalPassthrough `json:"passthrough,omitempty"`

	// [Optional] Clients can provide payout_per_point directly, and the barrier will
	// be calculated based on this payout_per_point value.
	PayoutPerPoint *float64 `json:"payout_per_point,omitempty"`

	// [Optional] The product type.
	ProductType ProposalProductType `json:"product_type,omitempty"`

	// Must be `1`
	Proposal ProposalProposal `json:"proposal"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// [Optional] The tick that is predicted to have the highest/lowest value - for
	// `TICKHIGH` and `TICKLOW` contracts.
	SelectedTick *int `json:"selected_tick,omitempty"`

	// [Optional] 1 - to initiate a realtime stream of prices. Note that tick trades
	// (without a user-defined barrier), digit trades and less than 24 hours
	// at-the-money contracts for the following underlying symbols are not streamed:
	// `R_10`, `R_25`, `R_50`, `R_75`, `R_100`, `RDBULL`, `RDBEAR` (this is because
	// their price is constant).
	Subscribe *ProposalSubscribe `json:"subscribe,omitempty"`

	// The short symbol name (obtained from `active_symbols` call).
	Symbol string `json:"symbol"`

	// [Optional] Required only for multi-barrier trading. Defines the epoch value of
	// the trading period start time.
	TradingPeriodStart *int `json:"trading_period_start,omitempty"`
}

type ProposalBarrierRange string

const ProposalBarrierRangeMiddle ProposalBarrierRange = "middle"
const ProposalBarrierRangeTight ProposalBarrierRange = "tight"
const ProposalBarrierRangeWide ProposalBarrierRange = "wide"

var enumValues_ProposalBarrierRange = []interface{}{
	"tight",
	"middle",
	"wide",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalBarrierRange) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProposalBarrierRange {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProposalBarrierRange, v)
	}
	*j = ProposalBarrierRange(v)
	return nil
}

type ProposalBasis string

const ProposalBasisPayout ProposalBasis = "payout"
const ProposalBasisStake ProposalBasis = "stake"

var enumValues_ProposalBasis = []interface{}{
	"payout",
	"stake",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalBasis) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProposalBasis {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProposalBasis, v)
	}
	*j = ProposalBasis(v)
	return nil
}

type ProposalContractType string

const ProposalContractTypeACCU ProposalContractType = "ACCU"
const ProposalContractTypeASIAND ProposalContractType = "ASIAND"
const ProposalContractTypeASIANU ProposalContractType = "ASIANU"
const ProposalContractTypeCALL ProposalContractType = "CALL"
const ProposalContractTypeCALLE ProposalContractType = "CALLE"
const ProposalContractTypeCALLSPREAD ProposalContractType = "CALLSPREAD"
const ProposalContractTypeDIGITDIFF ProposalContractType = "DIGITDIFF"
const ProposalContractTypeDIGITEVEN ProposalContractType = "DIGITEVEN"
const ProposalContractTypeDIGITMATCH ProposalContractType = "DIGITMATCH"
const ProposalContractTypeDIGITODD ProposalContractType = "DIGITODD"
const ProposalContractTypeDIGITOVER ProposalContractType = "DIGITOVER"
const ProposalContractTypeDIGITUNDER ProposalContractType = "DIGITUNDER"
const ProposalContractTypeEXPIRYMISS ProposalContractType = "EXPIRYMISS"
const ProposalContractTypeEXPIRYMISSE ProposalContractType = "EXPIRYMISSE"
const ProposalContractTypeEXPIRYRANGE ProposalContractType = "EXPIRYRANGE"
const ProposalContractTypeEXPIRYRANGEE ProposalContractType = "EXPIRYRANGEE"
const ProposalContractTypeLBFLOATCALL ProposalContractType = "LBFLOATCALL"
const ProposalContractTypeLBFLOATPUT ProposalContractType = "LBFLOATPUT"
const ProposalContractTypeLBHIGHLOW ProposalContractType = "LBHIGHLOW"
const ProposalContractTypeMULTDOWN ProposalContractType = "MULTDOWN"
const ProposalContractTypeMULTUP ProposalContractType = "MULTUP"
const ProposalContractTypeNOTOUCH ProposalContractType = "NOTOUCH"
const ProposalContractTypeONETOUCH ProposalContractType = "ONETOUCH"
const ProposalContractTypePUT ProposalContractType = "PUT"
const ProposalContractTypePUTE ProposalContractType = "PUTE"
const ProposalContractTypePUTSPREAD ProposalContractType = "PUTSPREAD"
const ProposalContractTypeRANGE ProposalContractType = "RANGE"
const ProposalContractTypeRESETCALL ProposalContractType = "RESETCALL"
const ProposalContractTypeRESETPUT ProposalContractType = "RESETPUT"
const ProposalContractTypeRUNHIGH ProposalContractType = "RUNHIGH"
const ProposalContractTypeRUNLOW ProposalContractType = "RUNLOW"
const ProposalContractTypeTICKHIGH ProposalContractType = "TICKHIGH"
const ProposalContractTypeTICKLOW ProposalContractType = "TICKLOW"
const ProposalContractTypeTURBOSLONG ProposalContractType = "TURBOSLONG"
const ProposalContractTypeTURBOSSHORT ProposalContractType = "TURBOSSHORT"
const ProposalContractTypeUPORDOWN ProposalContractType = "UPORDOWN"
const ProposalContractTypeVANILLALONGCALL ProposalContractType = "VANILLALONGCALL"
const ProposalContractTypeVANILLALONGPUT ProposalContractType = "VANILLALONGPUT"

var enumValues_ProposalContractType = []interface{}{
	"MULTUP",
	"MULTDOWN",
	"UPORDOWN",
	"EXPIRYRANGE",
	"ONETOUCH",
	"CALLE",
	"LBHIGHLOW",
	"ASIAND",
	"EXPIRYRANGEE",
	"DIGITDIFF",
	"DIGITMATCH",
	"DIGITOVER",
	"PUTE",
	"DIGITUNDER",
	"NOTOUCH",
	"CALL",
	"RANGE",
	"LBFLOATPUT",
	"DIGITODD",
	"PUT",
	"ASIANU",
	"LBFLOATCALL",
	"EXPIRYMISSE",
	"EXPIRYMISS",
	"DIGITEVEN",
	"TICKHIGH",
	"TICKLOW",
	"RESETCALL",
	"RESETPUT",
	"CALLSPREAD",
	"PUTSPREAD",
	"RUNHIGH",
	"RUNLOW",
	"ACCU",
	"VANILLALONGCALL",
	"VANILLALONGPUT",
	"TURBOSLONG",
	"TURBOSSHORT",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalContractType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProposalContractType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProposalContractType, v)
	}
	*j = ProposalContractType(v)
	return nil
}

type ProposalDurationUnit string

const ProposalDurationUnitD ProposalDurationUnit = "d"
const ProposalDurationUnitH ProposalDurationUnit = "h"
const ProposalDurationUnitM ProposalDurationUnit = "m"
const ProposalDurationUnitS ProposalDurationUnit = "s"
const ProposalDurationUnitT ProposalDurationUnit = "t"

var enumValues_ProposalDurationUnit = []interface{}{
	"d",
	"m",
	"s",
	"h",
	"t",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalDurationUnit) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProposalDurationUnit {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProposalDurationUnit, v)
	}
	*j = ProposalDurationUnit(v)
	return nil
}

// Add an order to close the contract once the order condition is met (only for
// `MULTUP` and `MULTDOWN` and 'ACCU' contracts). Supported orders: `take_profit`,
// `stop_loss`.
type ProposalLimitOrder struct {
	// Contract will be automatically closed when the value of the contract reaches a
	// specific loss.
	StopLoss *float64 `json:"stop_loss,omitempty"`

	// Contract will be automatically closed when the value of the contract reaches a
	// specific profit.
	TakeProfit *float64 `json:"take_profit,omitempty"`
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type ProposalPassthrough map[string]interface{}

type ProposalProductType string

const ProposalProductTypeBasic ProposalProductType = "basic"

var enumValues_ProposalProductType = []interface{}{
	"basic",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalProductType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProposalProductType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProposalProductType, v)
	}
	*j = ProposalProductType(v)
	return nil
}

type ProposalProposal int

var enumValues_ProposalProposal = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalProposal) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProposalProposal {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProposalProposal, v)
	}
	*j = ProposalProposal(v)
	return nil
}

type ProposalSubscribe int

var enumValues_ProposalSubscribe = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalSubscribe) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProposalSubscribe {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProposalSubscribe, v)
	}
	*j = ProposalSubscribe(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Proposal) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["contract_type"]; raw != nil && !ok {
		return fmt.Errorf("field contract_type in Proposal: required")
	}
	if _, ok := raw["currency"]; raw != nil && !ok {
		return fmt.Errorf("field currency in Proposal: required")
	}
	if _, ok := raw["proposal"]; raw != nil && !ok {
		return fmt.Errorf("field proposal in Proposal: required")
	}
	if _, ok := raw["symbol"]; raw != nil && !ok {
		return fmt.Errorf("field symbol in Proposal: required")
	}
	type Plain Proposal
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["duration_unit"]; !ok || v == nil {
		plain.DurationUnit = "s"
	}
	if v, ok := raw["product_type"]; !ok || v == nil {
		plain.ProductType = "basic"
	}
	*j = Proposal(plain)
	return nil
}
