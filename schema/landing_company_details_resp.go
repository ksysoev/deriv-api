// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import "reflect"

// A message with Landing Company.
type LandingCompanyDetailsResp struct {
	// Echo of the request made.
	EchoReq LandingCompanyDetailsRespEchoReq `json:"echo_req"`

	// The detailed information of the requested landing company.
	LandingCompanyDetails *LandingCompanyDetailsRespLandingCompanyDetails `json:"landing_company_details,omitempty"`

	// Action name of the request made.
	MsgType LandingCompanyDetailsRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type LandingCompanyDetailsRespEchoReq map[string]interface{}

// The detailed information of the requested landing company.
type LandingCompanyDetailsRespLandingCompanyDetails struct {
	// Landing Company address.
	Address []string `json:"address,omitempty"`

	// Special conditions for changing sensitive fields
	ChangeableFields LandingCompanyDetailsRespLandingCompanyDetailsChangeableFields `json:"changeable_fields,omitempty"`

	// Landing Company country.
	Country *string `json:"country,omitempty"`

	// The configuration of each currency.
	CurrencyConfig *LandingCompanyDetailsRespLandingCompanyDetailsCurrencyConfig `json:"currency_config,omitempty"`

	// Flag to indicate whether reality check is applicable for this Landing Company.
	// `1`: applicable, `0`: not applicable. The Reality Check is a feature that gives
	// a summary of the client's trades and account balances on a regular basis
	// throughout his session, and is a regulatory requirement for certain Landing
	// Companies.
	HasRealityCheck *LandingCompanyDetailsRespLandingCompanyDetailsHasRealityCheck `json:"has_reality_check,omitempty"`

	// Allowed contract types for this Landing Company
	LegalAllowedContractCategories []string `json:"legal_allowed_contract_categories,omitempty"`

	// Allowable currencies for accounts with this Landing Company.
	LegalAllowedCurrencies []string `json:"legal_allowed_currencies,omitempty"`

	// Allowed markets for this Landing Company
	LegalAllowedMarkets []string `json:"legal_allowed_markets,omitempty"`

	// Default currency of client accounts with this Landing Company.
	LegalDefaultCurrency *string `json:"legal_default_currency,omitempty"`

	// Landing Company name.
	Name *string `json:"name,omitempty"`

	// Legal requirements for the given Landing Company.
	Requirements *LandingCompanyDetailsRespLandingCompanyDetailsRequirements `json:"requirements,omitempty"`

	// Landing Company shortcode.
	Shortcode *string `json:"shortcode,omitempty"`

	// Flag that indicates whether the landing company supports professional accounts
	// or not
	SupportProfessionalClient *LandingCompanyDetailsRespLandingCompanyDetailsSupportProfessionalClient `json:"support_professional_client,omitempty"`

	// Flag that indicates whether tax identifier number is not mandatory for the
	// current country and landing company.
	TinNotMandatory *LandingCompanyDetailsRespLandingCompanyDetailsTinNotMandatory `json:"tin_not_mandatory,omitempty"`
}

// Special conditions for changing sensitive fields
type LandingCompanyDetailsRespLandingCompanyDetailsChangeableFields map[string]interface{}

// The configuration of each currency.
type LandingCompanyDetailsRespLandingCompanyDetailsCurrencyConfig struct {
	// Name of commodities.
	Commodities LandingCompanyDetailsRespLandingCompanyDetailsCurrencyConfigCommodities `json:"commodities,omitempty"`

	// Name of cryptocurrency.
	Cryptocurrency LandingCompanyDetailsRespLandingCompanyDetailsCurrencyConfigCryptocurrency `json:"cryptocurrency,omitempty"`

	// Name of forex.
	Forex LandingCompanyDetailsRespLandingCompanyDetailsCurrencyConfigForex `json:"forex,omitempty"`

	// Name of indices.
	Indices LandingCompanyDetailsRespLandingCompanyDetailsCurrencyConfigIndices `json:"indices,omitempty"`

	// Name of market.
	Market *LandingCompanyDetailsRespLandingCompanyDetailsCurrencyConfigMarket `json:"market,omitempty"`

	// Name of synthetic index.
	SyntheticIndex LandingCompanyDetailsRespLandingCompanyDetailsCurrencyConfigSyntheticIndex `json:"synthetic_index,omitempty"`
}

// Name of commodities.
type LandingCompanyDetailsRespLandingCompanyDetailsCurrencyConfigCommodities map[string]interface{}

// Name of cryptocurrency.
type LandingCompanyDetailsRespLandingCompanyDetailsCurrencyConfigCryptocurrency map[string]interface{}

// Name of forex.
type LandingCompanyDetailsRespLandingCompanyDetailsCurrencyConfigForex map[string]interface{}

// Name of indices.
type LandingCompanyDetailsRespLandingCompanyDetailsCurrencyConfigIndices map[string]interface{}

// Name of market.
type LandingCompanyDetailsRespLandingCompanyDetailsCurrencyConfigMarket struct {
	// Currency Symbol.
	Currency *LandingCompanyDetailsRespLandingCompanyDetailsCurrencyConfigMarketCurrency `json:"currency,omitempty"`
}

// Currency Symbol.
type LandingCompanyDetailsRespLandingCompanyDetailsCurrencyConfigMarketCurrency struct {
	// Maximum payout for this currency in this market.
	MaxPayout *int `json:"max_payout,omitempty"`

	// Minimum stake for this currency in this market.
	MinStake *int `json:"min_stake,omitempty"`
}

// Name of synthetic index.
type LandingCompanyDetailsRespLandingCompanyDetailsCurrencyConfigSyntheticIndex map[string]interface{}

type LandingCompanyDetailsRespLandingCompanyDetailsHasRealityCheck int

var enumValues_LandingCompanyDetailsRespLandingCompanyDetailsHasRealityCheck = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyDetailsRespLandingCompanyDetailsHasRealityCheck) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandingCompanyDetailsRespLandingCompanyDetailsHasRealityCheck {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandingCompanyDetailsRespLandingCompanyDetailsHasRealityCheck, v)
	}
	*j = LandingCompanyDetailsRespLandingCompanyDetailsHasRealityCheck(v)
	return nil
}

// Legal requirements for the given Landing Company.
type LandingCompanyDetailsRespLandingCompanyDetailsRequirements struct {
	// After first deposit requirements
	AfterFirstDeposit *LandingCompanyDetailsRespLandingCompanyDetailsRequirementsAfterFirstDeposit `json:"after_first_deposit,omitempty"`

	// Compliance requirements
	Compliance *LandingCompanyDetailsRespLandingCompanyDetailsRequirementsCompliance `json:"compliance,omitempty"`

	// Sign up requirements for partners
	Partner []string `json:"partner,omitempty"`

	// Sign up requirements
	Signup []string `json:"signup,omitempty"`

	// Withdrawal requirements
	Withdrawal []string `json:"withdrawal,omitempty"`
}

// After first deposit requirements
type LandingCompanyDetailsRespLandingCompanyDetailsRequirementsAfterFirstDeposit struct {
	// Financial assessment requirements
	FinancialAssessment []string `json:"financial_assessment,omitempty"`
}

// Compliance requirements
type LandingCompanyDetailsRespLandingCompanyDetailsRequirementsCompliance struct {
	// Compliance MT5 requirements
	Mt5 []string `json:"mt5,omitempty"`

	// Compliance tax information requirements
	TaxInformation []string `json:"tax_information,omitempty"`
}

type LandingCompanyDetailsRespLandingCompanyDetailsSupportProfessionalClient int

var enumValues_LandingCompanyDetailsRespLandingCompanyDetailsSupportProfessionalClient = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyDetailsRespLandingCompanyDetailsSupportProfessionalClient) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandingCompanyDetailsRespLandingCompanyDetailsSupportProfessionalClient {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandingCompanyDetailsRespLandingCompanyDetailsSupportProfessionalClient, v)
	}
	*j = LandingCompanyDetailsRespLandingCompanyDetailsSupportProfessionalClient(v)
	return nil
}

type LandingCompanyDetailsRespLandingCompanyDetailsTinNotMandatory int

var enumValues_LandingCompanyDetailsRespLandingCompanyDetailsTinNotMandatory = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyDetailsRespLandingCompanyDetailsTinNotMandatory) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandingCompanyDetailsRespLandingCompanyDetailsTinNotMandatory {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandingCompanyDetailsRespLandingCompanyDetailsTinNotMandatory, v)
	}
	*j = LandingCompanyDetailsRespLandingCompanyDetailsTinNotMandatory(v)
	return nil
}

type LandingCompanyDetailsRespMsgType string

const LandingCompanyDetailsRespMsgTypeLandingCompanyDetails LandingCompanyDetailsRespMsgType = "landing_company_details"

var enumValues_LandingCompanyDetailsRespMsgType = []interface{}{
	"landing_company_details",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyDetailsRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandingCompanyDetailsRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandingCompanyDetailsRespMsgType, v)
	}
	*j = LandingCompanyDetailsRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyDetailsResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["echo_req"]; raw != nil && !ok {
		return fmt.Errorf("field echo_req in LandingCompanyDetailsResp: required")
	}
	if _, ok := raw["msg_type"]; raw != nil && !ok {
		return fmt.Errorf("field msg_type in LandingCompanyDetailsResp: required")
	}
	type Plain LandingCompanyDetailsResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandingCompanyDetailsResp(plain)
	return nil
}
