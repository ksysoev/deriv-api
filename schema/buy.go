// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import "reflect"

// Buy a Contract
type Buy struct {
	// Either the ID received from a Price Proposal (`proposal` call), or `1` if
	// contract buy parameters are passed in the `parameters` field.
	Buy string `json:"buy"`

	// [Optional] The login id of the user. If left unspecified, it defaults to the
	// initial authorized token's login id.
	Loginid *string `json:"loginid,omitempty"`

	// [Optional] Used to pass the parameters for contract buy.
	Parameters *BuyParameters `json:"parameters,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field. Maximum size is 3500 bytes.
	Passthrough BuyPassthrough `json:"passthrough,omitempty"`

	// Maximum price at which to purchase the contract.
	Price float64 `json:"price"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// [Optional] `1` to stream.
	Subscribe *BuySubscribe `json:"subscribe,omitempty"`
}

// [Optional] Used to pass the parameters for contract buy.
type BuyParameters struct {
	// [Optional] Proposed payout or stake value
	Amount *float64 `json:"amount,omitempty"`

	// [Optional] Markup added to contract prices (as a percentage of contract payout)
	AppMarkupPercentage *float64 `json:"app_markup_percentage,omitempty"`

	// [Optional] Barrier for the contract (or last digit prediction for digit
	// contracts). Contracts less than 24 hours in duration would need a relative
	// barrier (barriers which need +/-), where entry spot would be adjusted
	// accordingly with that amount to define a barrier, except for Synthetic Indices
	// as they support both relative and absolute barriers.
	Barrier *string `json:"barrier,omitempty"`

	// [Optional] Low barrier for the contract (for contracts with two barriers).
	// Contracts less than 24 hours in duration would need a relative barrier
	// (barriers which need +/-), where entry spot would be adjusted accordingly with
	// that amount to define a barrier, except for Synthetic Indices as they support
	// both relative and absolute barriers.
	Barrier2 *string `json:"barrier2,omitempty"`

	// [Optional] Barrier range for callputspread.
	BarrierRange *BuyParametersBarrierRange `json:"barrier_range,omitempty"`

	// [Optional] Indicates whether amount is 'payout' or 'stake' for binary options.
	Basis *BuyParametersBasis `json:"basis,omitempty"`

	// Cancellation duration option (only for `MULTUP` and `MULTDOWN` contracts).
	Cancellation *string `json:"cancellation,omitempty"`

	// A valid contract-type
	ContractType BuyParametersContractType `json:"contract_type"`

	// This can only be the account-holder's currency
	Currency string `json:"currency"`

	// [Optional] Epoch value of the expiry time of the contract. You must either
	// specify date_expiry or duration.
	DateExpiry *int `json:"date_expiry,omitempty"`

	// [Optional] For forward-starting contracts, epoch value of the starting time of
	// the contract.
	DateStart *int `json:"date_start,omitempty"`

	// [Optional] Duration quantity
	Duration *int `json:"duration,omitempty"`

	// [Optional] Duration unit is `s`: seconds, `m`: minutes, `h`: hours, `d`: days,
	// `t`: ticks
	DurationUnit *BuyParametersDurationUnit `json:"duration_unit,omitempty"`

	// [Optional] Growth rate of an accumulator contract.
	GrowthRate *float64 `json:"growth_rate,omitempty"`

	// Add an order to close the contract once the order condition is met (only for
	// `MULTUP` and `MULTDOWN` and `ACCU` contracts).
	LimitOrder *BuyParametersLimitOrder `json:"limit_order,omitempty"`

	// [Optional] The multiplier for non-binary options. E.g. lookbacks.
	Multiplier *float64 `json:"multiplier,omitempty"`

	// [Optional] The product type.
	ProductType BuyParametersProductType `json:"product_type,omitempty"`

	// [Optional] The tick that is predicted to have the highest/lowest value - for
	// tickhigh and ticklow contracts.
	SelectedTick *int `json:"selected_tick,omitempty"`

	// Symbol code
	Symbol string `json:"symbol"`

	// [Optional] An epoch value of a predefined trading period start time
	TradingPeriodStart *int `json:"trading_period_start,omitempty"`
}

type BuyParametersBarrierRange string

const BuyParametersBarrierRangeMiddle BuyParametersBarrierRange = "middle"
const BuyParametersBarrierRangeTight BuyParametersBarrierRange = "tight"
const BuyParametersBarrierRangeWide BuyParametersBarrierRange = "wide"

type BuyParametersBasis string

const BuyParametersBasisPayout BuyParametersBasis = "payout"
const BuyParametersBasisStake BuyParametersBasis = "stake"

type BuyParametersContractType string

const BuyParametersContractTypeACCU BuyParametersContractType = "ACCU"
const BuyParametersContractTypeASIAND BuyParametersContractType = "ASIAND"
const BuyParametersContractTypeASIANU BuyParametersContractType = "ASIANU"
const BuyParametersContractTypeCALL BuyParametersContractType = "CALL"
const BuyParametersContractTypeCALLE BuyParametersContractType = "CALLE"
const BuyParametersContractTypeCALLSPREAD BuyParametersContractType = "CALLSPREAD"
const BuyParametersContractTypeDIGITDIFF BuyParametersContractType = "DIGITDIFF"
const BuyParametersContractTypeDIGITEVEN BuyParametersContractType = "DIGITEVEN"
const BuyParametersContractTypeDIGITMATCH BuyParametersContractType = "DIGITMATCH"
const BuyParametersContractTypeDIGITODD BuyParametersContractType = "DIGITODD"
const BuyParametersContractTypeDIGITOVER BuyParametersContractType = "DIGITOVER"
const BuyParametersContractTypeDIGITUNDER BuyParametersContractType = "DIGITUNDER"
const BuyParametersContractTypeEXPIRYMISS BuyParametersContractType = "EXPIRYMISS"
const BuyParametersContractTypeEXPIRYMISSE BuyParametersContractType = "EXPIRYMISSE"
const BuyParametersContractTypeEXPIRYRANGE BuyParametersContractType = "EXPIRYRANGE"
const BuyParametersContractTypeEXPIRYRANGEE BuyParametersContractType = "EXPIRYRANGEE"
const BuyParametersContractTypeLBFLOATCALL BuyParametersContractType = "LBFLOATCALL"
const BuyParametersContractTypeLBFLOATPUT BuyParametersContractType = "LBFLOATPUT"
const BuyParametersContractTypeLBHIGHLOW BuyParametersContractType = "LBHIGHLOW"
const BuyParametersContractTypeMULTDOWN BuyParametersContractType = "MULTDOWN"
const BuyParametersContractTypeMULTUP BuyParametersContractType = "MULTUP"
const BuyParametersContractTypeNOTOUCH BuyParametersContractType = "NOTOUCH"
const BuyParametersContractTypeONETOUCH BuyParametersContractType = "ONETOUCH"
const BuyParametersContractTypePUT BuyParametersContractType = "PUT"
const BuyParametersContractTypePUTE BuyParametersContractType = "PUTE"
const BuyParametersContractTypePUTSPREAD BuyParametersContractType = "PUTSPREAD"
const BuyParametersContractTypeRANGE BuyParametersContractType = "RANGE"
const BuyParametersContractTypeRESETCALL BuyParametersContractType = "RESETCALL"
const BuyParametersContractTypeRESETPUT BuyParametersContractType = "RESETPUT"
const BuyParametersContractTypeRUNHIGH BuyParametersContractType = "RUNHIGH"
const BuyParametersContractTypeRUNLOW BuyParametersContractType = "RUNLOW"
const BuyParametersContractTypeTICKHIGH BuyParametersContractType = "TICKHIGH"
const BuyParametersContractTypeTICKLOW BuyParametersContractType = "TICKLOW"
const BuyParametersContractTypeTURBOSLONG BuyParametersContractType = "TURBOSLONG"
const BuyParametersContractTypeTURBOSSHORT BuyParametersContractType = "TURBOSSHORT"
const BuyParametersContractTypeUPORDOWN BuyParametersContractType = "UPORDOWN"
const BuyParametersContractTypeVANILLALONGCALL BuyParametersContractType = "VANILLALONGCALL"
const BuyParametersContractTypeVANILLALONGPUT BuyParametersContractType = "VANILLALONGPUT"

type BuyParametersDurationUnit string

const BuyParametersDurationUnitD BuyParametersDurationUnit = "d"
const BuyParametersDurationUnitH BuyParametersDurationUnit = "h"
const BuyParametersDurationUnitM BuyParametersDurationUnit = "m"
const BuyParametersDurationUnitS BuyParametersDurationUnit = "s"
const BuyParametersDurationUnitT BuyParametersDurationUnit = "t"

// Add an order to close the contract once the order condition is met (only for
// `MULTUP` and `MULTDOWN` and `ACCU` contracts).
type BuyParametersLimitOrder struct {
	// Contract will be automatically closed when the value of the contract reaches a
	// specific loss.
	StopLoss *float64 `json:"stop_loss,omitempty"`

	// Contract will be automatically closed when the value of the contract reaches a
	// specific profit.
	TakeProfit *float64 `json:"take_profit,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuyParametersProductType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BuyParametersProductType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BuyParametersProductType, v)
	}
	*j = BuyParametersProductType(v)
	return nil
}

var enumValues_BuyParametersDurationUnit = []interface{}{
	"d",
	"m",
	"s",
	"h",
	"t",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuyParametersContractType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BuyParametersContractType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BuyParametersContractType, v)
	}
	*j = BuyParametersContractType(v)
	return nil
}

var enumValues_BuyParametersContractType = []interface{}{
	"MULTUP",
	"MULTDOWN",
	"UPORDOWN",
	"EXPIRYRANGE",
	"ONETOUCH",
	"CALLE",
	"LBHIGHLOW",
	"ASIAND",
	"EXPIRYRANGEE",
	"DIGITDIFF",
	"DIGITMATCH",
	"DIGITOVER",
	"PUTE",
	"DIGITUNDER",
	"NOTOUCH",
	"CALL",
	"RANGE",
	"LBFLOATPUT",
	"DIGITODD",
	"PUT",
	"ASIANU",
	"LBFLOATCALL",
	"EXPIRYMISSE",
	"EXPIRYMISS",
	"DIGITEVEN",
	"TICKHIGH",
	"TICKLOW",
	"RESETCALL",
	"RESETPUT",
	"CALLSPREAD",
	"PUTSPREAD",
	"RUNHIGH",
	"RUNLOW",
	"ACCU",
	"VANILLALONGCALL",
	"VANILLALONGPUT",
	"TURBOSLONG",
	"TURBOSSHORT",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuyParametersBasis) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BuyParametersBasis {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BuyParametersBasis, v)
	}
	*j = BuyParametersBasis(v)
	return nil
}

var enumValues_BuyParametersBasis = []interface{}{
	"payout",
	"stake",
}

type BuyParametersProductType string

var enumValues_BuyParametersProductType = []interface{}{
	"basic",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuyParametersDurationUnit) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BuyParametersDurationUnit {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BuyParametersDurationUnit, v)
	}
	*j = BuyParametersDurationUnit(v)
	return nil
}

const BuyParametersProductTypeBasic BuyParametersProductType = "basic"

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuyParametersBarrierRange) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BuyParametersBarrierRange {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BuyParametersBarrierRange, v)
	}
	*j = BuyParametersBarrierRange(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuyParameters) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["contract_type"]; !ok || v == nil {
		return fmt.Errorf("field contract_type in BuyParameters: required")
	}
	if v, ok := raw["currency"]; !ok || v == nil {
		return fmt.Errorf("field currency in BuyParameters: required")
	}
	if v, ok := raw["symbol"]; !ok || v == nil {
		return fmt.Errorf("field symbol in BuyParameters: required")
	}
	type Plain BuyParameters
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["product_type"]; !ok || v == nil {
		plain.ProductType = "basic"
	}
	*j = BuyParameters(plain)
	return nil
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field. Maximum size is 3500 bytes.
type BuyPassthrough map[string]interface{}

type BuySubscribe int

var enumValues_BuySubscribe = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuySubscribe) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BuySubscribe {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BuySubscribe, v)
	}
	*j = BuySubscribe(v)
	return nil
}

var enumValues_BuyParametersBarrierRange = []interface{}{
	"tight",
	"middle",
	"wide",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Buy) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["buy"]; !ok || v == nil {
		return fmt.Errorf("field buy in Buy: required")
	}
	if v, ok := raw["price"]; !ok || v == nil {
		return fmt.Errorf("field price in Buy: required")
	}
	type Plain Buy
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Buy(plain)
	return nil
}
