// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import "reflect"

// Server status alongside general settings like call limits, currencies
// information, supported languages, etc.
type WebsiteStatusResp struct {
	// Echo of the request made.
	EchoReq WebsiteStatusRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType WebsiteStatusRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// For subscription requests only.
	Subscription *WebsiteStatusRespSubscription `json:"subscription,omitempty"`

	// Server status and other information regarding general settings
	WebsiteStatus *WebsiteStatusRespWebsiteStatus `json:"website_status,omitempty"`
}

// Echo of the request made.
type WebsiteStatusRespEchoReq map[string]interface{}

type WebsiteStatusRespMsgType string

const WebsiteStatusRespMsgTypeWebsiteStatus WebsiteStatusRespMsgType = "website_status"

var enumValues_WebsiteStatusRespMsgType = []interface{}{
	"website_status",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WebsiteStatusRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WebsiteStatusRespMsgType, v)
	}
	*j = WebsiteStatusRespMsgType(v)
	return nil
}

// For subscription requests only.
type WebsiteStatusRespSubscription struct {
	// A per-connection unique identifier. Can be passed to the `forget` API call to
	// unsubscribe.
	Id string `json:"id"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespSubscription) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in WebsiteStatusRespSubscription: required")
	}
	type Plain WebsiteStatusRespSubscription
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = WebsiteStatusRespSubscription(plain)
	return nil
}

// Server status and other information regarding general settings
type WebsiteStatusRespWebsiteStatus struct {
	// Maximum number of API calls during specified period of time.
	ApiCallLimits WebsiteStatusRespWebsiteStatusApiCallLimits `json:"api_call_limits"`

	// List of all available broker codes.
	BrokerCodes []string `json:"broker_codes,omitempty"`

	// Country code of connected IP
	ClientsCountry *string `json:"clients_country,omitempty"`

	// Available currencies and their information
	CurrenciesConfig WebsiteStatusRespWebsiteStatusCurrenciesConfig `json:"currencies_config"`

	// Suspension status of Dxtrade/DerivX API calls
	DxtradeStatus *WebsiteStatusRespWebsiteStatusDxtradeStatus `json:"dxtrade_status,omitempty"`

	// Text for site status banner, contains problem description. shown only if set by
	// the system.
	Message *string `json:"message,omitempty"`

	// Suspension status of MT5 API calls
	Mt5Status *WebsiteStatusRespWebsiteStatusMt5Status `json:"mt5_status,omitempty"`

	// Peer-to-peer payment system settings.
	P2PConfig *WebsiteStatusRespWebsiteStatusP2PConfig `json:"p2p_config,omitempty"`

	// Payments Agents system settings.
	PaymentAgents *WebsiteStatusRespWebsiteStatusPaymentAgents `json:"payment_agents,omitempty"`

	// The current status of the website.
	SiteStatus *WebsiteStatusRespWebsiteStatusSiteStatus `json:"site_status,omitempty"`

	// Provides codes for languages supported.
	SupportedLanguages []string `json:"supported_languages,omitempty"`

	// Latest terms and conditions version.
	TermsConditionsVersion *string `json:"terms_conditions_version,omitempty"`
}

// Maximum number of API calls during specified period of time.
type WebsiteStatusRespWebsiteStatusApiCallLimits struct {
	// Maximum subscription to proposal calls.
	MaxProposalSubscription WebsiteStatusRespWebsiteStatusApiCallLimitsMaxProposalSubscription `json:"max_proposal_subscription"`

	// Maximum number of general requests allowed during specified period of time.
	MaxRequestesGeneral WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestesGeneral `json:"max_requestes_general"`

	// Maximum number of outcome requests allowed during specified period of time.
	MaxRequestsOutcome WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestsOutcome `json:"max_requests_outcome"`

	// Maximum number of pricing requests allowed during specified period of time.
	MaxRequestsPricing WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestsPricing `json:"max_requests_pricing"`
}

// Maximum subscription to proposal calls.
type WebsiteStatusRespWebsiteStatusApiCallLimitsMaxProposalSubscription struct {
	// Describes which calls this limit applies to.
	AppliesTo string `json:"applies_to"`

	// Maximum number of allowed calls.
	Max float64 `json:"max"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusApiCallLimitsMaxProposalSubscription) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["applies_to"]; raw != nil && !ok {
		return fmt.Errorf("field applies_to in WebsiteStatusRespWebsiteStatusApiCallLimitsMaxProposalSubscription: required")
	}
	if _, ok := raw["max"]; raw != nil && !ok {
		return fmt.Errorf("field max in WebsiteStatusRespWebsiteStatusApiCallLimitsMaxProposalSubscription: required")
	}
	type Plain WebsiteStatusRespWebsiteStatusApiCallLimitsMaxProposalSubscription
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = WebsiteStatusRespWebsiteStatusApiCallLimitsMaxProposalSubscription(plain)
	return nil
}

// Maximum number of general requests allowed during specified period of time.
type WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestesGeneral struct {
	// Describes which calls this limit applies to.
	AppliesTo string `json:"applies_to"`

	// The maximum of allowed calls per hour.
	Hourly float64 `json:"hourly"`

	// The maximum of allowed calls per minute.
	Minutely float64 `json:"minutely"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestesGeneral) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["applies_to"]; raw != nil && !ok {
		return fmt.Errorf("field applies_to in WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestesGeneral: required")
	}
	if _, ok := raw["hourly"]; raw != nil && !ok {
		return fmt.Errorf("field hourly in WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestesGeneral: required")
	}
	if _, ok := raw["minutely"]; raw != nil && !ok {
		return fmt.Errorf("field minutely in WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestesGeneral: required")
	}
	type Plain WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestesGeneral
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestesGeneral(plain)
	return nil
}

// Maximum number of outcome requests allowed during specified period of time.
type WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestsOutcome struct {
	// Describes which calls this limit applies to.
	AppliesTo string `json:"applies_to"`

	// The maximum of allowed calls per hour.
	Hourly float64 `json:"hourly"`

	// The maximum of allowed calls per minute.
	Minutely float64 `json:"minutely"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestsOutcome) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["applies_to"]; raw != nil && !ok {
		return fmt.Errorf("field applies_to in WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestsOutcome: required")
	}
	if _, ok := raw["hourly"]; raw != nil && !ok {
		return fmt.Errorf("field hourly in WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestsOutcome: required")
	}
	if _, ok := raw["minutely"]; raw != nil && !ok {
		return fmt.Errorf("field minutely in WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestsOutcome: required")
	}
	type Plain WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestsOutcome
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestsOutcome(plain)
	return nil
}

// Maximum number of pricing requests allowed during specified period of time.
type WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestsPricing struct {
	// Describes which calls this limit applies to.
	AppliesTo string `json:"applies_to"`

	// The maximum of allowed calls per hour.
	Hourly float64 `json:"hourly"`

	// The maximum of allowed calls per minute.
	Minutely float64 `json:"minutely"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestsPricing) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["applies_to"]; raw != nil && !ok {
		return fmt.Errorf("field applies_to in WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestsPricing: required")
	}
	if _, ok := raw["hourly"]; raw != nil && !ok {
		return fmt.Errorf("field hourly in WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestsPricing: required")
	}
	if _, ok := raw["minutely"]; raw != nil && !ok {
		return fmt.Errorf("field minutely in WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestsPricing: required")
	}
	type Plain WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestsPricing
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestsPricing(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusApiCallLimits) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["max_proposal_subscription"]; raw != nil && !ok {
		return fmt.Errorf("field max_proposal_subscription in WebsiteStatusRespWebsiteStatusApiCallLimits: required")
	}
	if _, ok := raw["max_requestes_general"]; raw != nil && !ok {
		return fmt.Errorf("field max_requestes_general in WebsiteStatusRespWebsiteStatusApiCallLimits: required")
	}
	if _, ok := raw["max_requests_outcome"]; raw != nil && !ok {
		return fmt.Errorf("field max_requests_outcome in WebsiteStatusRespWebsiteStatusApiCallLimits: required")
	}
	if _, ok := raw["max_requests_pricing"]; raw != nil && !ok {
		return fmt.Errorf("field max_requests_pricing in WebsiteStatusRespWebsiteStatusApiCallLimits: required")
	}
	type Plain WebsiteStatusRespWebsiteStatusApiCallLimits
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = WebsiteStatusRespWebsiteStatusApiCallLimits(plain)
	return nil
}

// Available currencies and their information
type WebsiteStatusRespWebsiteStatusCurrenciesConfig map[string]interface{}

// Suspension status of Dxtrade/DerivX API calls
type WebsiteStatusRespWebsiteStatusDxtradeStatus struct {
	// Suspension of Dxtrade/DerivX API calls on all servers.
	All *int `json:"all,omitempty"`

	// Suspension of Dxtrade/DerivX API calls on demo servers.
	Demo *int `json:"demo,omitempty"`

	// Suspension of Dxtrade/DerivX API calls on real trading servers.
	Real *int `json:"real,omitempty"`
}

// Suspension status of MT5 API calls
type WebsiteStatusRespWebsiteStatusMt5Status struct {
	// Suspension of MT5 API calls on demo servers.
	Demo []interface{} `json:"demo,omitempty"`

	// Suspension of MT5 API calls on real trading servers.
	Real []interface{} `json:"real,omitempty"`
}

// Peer-to-peer payment system settings.
type WebsiteStatusRespWebsiteStatusP2PConfig struct {
	// Maximum number of active ads allowed by an advertiser per currency pair and
	// advert type (buy or sell).
	AdvertsActiveLimit int `json:"adverts_active_limit"`

	// Adverts will be deactivated if no activity occurs within this period, in days.
	AdvertsArchivePeriod *int `json:"adverts_archive_period,omitempty"`

	// Block trading settings
	BlockTrade WebsiteStatusRespWebsiteStatusP2PConfigBlockTrade `json:"block_trade"`

	// A buyer will be blocked for this duration after exceeding the cancellation
	// limit, in hours.
	CancellationBlockDuration int `json:"cancellation_block_duration"`

	// The period within which to count buyer cancellations, in hours.
	CancellationCountPeriod int `json:"cancellation_count_period"`

	// A buyer may cancel an order within this period without negative consequences,
	// in minutes after order creation.
	CancellationGracePeriod int `json:"cancellation_grace_period"`

	// A buyer will be temporarily barred after marking this number of cancellations
	// within cancellation_period.
	CancellationLimit int `json:"cancellation_limit"`

	// When 0, only exchanges in local currency are allowed for P2P advertiser.
	CrossBorderAdsEnabled WebsiteStatusRespWebsiteStatusP2PConfigCrossBorderAdsEnabled `json:"cross_border_ads_enabled"`

	// When 1, the P2P service is unavailable.
	Disabled WebsiteStatusRespWebsiteStatusP2PConfigDisabled `json:"disabled"`

	// Indicates the availbility of certain backend features.
	FeatureLevel int `json:"feature_level"`

	// Availability of fixed rate adverts.
	FixedRateAdverts WebsiteStatusRespWebsiteStatusP2PConfigFixedRateAdverts `json:"fixed_rate_adverts"`

	// Date on which fixed rate adverts will be deactivated.
	FixedRateAdvertsEndDate *string `json:"fixed_rate_adverts_end_date,omitempty"`

	// Availability of floating rate adverts.
	FloatRateAdverts WebsiteStatusRespWebsiteStatusP2PConfigFloatRateAdverts `json:"float_rate_adverts"`

	// Maximum rate offset for floating rate adverts.
	FloatRateOffsetLimit float64 `json:"float_rate_offset_limit"`

	// Available local currencies for p2p_advert_list request.
	LocalCurrencies []WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElem `json:"local_currencies"`

	// Maximum amount of an advert, in USD.
	MaximumAdvertAmount float64 `json:"maximum_advert_amount"`

	// Maximum amount of an order, in USD.
	MaximumOrderAmount float64 `json:"maximum_order_amount"`

	// Maximum number of orders a user may create per day.
	OrderDailyLimit int `json:"order_daily_limit"`

	// Time allowed for order payment, in minutes after order creation.
	OrderPaymentPeriod int `json:"order_payment_period"`

	// Local P2P exchange rate which should be used instead of those obtained from the
	// `exchange_rates` call.
	OverrideExchangeRate *string `json:"override_exchange_rate,omitempty"`

	// Indicates if the payment methods feature is enabled.
	PaymentMethodsEnabled WebsiteStatusRespWebsiteStatusP2PConfigPaymentMethodsEnabled `json:"payment_methods_enabled"`

	// Time after successful order completion during which reviews can be created, in
	// hours.
	ReviewPeriod float64 `json:"review_period"`

	// List of currencies for which P2P is available
	SupportedCurrencies []string `json:"supported_currencies"`
}

// Block trading settings
type WebsiteStatusRespWebsiteStatusP2PConfigBlockTrade struct {
	// When 1, Block trading is unavailable.
	Disabled *WebsiteStatusRespWebsiteStatusP2PConfigBlockTradeDisabled `json:"disabled,omitempty"`

	// Maximum amount of a block trade advert, in USD.
	MaximumAdvertAmount *float64 `json:"maximum_advert_amount,omitempty"`
}

type WebsiteStatusRespWebsiteStatusP2PConfigBlockTradeDisabled int

var enumValues_WebsiteStatusRespWebsiteStatusP2PConfigBlockTradeDisabled = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusP2PConfigBlockTradeDisabled) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WebsiteStatusRespWebsiteStatusP2PConfigBlockTradeDisabled {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WebsiteStatusRespWebsiteStatusP2PConfigBlockTradeDisabled, v)
	}
	*j = WebsiteStatusRespWebsiteStatusP2PConfigBlockTradeDisabled(v)
	return nil
}

type WebsiteStatusRespWebsiteStatusP2PConfigCrossBorderAdsEnabled int

var enumValues_WebsiteStatusRespWebsiteStatusP2PConfigCrossBorderAdsEnabled = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusP2PConfigCrossBorderAdsEnabled) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WebsiteStatusRespWebsiteStatusP2PConfigCrossBorderAdsEnabled {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WebsiteStatusRespWebsiteStatusP2PConfigCrossBorderAdsEnabled, v)
	}
	*j = WebsiteStatusRespWebsiteStatusP2PConfigCrossBorderAdsEnabled(v)
	return nil
}

type WebsiteStatusRespWebsiteStatusP2PConfigDisabled int

var enumValues_WebsiteStatusRespWebsiteStatusP2PConfigDisabled = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusP2PConfigDisabled) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WebsiteStatusRespWebsiteStatusP2PConfigDisabled {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WebsiteStatusRespWebsiteStatusP2PConfigDisabled, v)
	}
	*j = WebsiteStatusRespWebsiteStatusP2PConfigDisabled(v)
	return nil
}

type WebsiteStatusRespWebsiteStatusP2PConfigFixedRateAdverts string

const WebsiteStatusRespWebsiteStatusP2PConfigFixedRateAdvertsDisabled WebsiteStatusRespWebsiteStatusP2PConfigFixedRateAdverts = "disabled"
const WebsiteStatusRespWebsiteStatusP2PConfigFixedRateAdvertsEnabled WebsiteStatusRespWebsiteStatusP2PConfigFixedRateAdverts = "enabled"
const WebsiteStatusRespWebsiteStatusP2PConfigFixedRateAdvertsListOnly WebsiteStatusRespWebsiteStatusP2PConfigFixedRateAdverts = "list_only"

var enumValues_WebsiteStatusRespWebsiteStatusP2PConfigFixedRateAdverts = []interface{}{
	"disabled",
	"enabled",
	"list_only",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusP2PConfigFixedRateAdverts) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WebsiteStatusRespWebsiteStatusP2PConfigFixedRateAdverts {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WebsiteStatusRespWebsiteStatusP2PConfigFixedRateAdverts, v)
	}
	*j = WebsiteStatusRespWebsiteStatusP2PConfigFixedRateAdverts(v)
	return nil
}

type WebsiteStatusRespWebsiteStatusP2PConfigFloatRateAdverts string

const WebsiteStatusRespWebsiteStatusP2PConfigFloatRateAdvertsDisabled WebsiteStatusRespWebsiteStatusP2PConfigFloatRateAdverts = "disabled"
const WebsiteStatusRespWebsiteStatusP2PConfigFloatRateAdvertsEnabled WebsiteStatusRespWebsiteStatusP2PConfigFloatRateAdverts = "enabled"
const WebsiteStatusRespWebsiteStatusP2PConfigFloatRateAdvertsListOnly WebsiteStatusRespWebsiteStatusP2PConfigFloatRateAdverts = "list_only"

var enumValues_WebsiteStatusRespWebsiteStatusP2PConfigFloatRateAdverts = []interface{}{
	"disabled",
	"enabled",
	"list_only",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusP2PConfigFloatRateAdverts) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WebsiteStatusRespWebsiteStatusP2PConfigFloatRateAdverts {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WebsiteStatusRespWebsiteStatusP2PConfigFloatRateAdverts, v)
	}
	*j = WebsiteStatusRespWebsiteStatusP2PConfigFloatRateAdverts(v)
	return nil
}

// Local currency details.
type WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElem struct {
	// Local currency name
	DisplayName string `json:"display_name"`

	// Indicates that there are adverts available for this currency.
	HasAdverts WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElemHasAdverts `json:"has_adverts"`

	// Indicates that this is local currency for the current country.
	IsDefault *WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElemIsDefault `json:"is_default,omitempty"`

	// Local currency symbol
	Symbol string `json:"symbol"`
}

type WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElemHasAdverts int

var enumValues_WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElemHasAdverts = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElemHasAdverts) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElemHasAdverts {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElemHasAdverts, v)
	}
	*j = WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElemHasAdverts(v)
	return nil
}

type WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElemIsDefault int

var enumValues_WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElemIsDefault = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElemIsDefault) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElemIsDefault {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElemIsDefault, v)
	}
	*j = WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElemIsDefault(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["display_name"]; raw != nil && !ok {
		return fmt.Errorf("field display_name in WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElem: required")
	}
	if _, ok := raw["has_adverts"]; raw != nil && !ok {
		return fmt.Errorf("field has_adverts in WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElem: required")
	}
	if _, ok := raw["symbol"]; raw != nil && !ok {
		return fmt.Errorf("field symbol in WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElem: required")
	}
	type Plain WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElem(plain)
	return nil
}

type WebsiteStatusRespWebsiteStatusP2PConfigPaymentMethodsEnabled int

var enumValues_WebsiteStatusRespWebsiteStatusP2PConfigPaymentMethodsEnabled = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusP2PConfigPaymentMethodsEnabled) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WebsiteStatusRespWebsiteStatusP2PConfigPaymentMethodsEnabled {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WebsiteStatusRespWebsiteStatusP2PConfigPaymentMethodsEnabled, v)
	}
	*j = WebsiteStatusRespWebsiteStatusP2PConfigPaymentMethodsEnabled(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusP2PConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["adverts_active_limit"]; raw != nil && !ok {
		return fmt.Errorf("field adverts_active_limit in WebsiteStatusRespWebsiteStatusP2PConfig: required")
	}
	if _, ok := raw["block_trade"]; raw != nil && !ok {
		return fmt.Errorf("field block_trade in WebsiteStatusRespWebsiteStatusP2PConfig: required")
	}
	if _, ok := raw["cancellation_block_duration"]; raw != nil && !ok {
		return fmt.Errorf("field cancellation_block_duration in WebsiteStatusRespWebsiteStatusP2PConfig: required")
	}
	if _, ok := raw["cancellation_count_period"]; raw != nil && !ok {
		return fmt.Errorf("field cancellation_count_period in WebsiteStatusRespWebsiteStatusP2PConfig: required")
	}
	if _, ok := raw["cancellation_grace_period"]; raw != nil && !ok {
		return fmt.Errorf("field cancellation_grace_period in WebsiteStatusRespWebsiteStatusP2PConfig: required")
	}
	if _, ok := raw["cancellation_limit"]; raw != nil && !ok {
		return fmt.Errorf("field cancellation_limit in WebsiteStatusRespWebsiteStatusP2PConfig: required")
	}
	if _, ok := raw["cross_border_ads_enabled"]; raw != nil && !ok {
		return fmt.Errorf("field cross_border_ads_enabled in WebsiteStatusRespWebsiteStatusP2PConfig: required")
	}
	if _, ok := raw["disabled"]; raw != nil && !ok {
		return fmt.Errorf("field disabled in WebsiteStatusRespWebsiteStatusP2PConfig: required")
	}
	if _, ok := raw["feature_level"]; raw != nil && !ok {
		return fmt.Errorf("field feature_level in WebsiteStatusRespWebsiteStatusP2PConfig: required")
	}
	if _, ok := raw["fixed_rate_adverts"]; raw != nil && !ok {
		return fmt.Errorf("field fixed_rate_adverts in WebsiteStatusRespWebsiteStatusP2PConfig: required")
	}
	if _, ok := raw["float_rate_adverts"]; raw != nil && !ok {
		return fmt.Errorf("field float_rate_adverts in WebsiteStatusRespWebsiteStatusP2PConfig: required")
	}
	if _, ok := raw["float_rate_offset_limit"]; raw != nil && !ok {
		return fmt.Errorf("field float_rate_offset_limit in WebsiteStatusRespWebsiteStatusP2PConfig: required")
	}
	if _, ok := raw["local_currencies"]; raw != nil && !ok {
		return fmt.Errorf("field local_currencies in WebsiteStatusRespWebsiteStatusP2PConfig: required")
	}
	if _, ok := raw["maximum_advert_amount"]; raw != nil && !ok {
		return fmt.Errorf("field maximum_advert_amount in WebsiteStatusRespWebsiteStatusP2PConfig: required")
	}
	if _, ok := raw["maximum_order_amount"]; raw != nil && !ok {
		return fmt.Errorf("field maximum_order_amount in WebsiteStatusRespWebsiteStatusP2PConfig: required")
	}
	if _, ok := raw["order_daily_limit"]; raw != nil && !ok {
		return fmt.Errorf("field order_daily_limit in WebsiteStatusRespWebsiteStatusP2PConfig: required")
	}
	if _, ok := raw["order_payment_period"]; raw != nil && !ok {
		return fmt.Errorf("field order_payment_period in WebsiteStatusRespWebsiteStatusP2PConfig: required")
	}
	if _, ok := raw["payment_methods_enabled"]; raw != nil && !ok {
		return fmt.Errorf("field payment_methods_enabled in WebsiteStatusRespWebsiteStatusP2PConfig: required")
	}
	if _, ok := raw["review_period"]; raw != nil && !ok {
		return fmt.Errorf("field review_period in WebsiteStatusRespWebsiteStatusP2PConfig: required")
	}
	if _, ok := raw["supported_currencies"]; raw != nil && !ok {
		return fmt.Errorf("field supported_currencies in WebsiteStatusRespWebsiteStatusP2PConfig: required")
	}
	type Plain WebsiteStatusRespWebsiteStatusP2PConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = WebsiteStatusRespWebsiteStatusP2PConfig(plain)
	return nil
}

// Payments Agents system settings.
type WebsiteStatusRespWebsiteStatusPaymentAgents struct {
	// Initial deposit requirement per country.
	InitialDepositPerCountry WebsiteStatusRespWebsiteStatusPaymentAgentsInitialDepositPerCountry `json:"initial_deposit_per_country"`
}

// Initial deposit requirement per country.
type WebsiteStatusRespWebsiteStatusPaymentAgentsInitialDepositPerCountry map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusPaymentAgents) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["initial_deposit_per_country"]; raw != nil && !ok {
		return fmt.Errorf("field initial_deposit_per_country in WebsiteStatusRespWebsiteStatusPaymentAgents: required")
	}
	type Plain WebsiteStatusRespWebsiteStatusPaymentAgents
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = WebsiteStatusRespWebsiteStatusPaymentAgents(plain)
	return nil
}

type WebsiteStatusRespWebsiteStatusSiteStatus string

const WebsiteStatusRespWebsiteStatusSiteStatusDown WebsiteStatusRespWebsiteStatusSiteStatus = "down"
const WebsiteStatusRespWebsiteStatusSiteStatusUp WebsiteStatusRespWebsiteStatusSiteStatus = "up"
const WebsiteStatusRespWebsiteStatusSiteStatusUpdating WebsiteStatusRespWebsiteStatusSiteStatus = "updating"

var enumValues_WebsiteStatusRespWebsiteStatusSiteStatus = []interface{}{
	"up",
	"down",
	"updating",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusSiteStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WebsiteStatusRespWebsiteStatusSiteStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WebsiteStatusRespWebsiteStatusSiteStatus, v)
	}
	*j = WebsiteStatusRespWebsiteStatusSiteStatus(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatus) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["api_call_limits"]; raw != nil && !ok {
		return fmt.Errorf("field api_call_limits in WebsiteStatusRespWebsiteStatus: required")
	}
	if _, ok := raw["currencies_config"]; raw != nil && !ok {
		return fmt.Errorf("field currencies_config in WebsiteStatusRespWebsiteStatus: required")
	}
	type Plain WebsiteStatusRespWebsiteStatus
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = WebsiteStatusRespWebsiteStatus(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["echo_req"]; raw != nil && !ok {
		return fmt.Errorf("field echo_req in WebsiteStatusResp: required")
	}
	if _, ok := raw["msg_type"]; raw != nil && !ok {
		return fmt.Errorf("field msg_type in WebsiteStatusResp: required")
	}
	type Plain WebsiteStatusResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = WebsiteStatusResp(plain)
	return nil
}
