// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "fmt"
import "reflect"
import "encoding/json"

// Retrieve a list of all currently active symbols (underlying markets upon which
// contracts are available for trading).
type ActiveSymbols struct {
	// If you use `brief`, only a subset of fields will be returned.
	ActiveSymbols ActiveSymbolsActiveSymbols `json:"active_symbols"`

	// Deprecated - replaced by landing_company_short.
	LandingCompany *ActiveSymbolsLandingCompany `json:"landing_company,omitempty"`

	// [Optional] If you specify this field, only symbols available for trading by
	// that landing company will be returned. If you are logged in, only symbols
	// available for trading by your landing company will be returned regardless of
	// what you specify in this field.
	LandingCompanyShort *ActiveSymbolsLandingCompanyShort `json:"landing_company_short,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough ActiveSymbolsPassthrough `json:"passthrough,omitempty"`

	// [Optional] If you specify this field, only symbols that can be traded through
	// that product type will be returned.
	ProductType *ActiveSymbolsProductType `json:"product_type,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type ActiveSymbolsActiveSymbols string

const ActiveSymbolsActiveSymbolsBrief ActiveSymbolsActiveSymbols = "brief"
const ActiveSymbolsActiveSymbolsFull ActiveSymbolsActiveSymbols = "full"

type ActiveSymbolsLandingCompany string

const ActiveSymbolsLandingCompanyChampion ActiveSymbolsLandingCompany = "champion"
const ActiveSymbolsLandingCompanyChampionVirtual ActiveSymbolsLandingCompany = "champion-virtual"
const ActiveSymbolsLandingCompanyIom ActiveSymbolsLandingCompany = "iom"
const ActiveSymbolsLandingCompanyMalta ActiveSymbolsLandingCompany = "malta"
const ActiveSymbolsLandingCompanyMaltainvest ActiveSymbolsLandingCompany = "maltainvest"

type ActiveSymbolsLandingCompanyShort string

const ActiveSymbolsLandingCompanyShortChampion ActiveSymbolsLandingCompanyShort = "champion"
const ActiveSymbolsLandingCompanyShortChampionVirtual ActiveSymbolsLandingCompanyShort = "champion-virtual"
const ActiveSymbolsLandingCompanyShortIom ActiveSymbolsLandingCompanyShort = "iom"
const ActiveSymbolsLandingCompanyShortMalta ActiveSymbolsLandingCompanyShort = "malta"
const ActiveSymbolsLandingCompanyShortMaltainvest ActiveSymbolsLandingCompanyShort = "maltainvest"
const ActiveSymbolsLandingCompanyShortSvg ActiveSymbolsLandingCompanyShort = "svg"
const ActiveSymbolsLandingCompanyShortVanuatu ActiveSymbolsLandingCompanyShort = "vanuatu"
const ActiveSymbolsLandingCompanyShortVirtual ActiveSymbolsLandingCompanyShort = "virtual"
const ActiveSymbolsLandingCompanySvg ActiveSymbolsLandingCompany = "svg"
const ActiveSymbolsLandingCompanyVanuatu ActiveSymbolsLandingCompany = "vanuatu"
const ActiveSymbolsLandingCompanyVirtual ActiveSymbolsLandingCompany = "virtual"

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type ActiveSymbolsPassthrough map[string]interface{}

type ActiveSymbolsProductType string

const ActiveSymbolsProductTypeBasic ActiveSymbolsProductType = "basic"

// A message containing the list of active symbols.
type ActiveSymbolsResp struct {
	// List of active symbols.
	ActiveSymbols []ActiveSymbolsRespActiveSymbolsElem `json:"active_symbols,omitempty"`

	// Echo of the request made.
	EchoReq ActiveSymbolsRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType ActiveSymbolsRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// The information about each symbol.
type ActiveSymbolsRespActiveSymbolsElem struct {
	// `1` if the symbol is tradable in a forward starting contract, `0` if not.
	AllowForwardStarting *ActiveSymbolsRespActiveSymbolsElemAllowForwardStarting `json:"allow_forward_starting,omitempty"`

	// Amount the data feed is delayed (in minutes) due to Exchange licensing
	// requirements. Only returned on `full` active symbols call.
	DelayAmount *int `json:"delay_amount,omitempty"`

	// Display name.
	DisplayName string `json:"display_name"`

	// Display order.
	DisplayOrder int `json:"display_order"`

	// `1` if market is currently open, `0` if closed.
	ExchangeIsOpen ActiveSymbolsRespActiveSymbolsElemExchangeIsOpen `json:"exchange_is_open"`

	// Exchange name (for underlyings listed on a Stock Exchange). Only returned on
	// `full` active symbols call.
	ExchangeName *string `json:"exchange_name,omitempty"`

	// Intraday interval minutes. Only returned on `full` active symbols call.
	IntradayIntervalMinutes *int `json:"intraday_interval_minutes,omitempty"`

	// `1` indicates that trading is currently suspended, `0` if not.
	IsTradingSuspended ActiveSymbolsRespActiveSymbolsElemIsTradingSuspended `json:"is_trading_suspended"`

	// Market category (forex, indices, etc).
	Market string `json:"market"`

	// Translated market name.
	MarketDisplayName string `json:"market_display_name"`

	// Pip size (i.e. minimum fluctuation amount).
	Pip float64 `json:"pip"`

	// For stock indices, the underlying currency for that instrument. Only returned
	// on `full` active symbols call.
	QuotedCurrencySymbol *string `json:"quoted_currency_symbol,omitempty"`

	// Latest spot price of the underlying. Only returned on `full` active symbols
	// call.
	Spot interface{} `json:"spot,omitempty"`

	// Number of seconds elapsed since the last spot price. Only returned on `full`
	// active symbols call.
	SpotAge *string `json:"spot_age,omitempty"`

	// Daily percentage for a symbol. Only returned on 'full' active symbols call.
	SpotPercentageChange *string `json:"spot_percentage_change,omitempty"`

	// Latest spot epoch time. Only returned on `full` active symbols call.
	SpotTime *string `json:"spot_time,omitempty"`

	// Subgroup name.
	Subgroup string `json:"subgroup"`

	// Translated subgroup name.
	SubgroupDisplayName string `json:"subgroup_display_name"`

	// Submarket name.
	Submarket string `json:"submarket"`

	// Translated submarket name.
	SubmarketDisplayName string `json:"submarket_display_name"`

	// The symbol code for this underlying.
	Symbol string `json:"symbol"`

	// Symbol type (forex, commodities, etc).
	SymbolType string `json:"symbol_type"`
}

type ActiveSymbolsRespActiveSymbolsElemAllowForwardStarting int

type ActiveSymbolsRespActiveSymbolsElemExchangeIsOpen int

type ActiveSymbolsRespActiveSymbolsElemIsTradingSuspended int

// Echo of the request made.
type ActiveSymbolsRespEchoReq map[string]interface{}

type ActiveSymbolsRespMsgType string

const ActiveSymbolsRespMsgTypeActiveSymbols ActiveSymbolsRespMsgType = "active_symbols"

// This call manages API tokens
type ApiToken struct {
	// Must be `1`
	ApiToken ApiTokenApiToken `json:"api_token"`

	// [Optional] The token to remove.
	DeleteToken *string `json:"delete_token,omitempty"`

	// [Optional] The name of the created token.
	NewToken *string `json:"new_token,omitempty"`

	// [Optional] List of permission scopes to provide with the token.
	NewTokenScopes []ApiTokenNewTokenScopesElem `json:"new_token_scopes,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough ApiTokenPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// [Optional] If you set this parameter during token creation, then the token
	// created will only work for the IP address that was used to create the token
	ValidForCurrentIpOnly *ApiTokenValidForCurrentIpOnly `json:"valid_for_current_ip_only,omitempty"`
}

type ApiTokenApiToken int

type ApiTokenNewTokenScopesElem string

const ApiTokenNewTokenScopesElemAdmin ApiTokenNewTokenScopesElem = "admin"
const ApiTokenNewTokenScopesElemPayments ApiTokenNewTokenScopesElem = "payments"
const ApiTokenNewTokenScopesElemRead ApiTokenNewTokenScopesElem = "read"
const ApiTokenNewTokenScopesElemTrade ApiTokenNewTokenScopesElem = "trade"
const ApiTokenNewTokenScopesElemTradingInformation ApiTokenNewTokenScopesElem = "trading_information"

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type ApiTokenPassthrough map[string]interface{}

// The result of the API token request made.
type ApiTokenResp struct {
	// Contains the result of API token according to the type of request.
	ApiToken *ApiTokenRespApiToken `json:"api_token,omitempty"`

	// Echo of the request made.
	EchoReq ApiTokenRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType ApiTokenRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Contains the result of API token according to the type of request.
type ApiTokenRespApiToken struct {
	// Token deleted.
	DeleteToken *ApiTokenRespApiTokenDeleteToken `json:"delete_token,omitempty"`

	// Token created.
	NewToken *ApiTokenRespApiTokenNewToken `json:"new_token,omitempty"`

	// API tokens
	Tokens []ApiTokenRespApiTokenTokensElem `json:"tokens,omitempty"`
}

type ApiTokenRespApiTokenDeleteToken int

type ApiTokenRespApiTokenNewToken int

// The information for each token.
type ApiTokenRespApiTokenTokensElem struct {
	// The token name specified when creating.
	DisplayName *string `json:"display_name,omitempty"`

	// The last date which the token has been used.
	LastUsed *string `json:"last_used,omitempty"`

	// List of permission scopes of the token.
	Scopes []ApiTokenRespApiTokenTokensElemScopesElem `json:"scopes,omitempty"`

	// The token that can be used to `authorize` with.
	Token *string `json:"token,omitempty"`

	// The IP restriction for the token. No restriction if empty.
	ValidForIp *string `json:"valid_for_ip,omitempty"`
}

type ApiTokenRespApiTokenTokensElemScopesElem string

const ApiTokenRespApiTokenTokensElemScopesElemAdmin ApiTokenRespApiTokenTokensElemScopesElem = "admin"
const ApiTokenRespApiTokenTokensElemScopesElemPayments ApiTokenRespApiTokenTokensElemScopesElem = "payments"
const ApiTokenRespApiTokenTokensElemScopesElemRead ApiTokenRespApiTokenTokensElemScopesElem = "read"
const ApiTokenRespApiTokenTokensElemScopesElemTrade ApiTokenRespApiTokenTokensElemScopesElem = "trade"
const ApiTokenRespApiTokenTokensElemScopesElemTradingInformation ApiTokenRespApiTokenTokensElemScopesElem = "trading_information"

// Echo of the request made.
type ApiTokenRespEchoReq map[string]interface{}

type ApiTokenRespMsgType string

const ApiTokenRespMsgTypeApiToken ApiTokenRespMsgType = "api_token"

type ApiTokenValidForCurrentIpOnly int

// The request for deleting an application.
type AppDelete struct {
	// Application app_id
	AppDelete int `json:"app_delete"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough AppDeletePassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type AppDeletePassthrough map[string]interface{}

// The result of delete application request made.
type AppDeleteResp struct {
	// 1 on success
	AppDelete *int `json:"app_delete,omitempty"`

	// Echo of the request made.
	EchoReq AppDeleteRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType AppDeleteRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type AppDeleteRespEchoReq map[string]interface{}

type AppDeleteRespMsgType string

const AppDeleteRespMsgTypeAppDelete AppDeleteRespMsgType = "app_delete"

// To get the information of the OAuth application specified by 'app_id'
type AppGet struct {
	// Application app_id
	AppGet int `json:"app_get"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough AppGetPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type AppGetPassthrough map[string]interface{}

// A message with requested application details
type AppGetResp struct {
	// The information of the requested application.
	AppGet *AppGetRespAppGet `json:"app_get,omitempty"`

	// Echo of the request made.
	EchoReq AppGetRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType AppGetRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// The information of the requested application.
type AppGetRespAppGet struct {
	// Active.
	Active *int `json:"active,omitempty"`

	// Application ID.
	AppId int `json:"app_id"`

	// Markup added to contract prices (as a percentage of contract payout).
	AppMarkupPercentage float64 `json:"app_markup_percentage"`

	// Application's App Store URL.
	Appstore string `json:"appstore"`

	// Application's GitHub page (for open-source projects).
	Github string `json:"github"`

	// Application's Google Play URL.
	Googleplay string `json:"googleplay"`

	// Application's homepage URL.
	Homepage string `json:"homepage"`

	// Application name.
	Name string `json:"name"`

	// The URL to redirect to after a successful login.
	RedirectUri string `json:"redirect_uri"`

	// Scope Details.
	Scopes []string `json:"scopes,omitempty"`

	// Used when `verify_email` called. If available, a URL containing the
	// verification token will send to the client's email, otherwise only the token
	// will be sent.
	VerificationUri string `json:"verification_uri"`
}

// Echo of the request made.
type AppGetRespEchoReq map[string]interface{}

type AppGetRespMsgType string

const AppGetRespMsgTypeAppGet AppGetRespMsgType = "app_get"

// List all of the account's OAuth applications
type AppList struct {
	// Must be `1`
	AppList AppListAppList `json:"app_list"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough AppListPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type AppListAppList int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type AppListPassthrough map[string]interface{}

// A message with created applications
type AppListResp struct {
	// List of created applications for the authorized account.
	AppList []AppListRespAppListElem `json:"app_list,omitempty"`

	// Echo of the request made.
	EchoReq AppListRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType AppListRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

type AppListRespAppListElem struct {
	// Active.
	Active *int `json:"active,omitempty"`

	// Application ID.
	AppId int `json:"app_id"`

	// Markup added to contract prices (as a percentage of contract payout).
	AppMarkupPercentage float64 `json:"app_markup_percentage"`

	// Application's App Store URL.
	Appstore interface{} `json:"appstore"`

	// Application's GitHub page. (for open-source projects)
	Github interface{} `json:"github"`

	// Application's Google Play URL.
	Googleplay interface{} `json:"googleplay"`

	// Application's homepage URL.
	Homepage interface{} `json:"homepage"`

	// Application name.
	Name string `json:"name"`

	// The URL to redirect to after a successful login.
	RedirectUri string `json:"redirect_uri"`

	// Scope Details.
	Scopes []string `json:"scopes,omitempty"`

	// Used when `verify_email` called. If available, a URL containing the
	// verification token will send to the client's email, otherwise only the token
	// will be sent.
	VerificationUri interface{} `json:"verification_uri"`
}

// Echo of the request made.
type AppListRespEchoReq map[string]interface{}

type AppListRespMsgType string

const AppListRespMsgTypeAppList AppListRespMsgType = "app_list"

// Retrieve details of `app_markup` according to criteria specified.
type AppMarkupDetails struct {
	// [Optional] Specific application `app_id` to report on.
	AppId *int `json:"app_id,omitempty"`

	// Must be `1`
	AppMarkupDetails AppMarkupDetailsAppMarkupDetails `json:"app_markup_details"`

	// [Optional] Specific client loginid to report on, like CR12345
	ClientLoginid *string `json:"client_loginid,omitempty"`

	// Start date (epoch or YYYY-MM-DD HH:MM:SS). Results are inclusive of this time.
	DateFrom string `json:"date_from"`

	// End date (epoch or YYYY-MM-DD HH::MM::SS). Results are inclusive of this time.
	DateTo string `json:"date_to"`

	// [Optional] If set to 1, will return `app_markup` transaction details.
	Description *AppMarkupDetailsDescription `json:"description,omitempty"`

	// [Optional] Apply upper limit to count of transactions received.
	Limit float64 `json:"limit,omitempty"`

	// [Optional] Number of transactions to skip.
	Offset *int `json:"offset,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough AppMarkupDetailsPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// [Optional] Sort direction on `transaction_time`. Other fields sort order is
	// ASC.
	Sort AppMarkupDetailsSort `json:"sort,omitempty"`

	// [Optional] One or more of the specified fields to sort on. Default sort field
	// is by `transaction_time`.
	SortFields []AppMarkupDetailsSortFieldsElem `json:"sort_fields,omitempty"`
}

type AppMarkupDetailsAppMarkupDetails int

type AppMarkupDetailsDescription int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type AppMarkupDetailsPassthrough map[string]interface{}

// Per transaction reporting of app_markup
type AppMarkupDetailsResp struct {
	// App Markup transaction details
	AppMarkupDetails *AppMarkupDetailsRespAppMarkupDetails `json:"app_markup_details,omitempty"`

	// Echo of the request made.
	EchoReq AppMarkupDetailsRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType AppMarkupDetailsRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// App Markup transaction details
type AppMarkupDetailsRespAppMarkupDetails struct {
	// Array of returned transactions
	Transactions []AppMarkupDetailsRespAppMarkupDetailsTransactionsElem `json:"transactions,omitempty"`
}

type AppMarkupDetailsRespAppMarkupDetailsTransactionsElem struct {
	// ID of the application where this contract was purchased.
	AppId *int `json:"app_id,omitempty"`

	// The markup the client paid in their currency
	AppMarkup *float64 `json:"app_markup,omitempty"`

	// The markup the client paid in USD
	AppMarkupUsd *float64 `json:"app_markup_usd,omitempty"`

	// The markup the client paid in the app developer's currency
	AppMarkupValue *float64 `json:"app_markup_value,omitempty"`

	// Currency code of the client
	ClientCurrcode *string `json:"client_currcode,omitempty"`

	// Login ID of the client
	ClientLoginid *string `json:"client_loginid,omitempty"`

	// Currency code of the app developer
	DevCurrcode *string `json:"dev_currcode,omitempty"`

	// Login ID of the app developer
	DevLoginid *string `json:"dev_loginid,omitempty"`

	// The transaction ID. Every contract (buy or sell) and every payment has a unique
	// ID.
	TransactionId *int `json:"transaction_id,omitempty"`

	// The epoch value of purchase time of transaction
	TransactionTime *string `json:"transaction_time,omitempty"`
}

// Echo of the request made.
type AppMarkupDetailsRespEchoReq map[string]interface{}

type AppMarkupDetailsRespMsgType string

const AppMarkupDetailsRespMsgTypeAppMarkupDetails AppMarkupDetailsRespMsgType = "app_markup_details"

type AppMarkupDetailsSort string

const AppMarkupDetailsSortASC AppMarkupDetailsSort = "ASC"
const AppMarkupDetailsSortDESC AppMarkupDetailsSort = "DESC"

type AppMarkupDetailsSortFieldsElem string

const AppMarkupDetailsSortFieldsElemAppId AppMarkupDetailsSortFieldsElem = "app_id"
const AppMarkupDetailsSortFieldsElemClientLoginid AppMarkupDetailsSortFieldsElem = "client_loginid"
const AppMarkupDetailsSortFieldsElemTransactionTime AppMarkupDetailsSortFieldsElem = "transaction_time"

// Retrieve statistics of `app_markup`.
type AppMarkupStatistics struct {
	// Must be `1`
	AppMarkupStatistics AppMarkupStatisticsAppMarkupStatistics `json:"app_markup_statistics"`

	// Start date (epoch or YYYY-MM-DD HH:MM:SS). Results are inclusive of this time.
	DateFrom string `json:"date_from"`

	// End date (epoch or YYYY-MM-DD HH::MM::SS). Results are inclusive of this time.
	DateTo string `json:"date_to"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough AppMarkupStatisticsPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type AppMarkupStatisticsAppMarkupStatistics int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type AppMarkupStatisticsPassthrough map[string]interface{}

// Per application reporting of app_markup
type AppMarkupStatisticsResp struct {
	// App Markup transaction statistics
	AppMarkupStatistics *AppMarkupStatisticsRespAppMarkupStatistics `json:"app_markup_statistics,omitempty"`

	// Echo of the request made.
	EchoReq AppMarkupStatisticsRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType AppMarkupStatisticsRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// App Markup transaction statistics
type AppMarkupStatisticsRespAppMarkupStatistics struct {
	// Array of summed app markups grouped by app_id
	Breakdown []AppMarkupStatisticsRespAppMarkupStatisticsBreakdownElem `json:"breakdown,omitempty"`

	// The sum of markup the client paid in USD
	TotalAppMarkupUsd *float64 `json:"total_app_markup_usd,omitempty"`

	// The total count of transactions
	TotalTransactionsCount *float64 `json:"total_transactions_count,omitempty"`
}

type AppMarkupStatisticsRespAppMarkupStatisticsBreakdownElem struct {
	// ID of the application where this contract was purchased.
	AppId *int `json:"app_id,omitempty"`

	// The sum of markup the client paid in USD
	AppMarkupUsd *float64 `json:"app_markup_usd,omitempty"`

	// The sum of markup the client paid in developer's currency
	AppMarkupValue *float64 `json:"app_markup_value,omitempty"`

	// Currency code of the app developer
	DevCurrcode *string `json:"dev_currcode,omitempty"`

	// The count of app transactions
	TransactionsCount *float64 `json:"transactions_count,omitempty"`
}

// Echo of the request made.
type AppMarkupStatisticsRespEchoReq map[string]interface{}

type AppMarkupStatisticsRespMsgType string

const AppMarkupStatisticsRespMsgTypeAppMarkupStatistics AppMarkupStatisticsRespMsgType = "app_markup_statistics"

// Register a new OAuth application
type AppRegister struct {
	// [Optional] Markup to be added to contract prices (as a percentage of contract
	// payout).
	AppMarkupPercentage *float64 `json:"app_markup_percentage,omitempty"`

	// Must be `1`
	AppRegister AppRegisterAppRegister `json:"app_register"`

	// [Optional] Application's App Store URL (if applicable).
	Appstore *string `json:"appstore,omitempty"`

	// [Optional] Application's GitHub page (for open-source projects).
	Github *string `json:"github,omitempty"`

	// [Optional] Application's Google Play URL (if applicable).
	Googleplay *string `json:"googleplay,omitempty"`

	// [Optional] Application's homepage URL.
	Homepage *string `json:"homepage,omitempty"`

	// Application name.
	Name string `json:"name"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough AppRegisterPassthrough `json:"passthrough,omitempty"`

	// [Optional] The URL to redirect to after a successful login. Required if
	// charging markup percentage
	RedirectUri *string `json:"redirect_uri,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// List of permission scopes to grant the application.
	Scopes []AppRegisterScopesElem `json:"scopes"`

	// [Optional] Used when `verify_email` called. If available, a URL containing the
	// verification token will be sent to the client's email, otherwise only the token
	// will be sent.
	VerificationUri *string `json:"verification_uri,omitempty"`
}

type AppRegisterAppRegister int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type AppRegisterPassthrough map[string]interface{}

// A message with created application details
type AppRegisterResp struct {
	// The information of the created application.
	AppRegister *AppRegisterRespAppRegister `json:"app_register,omitempty"`

	// Echo of the request made.
	EchoReq AppRegisterRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType AppRegisterRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// The information of the created application.
type AppRegisterRespAppRegister struct {
	// Active.
	Active *int `json:"active,omitempty"`

	// Application ID.
	AppId int `json:"app_id"`

	// Markup added to contract prices (as a percentage of contract payout).
	AppMarkupPercentage float64 `json:"app_markup_percentage"`

	// Application's App Store URL.
	Appstore string `json:"appstore"`

	// Application's GitHub page (for open-source projects).
	Github string `json:"github"`

	// Application's Google Play URL.
	Googleplay string `json:"googleplay"`

	// Application's homepage URL.
	Homepage string `json:"homepage"`

	// Application name.
	Name string `json:"name"`

	// The URL to redirect to after a successful login.
	RedirectUri string `json:"redirect_uri"`

	// Scope Details.
	Scopes []string `json:"scopes,omitempty"`

	// Used when `verify_email` called. If available, a URL containing the
	// verification token will send to the client's email, otherwise only the token
	// will be sent.
	VerificationUri string `json:"verification_uri"`
}

// Echo of the request made.
type AppRegisterRespEchoReq map[string]interface{}

type AppRegisterRespMsgType string

const AppRegisterRespMsgTypeAppRegister AppRegisterRespMsgType = "app_register"

type AppRegisterScopesElem string

const AppRegisterScopesElemAdmin AppRegisterScopesElem = "admin"
const AppRegisterScopesElemPayments AppRegisterScopesElem = "payments"
const AppRegisterScopesElemRead AppRegisterScopesElem = "read"
const AppRegisterScopesElemTrade AppRegisterScopesElem = "trade"
const AppRegisterScopesElemTradingInformation AppRegisterScopesElem = "trading_information"

// Update a new OAuth application
type AppUpdate struct {
	// [Optional] Markup to be added to contract prices (as a percentage of contract
	// payout).
	AppMarkupPercentage *float64 `json:"app_markup_percentage,omitempty"`

	// Application app_id.
	AppUpdate int `json:"app_update"`

	// [Optional] Application's App Store URL (if applicable).
	Appstore *string `json:"appstore,omitempty"`

	// [Optional] Application's GitHub page (for open-source projects).
	Github *string `json:"github,omitempty"`

	// [Optional] Application's Google Play URL (if applicable).
	Googleplay *string `json:"googleplay,omitempty"`

	// [Optional] Application's homepage URL.
	Homepage *string `json:"homepage,omitempty"`

	// Application name.
	Name string `json:"name"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough AppUpdatePassthrough `json:"passthrough,omitempty"`

	// [Optional] The URL to redirect to after a successful login. Required if
	// charging markup percentage.
	RedirectUri *string `json:"redirect_uri,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// Change scopes will revoke all user's grants and log them out.
	Scopes []AppUpdateScopesElem `json:"scopes"`

	// [Optional] Used when `verify_email` called. If available, a URL containing the
	// verification token will send to the client's email, otherwise only the token
	// will be sent.
	VerificationUri *string `json:"verification_uri,omitempty"`
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type AppUpdatePassthrough map[string]interface{}

// A message with created application
type AppUpdateResp struct {
	// Information of the updated application.
	AppUpdate *AppUpdateRespAppUpdate `json:"app_update,omitempty"`

	// Echo of the request made.
	EchoReq AppUpdateRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType AppUpdateRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Information of the updated application.
type AppUpdateRespAppUpdate struct {
	// Active.
	Active *int `json:"active,omitempty"`

	// Application ID.
	AppId *int `json:"app_id,omitempty"`

	// Markup added to contract prices (as a percentage of contract payout).
	AppMarkupPercentage *float64 `json:"app_markup_percentage,omitempty"`

	// Application's App Store URL.
	Appstore *string `json:"appstore,omitempty"`

	// Application's GitHub page (for open-source projects).
	Github *string `json:"github,omitempty"`

	// Application's Google Play URL.
	Googleplay *string `json:"googleplay,omitempty"`

	// Application's homepage URL.
	Homepage *string `json:"homepage,omitempty"`

	// Application name.
	Name *string `json:"name,omitempty"`

	// The URL to redirect to after a successful login.
	RedirectUri *string `json:"redirect_uri,omitempty"`

	// Scope Details.
	Scopes []string `json:"scopes,omitempty"`

	// Used when `verify_email` called. If available, a URL containing the
	// verification token will be sent to the client's email, otherwise only the token
	// will be sent.
	VerificationUri *string `json:"verification_uri,omitempty"`
}

// Echo of the request made.
type AppUpdateRespEchoReq map[string]interface{}

type AppUpdateRespMsgType string

const AppUpdateRespMsgTypeAppUpdate AppUpdateRespMsgType = "app_update"

type AppUpdateScopesElem string

const AppUpdateScopesElemAdmin AppUpdateScopesElem = "admin"
const AppUpdateScopesElemPayments AppUpdateScopesElem = "payments"
const AppUpdateScopesElemRead AppUpdateScopesElem = "read"
const AppUpdateScopesElemTrade AppUpdateScopesElem = "trade"
const AppUpdateScopesElemTradingInformation AppUpdateScopesElem = "trading_information"

// Retrieve a list of all available underlyings and the corresponding contract
// types and duration boundaries. If the user is logged in, only the assets
// available for that user's landing company will be returned.
type AssetIndex struct {
	// Must be `1`
	AssetIndex AssetIndexAssetIndex `json:"asset_index"`

	// Deprecated - replaced by landing_company_short.
	LandingCompany *AssetIndexLandingCompany `json:"landing_company,omitempty"`

	// [Optional] If specified, will return only the underlyings for the specified
	// landing company.
	LandingCompanyShort *AssetIndexLandingCompanyShort `json:"landing_company_short,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough AssetIndexPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type AssetIndexAssetIndex int

type AssetIndexLandingCompany string

const AssetIndexLandingCompanyChampion AssetIndexLandingCompany = "champion"
const AssetIndexLandingCompanyChampionVirtual AssetIndexLandingCompany = "champion-virtual"
const AssetIndexLandingCompanyIom AssetIndexLandingCompany = "iom"
const AssetIndexLandingCompanyMalta AssetIndexLandingCompany = "malta"
const AssetIndexLandingCompanyMaltainvest AssetIndexLandingCompany = "maltainvest"

type AssetIndexLandingCompanyShort string

const AssetIndexLandingCompanyShortChampion AssetIndexLandingCompanyShort = "champion"
const AssetIndexLandingCompanyShortChampionVirtual AssetIndexLandingCompanyShort = "champion-virtual"
const AssetIndexLandingCompanyShortIom AssetIndexLandingCompanyShort = "iom"
const AssetIndexLandingCompanyShortMalta AssetIndexLandingCompanyShort = "malta"
const AssetIndexLandingCompanyShortMaltainvest AssetIndexLandingCompanyShort = "maltainvest"
const AssetIndexLandingCompanyShortSvg AssetIndexLandingCompanyShort = "svg"
const AssetIndexLandingCompanyShortVanuatu AssetIndexLandingCompanyShort = "vanuatu"
const AssetIndexLandingCompanyShortVirtual AssetIndexLandingCompanyShort = "virtual"
const AssetIndexLandingCompanySvg AssetIndexLandingCompany = "svg"
const AssetIndexLandingCompanyVanuatu AssetIndexLandingCompany = "vanuatu"
const AssetIndexLandingCompanyVirtual AssetIndexLandingCompany = "virtual"

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type AssetIndexPassthrough map[string]interface{}

// A message with Asset Index
type AssetIndexResp struct {
	// List of underlyings by their display name and symbol followed by their
	// available contract types and duration boundaries.
	AssetIndex []interface{} `json:"asset_index,omitempty"`

	// Echo of the request made.
	EchoReq AssetIndexRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType AssetIndexRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type AssetIndexRespEchoReq map[string]interface{}

type AssetIndexRespMsgType string

const AssetIndexRespMsgTypeAssetIndex AssetIndexRespMsgType = "asset_index"

// Authorize current WebSocket session to act on behalf of the owner of a given
// token. Must precede requests that need to access client account, for example
// purchasing and selling contracts or viewing portfolio.
type Authorize struct {
	// [Optional] Send this when you use api tokens for authorization and want to
	// track activity using `login_history` call.
	AddToLoginHistory AuthorizeAddToLoginHistory `json:"add_to_login_history,omitempty"`

	// Authentication token. May be retrieved from
	// https://www.binary.com/en/user/security/api_tokenws.html
	Authorize string `json:"authorize"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough AuthorizePassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type AuthorizeAddToLoginHistory int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type AuthorizePassthrough map[string]interface{}

// A message containing account information for the holder of that token.
type AuthorizeResp struct {
	// Account information for the holder of the token.
	Authorize *AuthorizeRespAuthorize `json:"authorize,omitempty"`

	// Echo of the request made.
	EchoReq AuthorizeRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType AuthorizeRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Account information for the holder of the token.
type AuthorizeRespAuthorize struct {
	// List of accounts for current user.
	AccountList []AuthorizeRespAuthorizeAccountListElem `json:"account_list,omitempty"`

	// Cash balance of the account.
	Balance *float64 `json:"balance,omitempty"`

	// 2-letter country code (ISO standard).
	Country *string `json:"country,omitempty"`

	// Currency of the account.
	Currency *string `json:"currency,omitempty"`

	// User email.
	Email *string `json:"email,omitempty"`

	// User's full name. Will be empty for virtual accounts.
	Fullname *string `json:"fullname,omitempty"`

	// Boolean value: 1 or 0, indicating whether the account is a virtual-money
	// account.
	IsVirtual *AuthorizeRespAuthorizeIsVirtual `json:"is_virtual,omitempty"`

	// Landing company name the account belongs to.
	LandingCompanyFullname *string `json:"landing_company_fullname,omitempty"`

	// Landing company shortcode the account belongs to.
	LandingCompanyName *string `json:"landing_company_name,omitempty"`

	// Details of the list of Trading accounts linked to the Wallet account.
	LinkedTo []AuthorizeRespAuthorizeLinkedToElem `json:"linked_to,omitempty"`

	// Currencies in client's residence country
	LocalCurrencies AuthorizeRespAuthorizeLocalCurrencies `json:"local_currencies,omitempty"`

	// The account ID that the token was issued for.
	Loginid *string `json:"loginid,omitempty"`

	// User's preferred language, ISO standard code of language
	PreferredLanguage interface{} `json:"preferred_language,omitempty"`

	// Scopes available to the token.
	Scopes []string `json:"scopes,omitempty"`

	// List of landing company shortcodes the account can upgrade to.
	UpgradeableLandingCompanies []interface{} `json:"upgradeable_landing_companies,omitempty"`

	// The internal user ID for this account.
	UserId *int `json:"user_id,omitempty"`
}

type AuthorizeRespAuthorizeAccountListElem struct {
	// Account category.
	AccountCategory *AuthorizeRespAuthorizeAccountListElemAccountCategory `json:"account_category,omitempty"`

	// Account type.
	AccountType *string `json:"account_type,omitempty"`

	// Creation time of the account as epoch.
	CreatedAt *int `json:"created_at,omitempty"`

	// Currency of specified account.
	Currency *string `json:"currency,omitempty"`

	// Epoch of date till client has excluded him/herself from the website, only
	// present if client is self excluded.
	ExcludedUntil *int `json:"excluded_until,omitempty"`

	// Boolean value: 1 or 0, indicating whether the account is marked as disabled or
	// not.
	IsDisabled *AuthorizeRespAuthorizeAccountListElemIsDisabled `json:"is_disabled,omitempty"`

	// Boolean value: 1 or 0, indicating whether the account is a virtual-money
	// account.
	IsVirtual *AuthorizeRespAuthorizeAccountListElemIsVirtual `json:"is_virtual,omitempty"`

	// Landing company shortcode the account belongs to.
	LandingCompanyName *string `json:"landing_company_name,omitempty"`

	// Details of the list of Trading accounts linked to the Wallet account.
	LinkedTo []AuthorizeRespAuthorizeAccountListElemLinkedToElem `json:"linked_to,omitempty"`

	// The account ID of specified account.
	Loginid *string `json:"loginid,omitempty"`
}

type AuthorizeRespAuthorizeAccountListElemAccountCategory string

const AuthorizeRespAuthorizeAccountListElemAccountCategoryTrading AuthorizeRespAuthorizeAccountListElemAccountCategory = "trading"
const AuthorizeRespAuthorizeAccountListElemAccountCategoryWallet AuthorizeRespAuthorizeAccountListElemAccountCategory = "wallet"

type AuthorizeRespAuthorizeAccountListElemIsDisabled int

type AuthorizeRespAuthorizeAccountListElemIsVirtual int

type AuthorizeRespAuthorizeAccountListElemLinkedToElem struct {
	// Account ID.
	Loginid *string `json:"loginid,omitempty"`

	// Account platform name.
	Platform *AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatform `json:"platform,omitempty"`
}

type AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatform string

const AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatformDerivez AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatform = "derivez"
const AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatformDtrade AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatform = "dtrade"
const AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatformDwallet AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatform = "dwallet"
const AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatformDxtrade AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatform = "dxtrade"
const AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatformMt5 AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatform = "mt5"

type AuthorizeRespAuthorizeIsVirtual int

type AuthorizeRespAuthorizeLinkedToElem struct {
	// Account ID.
	Loginid *string `json:"loginid,omitempty"`

	// Account platform name.
	Platform *AuthorizeRespAuthorizeLinkedToElemPlatform `json:"platform,omitempty"`
}

type AuthorizeRespAuthorizeLinkedToElemPlatform string

const AuthorizeRespAuthorizeLinkedToElemPlatformDerivez AuthorizeRespAuthorizeLinkedToElemPlatform = "derivez"
const AuthorizeRespAuthorizeLinkedToElemPlatformDtrade AuthorizeRespAuthorizeLinkedToElemPlatform = "dtrade"
const AuthorizeRespAuthorizeLinkedToElemPlatformDwallet AuthorizeRespAuthorizeLinkedToElemPlatform = "dwallet"
const AuthorizeRespAuthorizeLinkedToElemPlatformDxtrade AuthorizeRespAuthorizeLinkedToElemPlatform = "dxtrade"
const AuthorizeRespAuthorizeLinkedToElemPlatformMt5 AuthorizeRespAuthorizeLinkedToElemPlatform = "mt5"

// Currencies in client's residence country
type AuthorizeRespAuthorizeLocalCurrencies map[string]interface{}

// Echo of the request made.
type AuthorizeRespEchoReq map[string]interface{}

type AuthorizeRespMsgType string

const AuthorizeRespMsgTypeAuthorize AuthorizeRespMsgType = "authorize"

// Get user account balance
type Balance struct {
	// [Optional] If set to `all`, return the balances of all accounts one by one; if
	// set to `current`, return the balance of current account; if set as an account
	// id, return the balance of that account.
	Account string `json:"account,omitempty"`

	// Must be `1`
	Balance BalanceBalance `json:"balance"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough BalancePassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// [Optional] If set to 1, will send updates whenever the balance changes.
	Subscribe *BalanceSubscribe `json:"subscribe,omitempty"`
}

type BalanceBalance int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type BalancePassthrough map[string]interface{}

// Return details of user account balance
type BalanceResp struct {
	// Current balance of one or more accounts.
	Balance *BalanceRespBalance `json:"balance,omitempty"`

	// Echo of the request made.
	EchoReq BalanceRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType BalanceRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// For subscription requests only.
	Subscription *BalanceRespSubscription `json:"subscription,omitempty"`
}

// Current balance of one or more accounts.
type BalanceRespBalance struct {
	// List of active accounts.
	Accounts BalanceRespBalanceAccounts `json:"accounts,omitempty"`

	// Balance of current account.
	Balance float64 `json:"balance"`

	// Currency of current account.
	Currency string `json:"currency"`

	// A per-connection unique identifier. Can be passed to the `forget` API call to
	// unsubscribe.
	Id *string `json:"id,omitempty"`

	// Client loginid.
	Loginid string `json:"loginid"`

	// Summary totals of accounts by type.
	Total *BalanceRespBalanceTotal `json:"total,omitempty"`
}

// List of active accounts.
type BalanceRespBalanceAccounts map[string]interface{}

// Summary totals of accounts by type.
type BalanceRespBalanceTotal struct {
	// Total balance of all real money Deriv accounts.
	Deriv *BalanceRespBalanceTotalDeriv `json:"deriv,omitempty"`

	// Total balance of all demo Deriv accounts.
	DerivDemo *BalanceRespBalanceTotalDerivDemo `json:"deriv_demo,omitempty"`

	// Total balance of all MT5 real money accounts.
	Mt5 *BalanceRespBalanceTotalMt5 `json:"mt5,omitempty"`

	// Total balance of all MT5 demo accounts.
	Mt5Demo *BalanceRespBalanceTotalMt5Demo `json:"mt5_demo,omitempty"`
}

// Total balance of all real money Deriv accounts.
type BalanceRespBalanceTotalDeriv struct {
	// Total of balances.
	Amount float64 `json:"amount"`

	// Currency of total.
	Currency string `json:"currency"`
}

// Total balance of all demo Deriv accounts.
type BalanceRespBalanceTotalDerivDemo struct {
	// Total of balances.
	Amount float64 `json:"amount"`

	// Currency of total.
	Currency string `json:"currency"`
}

// Total balance of all MT5 real money accounts.
type BalanceRespBalanceTotalMt5 struct {
	// Total balance of all MT5 accounts
	Amount float64 `json:"amount"`

	// Currency of total.
	Currency string `json:"currency"`
}

// Total balance of all MT5 demo accounts.
type BalanceRespBalanceTotalMt5Demo struct {
	// Total of balances.
	Amount float64 `json:"amount"`

	// Currency of total.
	Currency string `json:"currency"`
}

// Echo of the request made.
type BalanceRespEchoReq map[string]interface{}

type BalanceRespMsgType string

const BalanceRespMsgTypeBalance BalanceRespMsgType = "balance"

// For subscription requests only.
type BalanceRespSubscription struct {
	// A per-connection unique identifier. Can be passed to the `forget` API call to
	// unsubscribe.
	Id string `json:"id"`
}

type BalanceSubscribe int

// Buy a Contract
type Buy struct {
	// Either the ID received from a Price Proposal (`proposal` call), or `1` if
	// contract buy parameters are passed in the `parameters` field.
	Buy string `json:"buy"`

	// [Optional] Used to pass the parameters for contract buy.
	Parameters *BuyParameters `json:"parameters,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough BuyPassthrough `json:"passthrough,omitempty"`

	// Maximum price at which to purchase the contract.
	Price float64 `json:"price"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// [Optional] `1` to stream.
	Subscribe *BuySubscribe `json:"subscribe,omitempty"`
}

// Buy a Contract for multiple Accounts specified by the `tokens` parameter. Note,
// although this is an authorized call, the contract is not bought for the
// authorized account.
type BuyContractForMultipleAccounts struct {
	// Either the ID received from a Price Proposal (`proposal` call), or `1` if
	// contract buy parameters are passed in the `parameters` field.
	BuyContractForMultipleAccounts string `json:"buy_contract_for_multiple_accounts"`

	// [Optional] Used to pass the parameters for contract buy.
	Parameters *BuyContractForMultipleAccountsParameters `json:"parameters,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough BuyContractForMultipleAccountsPassthrough `json:"passthrough,omitempty"`

	// Maximum price at which to purchase the contract.
	Price float64 `json:"price"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// List of API tokens identifying the accounts for which the contract is bought.
	// Note: If the same token appears multiple times or if multiple tokens designate
	// the same account, the contract is bought multiple times for this account.
	Tokens []string `json:"tokens"`
}

// [Optional] Used to pass the parameters for contract buy.
type BuyContractForMultipleAccountsParameters struct {
	// [Optional] Proposed `payout` or `stake` value
	Amount *float64 `json:"amount,omitempty"`

	// [Optional] Markup added to contract prices (as a percentage of contract payout)
	AppMarkupPercentage *float64 `json:"app_markup_percentage,omitempty"`

	// [Optional] Barrier for the contract (or last digit prediction for digit
	// contracts). Contracts less than 24 hours in duration would need a relative
	// barrier (barriers which need +/-), where entry spot would be adjusted
	// accordingly with that amount to define a barrier, except for Synthetic Indices
	// as they support both relative and absolute barriers.
	Barrier *string `json:"barrier,omitempty"`

	// [Optional] Low barrier for the contract (for contracts with two barriers).
	// Contracts less than 24 hours in duration would need a relative barrier
	// (barriers which need +/-), where entry spot would be adjusted accordingly with
	// that amount to define a barrier, except for Synthetic Indices as they support
	// both relative and absolute barriers.
	Barrier2 *string `json:"barrier2,omitempty"`

	// [Optional] Indicate whether amount is 'payout' or 'stake'.
	Basis *BuyContractForMultipleAccountsParametersBasis `json:"basis,omitempty"`

	// A valid contract-type
	ContractType BuyContractForMultipleAccountsParametersContractType `json:"contract_type"`

	// This can only be the account-holder's currency
	Currency string `json:"currency"`

	// [Optional] Epoch value of the expiry time of the contract. You must either
	// specify `date_expiry` or `duration`.
	DateExpiry *int `json:"date_expiry,omitempty"`

	// [Optional] For forward-starting contracts, epoch value of the starting time of
	// the contract.
	DateStart *int `json:"date_start,omitempty"`

	// [Optional] Duration quantity
	Duration *int `json:"duration,omitempty"`

	// [Optional] Duration unit is `s`: seconds, `m`: minutes, `h`: hours, `d`: days,
	// `t`: ticks
	DurationUnit *BuyContractForMultipleAccountsParametersDurationUnit `json:"duration_unit,omitempty"`

	// [Optional] The multiplier for non-binary options. E.g. lookbacks.
	Multiplier *float64 `json:"multiplier,omitempty"`

	// [Optional] The tick that is predicted to have the highest/lowest value - for
	// tickhigh and ticklow contracts.
	SelectedTick *int `json:"selected_tick,omitempty"`

	// Symbol code
	Symbol string `json:"symbol"`
}

type BuyContractForMultipleAccountsParametersBasis string

const BuyContractForMultipleAccountsParametersBasisPayout BuyContractForMultipleAccountsParametersBasis = "payout"
const BuyContractForMultipleAccountsParametersBasisStake BuyContractForMultipleAccountsParametersBasis = "stake"

type BuyContractForMultipleAccountsParametersContractType string

const BuyContractForMultipleAccountsParametersContractTypeASIAND BuyContractForMultipleAccountsParametersContractType = "ASIAND"
const BuyContractForMultipleAccountsParametersContractTypeASIANU BuyContractForMultipleAccountsParametersContractType = "ASIANU"
const BuyContractForMultipleAccountsParametersContractTypeCALL BuyContractForMultipleAccountsParametersContractType = "CALL"
const BuyContractForMultipleAccountsParametersContractTypeCALLE BuyContractForMultipleAccountsParametersContractType = "CALLE"
const BuyContractForMultipleAccountsParametersContractTypeCALLSPREAD BuyContractForMultipleAccountsParametersContractType = "CALLSPREAD"
const BuyContractForMultipleAccountsParametersContractTypeDIGITDIFF BuyContractForMultipleAccountsParametersContractType = "DIGITDIFF"
const BuyContractForMultipleAccountsParametersContractTypeDIGITEVEN BuyContractForMultipleAccountsParametersContractType = "DIGITEVEN"
const BuyContractForMultipleAccountsParametersContractTypeDIGITMATCH BuyContractForMultipleAccountsParametersContractType = "DIGITMATCH"
const BuyContractForMultipleAccountsParametersContractTypeDIGITODD BuyContractForMultipleAccountsParametersContractType = "DIGITODD"
const BuyContractForMultipleAccountsParametersContractTypeDIGITOVER BuyContractForMultipleAccountsParametersContractType = "DIGITOVER"
const BuyContractForMultipleAccountsParametersContractTypeDIGITUNDER BuyContractForMultipleAccountsParametersContractType = "DIGITUNDER"
const BuyContractForMultipleAccountsParametersContractTypeEXPIRYMISS BuyContractForMultipleAccountsParametersContractType = "EXPIRYMISS"
const BuyContractForMultipleAccountsParametersContractTypeEXPIRYMISSE BuyContractForMultipleAccountsParametersContractType = "EXPIRYMISSE"
const BuyContractForMultipleAccountsParametersContractTypeEXPIRYRANGE BuyContractForMultipleAccountsParametersContractType = "EXPIRYRANGE"
const BuyContractForMultipleAccountsParametersContractTypeEXPIRYRANGEE BuyContractForMultipleAccountsParametersContractType = "EXPIRYRANGEE"
const BuyContractForMultipleAccountsParametersContractTypeLBFLOATCALL BuyContractForMultipleAccountsParametersContractType = "LBFLOATCALL"
const BuyContractForMultipleAccountsParametersContractTypeLBFLOATPUT BuyContractForMultipleAccountsParametersContractType = "LBFLOATPUT"
const BuyContractForMultipleAccountsParametersContractTypeLBHIGHLOW BuyContractForMultipleAccountsParametersContractType = "LBHIGHLOW"
const BuyContractForMultipleAccountsParametersContractTypeMULTDOWN BuyContractForMultipleAccountsParametersContractType = "MULTDOWN"
const BuyContractForMultipleAccountsParametersContractTypeMULTUP BuyContractForMultipleAccountsParametersContractType = "MULTUP"
const BuyContractForMultipleAccountsParametersContractTypeNOTOUCH BuyContractForMultipleAccountsParametersContractType = "NOTOUCH"
const BuyContractForMultipleAccountsParametersContractTypeONETOUCH BuyContractForMultipleAccountsParametersContractType = "ONETOUCH"
const BuyContractForMultipleAccountsParametersContractTypePUT BuyContractForMultipleAccountsParametersContractType = "PUT"
const BuyContractForMultipleAccountsParametersContractTypePUTE BuyContractForMultipleAccountsParametersContractType = "PUTE"
const BuyContractForMultipleAccountsParametersContractTypePUTSPREAD BuyContractForMultipleAccountsParametersContractType = "PUTSPREAD"
const BuyContractForMultipleAccountsParametersContractTypeRANGE BuyContractForMultipleAccountsParametersContractType = "RANGE"
const BuyContractForMultipleAccountsParametersContractTypeRESETCALL BuyContractForMultipleAccountsParametersContractType = "RESETCALL"
const BuyContractForMultipleAccountsParametersContractTypeRESETPUT BuyContractForMultipleAccountsParametersContractType = "RESETPUT"
const BuyContractForMultipleAccountsParametersContractTypeRUNHIGH BuyContractForMultipleAccountsParametersContractType = "RUNHIGH"
const BuyContractForMultipleAccountsParametersContractTypeRUNLOW BuyContractForMultipleAccountsParametersContractType = "RUNLOW"
const BuyContractForMultipleAccountsParametersContractTypeTICKHIGH BuyContractForMultipleAccountsParametersContractType = "TICKHIGH"
const BuyContractForMultipleAccountsParametersContractTypeTICKLOW BuyContractForMultipleAccountsParametersContractType = "TICKLOW"
const BuyContractForMultipleAccountsParametersContractTypeTURBOSLONG BuyContractForMultipleAccountsParametersContractType = "TURBOSLONG"
const BuyContractForMultipleAccountsParametersContractTypeTURBOSSHORT BuyContractForMultipleAccountsParametersContractType = "TURBOSSHORT"
const BuyContractForMultipleAccountsParametersContractTypeUPORDOWN BuyContractForMultipleAccountsParametersContractType = "UPORDOWN"
const BuyContractForMultipleAccountsParametersContractTypeVANILLALONGCALL BuyContractForMultipleAccountsParametersContractType = "VANILLALONGCALL"
const BuyContractForMultipleAccountsParametersContractTypeVANILLALONGPUT BuyContractForMultipleAccountsParametersContractType = "VANILLALONGPUT"

type BuyContractForMultipleAccountsParametersDurationUnit string

const BuyContractForMultipleAccountsParametersDurationUnitD BuyContractForMultipleAccountsParametersDurationUnit = "d"
const BuyContractForMultipleAccountsParametersDurationUnitH BuyContractForMultipleAccountsParametersDurationUnit = "h"
const BuyContractForMultipleAccountsParametersDurationUnitM BuyContractForMultipleAccountsParametersDurationUnit = "m"
const BuyContractForMultipleAccountsParametersDurationUnitS BuyContractForMultipleAccountsParametersDurationUnit = "s"
const BuyContractForMultipleAccountsParametersDurationUnitT BuyContractForMultipleAccountsParametersDurationUnit = "t"

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type BuyContractForMultipleAccountsPassthrough map[string]interface{}

// A message with transaction results is received
type BuyContractForMultipleAccountsResp struct {
	// Receipt confirmation for the purchase
	BuyContractForMultipleAccounts *BuyContractForMultipleAccountsRespBuyContractForMultipleAccounts `json:"buy_contract_for_multiple_accounts,omitempty"`

	// Echo of the request made.
	EchoReq BuyContractForMultipleAccountsRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType BuyContractForMultipleAccountsRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Receipt confirmation for the purchase
type BuyContractForMultipleAccountsRespBuyContractForMultipleAccounts struct {
	// List of results containing transactions and/or errors for the bought contracts.
	Result []interface{} `json:"result"`
}

// Echo of the request made.
type BuyContractForMultipleAccountsRespEchoReq map[string]interface{}

type BuyContractForMultipleAccountsRespMsgType string

const BuyContractForMultipleAccountsRespMsgTypeBuyContractForMultipleAccounts BuyContractForMultipleAccountsRespMsgType = "buy_contract_for_multiple_accounts"

// [Optional] Used to pass the parameters for contract buy.
type BuyParameters struct {
	// [Optional] Proposed payout or stake value
	Amount *float64 `json:"amount,omitempty"`

	// [Optional] Markup added to contract prices (as a percentage of contract payout)
	AppMarkupPercentage *float64 `json:"app_markup_percentage,omitempty"`

	// [Optional] Barrier for the contract (or last digit prediction for digit
	// contracts). Contracts less than 24 hours in duration would need a relative
	// barrier (barriers which need +/-), where entry spot would be adjusted
	// accordingly with that amount to define a barrier, except for Synthetic Indices
	// as they support both relative and absolute barriers.
	Barrier *string `json:"barrier,omitempty"`

	// [Optional] Low barrier for the contract (for contracts with two barriers).
	// Contracts less than 24 hours in duration would need a relative barrier
	// (barriers which need +/-), where entry spot would be adjusted accordingly with
	// that amount to define a barrier, except for Synthetic Indices as they support
	// both relative and absolute barriers.
	Barrier2 *string `json:"barrier2,omitempty"`

	// [Optional] Barrier range for callputspread.
	BarrierRange *BuyParametersBarrierRange `json:"barrier_range,omitempty"`

	// [Optional] Indicates whether amount is 'payout' or 'stake' for binary options.
	Basis *BuyParametersBasis `json:"basis,omitempty"`

	// Cancellation duration option (only for `MULTUP` and `MULTDOWN` contracts).
	Cancellation *string `json:"cancellation,omitempty"`

	// A valid contract-type
	ContractType BuyParametersContractType `json:"contract_type"`

	// This can only be the account-holder's currency
	Currency string `json:"currency"`

	// [Optional] Epoch value of the expiry time of the contract. You must either
	// specify date_expiry or duration.
	DateExpiry *int `json:"date_expiry,omitempty"`

	// [Optional] For forward-starting contracts, epoch value of the starting time of
	// the contract.
	DateStart *int `json:"date_start,omitempty"`

	// [Optional] Duration quantity
	Duration *int `json:"duration,omitempty"`

	// [Optional] Duration unit is `s`: seconds, `m`: minutes, `h`: hours, `d`: days,
	// `t`: ticks
	DurationUnit *BuyParametersDurationUnit `json:"duration_unit,omitempty"`

	// [Optional] Growth rate of an accumulator contract.
	GrowthRate *float64 `json:"growth_rate,omitempty"`

	// Add an order to close the contract once the order condition is met (only for
	// `MULTUP` and `MULTDOWN` and `ACCU` contracts).
	LimitOrder *BuyParametersLimitOrder `json:"limit_order,omitempty"`

	// [Optional] The multiplier for non-binary options. E.g. lookbacks.
	Multiplier *float64 `json:"multiplier,omitempty"`

	// [Optional] The product type.
	ProductType BuyParametersProductType `json:"product_type,omitempty"`

	// [Optional] The tick that is predicted to have the highest/lowest value - for
	// tickhigh and ticklow contracts.
	SelectedTick *int `json:"selected_tick,omitempty"`

	// Symbol code
	Symbol string `json:"symbol"`

	// [Optional] An epoch value of a predefined trading period start time
	TradingPeriodStart *int `json:"trading_period_start,omitempty"`
}

type BuyParametersBarrierRange string

const BuyParametersBarrierRangeMiddle BuyParametersBarrierRange = "middle"
const BuyParametersBarrierRangeTight BuyParametersBarrierRange = "tight"
const BuyParametersBarrierRangeWide BuyParametersBarrierRange = "wide"

type BuyParametersBasis string

const BuyParametersBasisPayout BuyParametersBasis = "payout"
const BuyParametersBasisStake BuyParametersBasis = "stake"

type BuyParametersContractType string

const BuyParametersContractTypeACCU BuyParametersContractType = "ACCU"
const BuyParametersContractTypeASIAND BuyParametersContractType = "ASIAND"
const BuyParametersContractTypeASIANU BuyParametersContractType = "ASIANU"
const BuyParametersContractTypeCALL BuyParametersContractType = "CALL"
const BuyParametersContractTypeCALLE BuyParametersContractType = "CALLE"
const BuyParametersContractTypeCALLSPREAD BuyParametersContractType = "CALLSPREAD"
const BuyParametersContractTypeDIGITDIFF BuyParametersContractType = "DIGITDIFF"
const BuyParametersContractTypeDIGITEVEN BuyParametersContractType = "DIGITEVEN"
const BuyParametersContractTypeDIGITMATCH BuyParametersContractType = "DIGITMATCH"
const BuyParametersContractTypeDIGITODD BuyParametersContractType = "DIGITODD"
const BuyParametersContractTypeDIGITOVER BuyParametersContractType = "DIGITOVER"
const BuyParametersContractTypeDIGITUNDER BuyParametersContractType = "DIGITUNDER"
const BuyParametersContractTypeEXPIRYMISS BuyParametersContractType = "EXPIRYMISS"
const BuyParametersContractTypeEXPIRYMISSE BuyParametersContractType = "EXPIRYMISSE"
const BuyParametersContractTypeEXPIRYRANGE BuyParametersContractType = "EXPIRYRANGE"
const BuyParametersContractTypeEXPIRYRANGEE BuyParametersContractType = "EXPIRYRANGEE"
const BuyParametersContractTypeLBFLOATCALL BuyParametersContractType = "LBFLOATCALL"
const BuyParametersContractTypeLBFLOATPUT BuyParametersContractType = "LBFLOATPUT"
const BuyParametersContractTypeLBHIGHLOW BuyParametersContractType = "LBHIGHLOW"
const BuyParametersContractTypeMULTDOWN BuyParametersContractType = "MULTDOWN"
const BuyParametersContractTypeMULTUP BuyParametersContractType = "MULTUP"
const BuyParametersContractTypeNOTOUCH BuyParametersContractType = "NOTOUCH"
const BuyParametersContractTypeONETOUCH BuyParametersContractType = "ONETOUCH"
const BuyParametersContractTypePUT BuyParametersContractType = "PUT"
const BuyParametersContractTypePUTE BuyParametersContractType = "PUTE"
const BuyParametersContractTypePUTSPREAD BuyParametersContractType = "PUTSPREAD"
const BuyParametersContractTypeRANGE BuyParametersContractType = "RANGE"
const BuyParametersContractTypeRESETCALL BuyParametersContractType = "RESETCALL"
const BuyParametersContractTypeRESETPUT BuyParametersContractType = "RESETPUT"
const BuyParametersContractTypeRUNHIGH BuyParametersContractType = "RUNHIGH"
const BuyParametersContractTypeRUNLOW BuyParametersContractType = "RUNLOW"
const BuyParametersContractTypeTICKHIGH BuyParametersContractType = "TICKHIGH"
const BuyParametersContractTypeTICKLOW BuyParametersContractType = "TICKLOW"
const BuyParametersContractTypeTURBOSLONG BuyParametersContractType = "TURBOSLONG"
const BuyParametersContractTypeTURBOSSHORT BuyParametersContractType = "TURBOSSHORT"
const BuyParametersContractTypeUPORDOWN BuyParametersContractType = "UPORDOWN"
const BuyParametersContractTypeVANILLALONGCALL BuyParametersContractType = "VANILLALONGCALL"
const BuyParametersContractTypeVANILLALONGPUT BuyParametersContractType = "VANILLALONGPUT"

type BuyParametersDurationUnit string

const BuyParametersDurationUnitD BuyParametersDurationUnit = "d"
const BuyParametersDurationUnitH BuyParametersDurationUnit = "h"
const BuyParametersDurationUnitM BuyParametersDurationUnit = "m"
const BuyParametersDurationUnitS BuyParametersDurationUnit = "s"
const BuyParametersDurationUnitT BuyParametersDurationUnit = "t"

// Add an order to close the contract once the order condition is met (only for
// `MULTUP` and `MULTDOWN` and `ACCU` contracts).
type BuyParametersLimitOrder struct {
	// Contract will be automatically closed when the value of the contract reaches a
	// specific loss.
	StopLoss *float64 `json:"stop_loss,omitempty"`

	// Contract will be automatically closed when the value of the contract reaches a
	// specific profit.
	TakeProfit *float64 `json:"take_profit,omitempty"`
}

type BuyParametersProductType string

const BuyParametersProductTypeBasic BuyParametersProductType = "basic"

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type BuyPassthrough map[string]interface{}

// A message with transaction results is received
type BuyResp struct {
	// Receipt confirmation for the purchase
	Buy *BuyRespBuy `json:"buy,omitempty"`

	// Echo of the request made.
	EchoReq BuyRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType BuyRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// For subscription requests only.
	Subscription *BuyRespSubscription `json:"subscription,omitempty"`
}

// Receipt confirmation for the purchase
type BuyRespBuy struct {
	// The new account balance after completion of the purchase
	BalanceAfter float64 `json:"balance_after"`

	// Actual effected purchase price
	BuyPrice float64 `json:"buy_price"`

	// Internal contract identifier
	ContractId int `json:"contract_id"`

	// The description of contract purchased
	Longcode string `json:"longcode"`

	// Proposed payout value
	Payout float64 `json:"payout"`

	// Epoch value of the transaction purchase time
	PurchaseTime int `json:"purchase_time"`

	// Compact description of the contract purchased
	Shortcode string `json:"shortcode"`

	// Epoch value showing the expected start time of the contract
	StartTime int `json:"start_time"`

	// Internal transaction identifier
	TransactionId int `json:"transaction_id"`
}

// Echo of the request made.
type BuyRespEchoReq map[string]interface{}

type BuyRespMsgType string

const BuyRespMsgTypeBuy BuyRespMsgType = "buy"

// For subscription requests only.
type BuyRespSubscription struct {
	// A per-connection unique identifier. Can be passed to the `forget` API call to
	// unsubscribe.
	Id string `json:"id"`
}

type BuySubscribe int

// Cancel contract with contract id
type Cancel struct {
	// Value should be the `contract_id` which received from the `portfolio` call.
	Cancel int `json:"cancel"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough CancelPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type CancelPassthrough map[string]interface{}

// A message with transaction results is received
type CancelResp struct {
	// Receipt for the transaction
	Cancel *CancelRespCancel `json:"cancel,omitempty"`

	// Echo of the request made.
	EchoReq CancelRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType CancelRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Receipt for the transaction
type CancelRespCancel struct {
	// New account balance after completion of the sale
	BalanceAfter *float64 `json:"balance_after,omitempty"`

	// Internal contract identifier for the sold contract
	ContractId *int `json:"contract_id,omitempty"`

	// Internal transaction identifier for the corresponding buy transaction
	ReferenceId *int `json:"reference_id,omitempty"`

	// Actual effected sale price
	SoldFor *float64 `json:"sold_for,omitempty"`

	// Internal transaction identifier for the sale transaction
	TransactionId *int `json:"transaction_id,omitempty"`
}

// Echo of the request made.
type CancelRespEchoReq map[string]interface{}

type CancelRespMsgType string

const CancelRespMsgTypeCancel CancelRespMsgType = "cancel"

// Request the cashier info for the specified type.
type Cashier struct {
	// [Optional] Address for crypto withdrawal. Only applicable for `api` type.
	Address *string `json:"address,omitempty"`

	// [Optional] Amount for crypto withdrawal. Only applicable for `api` type.
	Amount *float64 `json:"amount,omitempty"`

	// Operation which needs to be requested from cashier
	Cashier CashierCashier `json:"cashier"`

	// [Optional] If set to `1`, only validation is performed. Only applicable for
	// `withdraw` using `crypto` provider and `api` type.
	DryRun CashierDryRun `json:"dry_run,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough CashierPassthrough `json:"passthrough,omitempty"`

	// [Optional] Cashier provider. `crypto` will be default option for crypto
	// currency accounts.
	Provider CashierProvider `json:"provider,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// [Optional] Data need to be returned from cashier. `api` is supported only for
	// `crypto` provider.
	Type CashierType `json:"type,omitempty"`

	// [Optional] Email verification code (received from a `verify_email` call, which
	// must be done first)
	VerificationCode *string `json:"verification_code,omitempty"`
}

type CashierCashier string

const CashierCashierDeposit CashierCashier = "deposit"
const CashierCashierWithdraw CashierCashier = "withdraw"

type CashierDryRun int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type CashierPassthrough map[string]interface{}

type CashierProvider string

const CashierProviderCrypto CashierProvider = "crypto"
const CashierProviderDoughflow CashierProvider = "doughflow"

// Cashier information for the specified type.
type CashierResp struct {
	// Possible error codes are:
	// - `ASK_TNC_APPROVAL`: API call `tnc_approval`
	// - `ASK_AUTHENTICATE`
	// - `ASK_UK_FUNDS_PROTECTION`: API call `tnc_approval`
	// - `ASK_CURRENCY`: API call `set_account_currency`
	// - `ASK_EMAIL_VERIFY`: API call `verify_email`
	// - `ASK_FIX_DETAILS`: API call `set_settings`
	Cashier interface{} `json:"cashier,omitempty"`

	// Echo of the request made.
	EchoReq CashierRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType CashierRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type CashierRespEchoReq map[string]interface{}

type CashierRespMsgType string

const CashierRespMsgTypeCashier CashierRespMsgType = "cashier"

type CashierType string

const CashierTypeApi CashierType = "api"
const CashierTypeUrl CashierType = "url"

// Update a contract condition.
type ContractUpdate struct {
	// Internal unique contract identifier.
	ContractId int `json:"contract_id"`

	// Must be `1`
	ContractUpdate ContractUpdateContractUpdate `json:"contract_update"`

	// Specify limit order to update.
	LimitOrder ContractUpdateLimitOrder `json:"limit_order"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough ContractUpdatePassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type ContractUpdateContractUpdate int

// Request for contract update history.
type ContractUpdateHistory struct {
	// Internal unique contract identifier.
	ContractId int `json:"contract_id"`

	// Must be `1`
	ContractUpdateHistory ContractUpdateHistoryContractUpdateHistory `json:"contract_update_history"`

	// [Optional] Maximum number of historical updates to receive.
	Limit float64 `json:"limit,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough ContractUpdateHistoryPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type ContractUpdateHistoryContractUpdateHistory int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type ContractUpdateHistoryPassthrough map[string]interface{}

// Contract update history status
type ContractUpdateHistoryResp struct {
	// Contains the historical and the most recent update status of the contract
	ContractUpdateHistory []ContractUpdateHistoryRespContractUpdateHistoryElem `json:"contract_update_history,omitempty"`

	// Echo of the request made.
	EchoReq ContractUpdateHistoryRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType ContractUpdateHistoryRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Contains the changed parameter.
type ContractUpdateHistoryRespContractUpdateHistoryElem struct {
	// Display name of the changed parameter.
	DisplayName *string `json:"display_name,omitempty"`

	// The amount.
	OrderAmount *string `json:"order_amount,omitempty"`

	// The epoch when the changed was done.
	OrderDate *int `json:"order_date,omitempty"`

	// The contract parameter updated.
	OrderType *string `json:"order_type,omitempty"`

	// The pip-sized barrier value.
	Value interface{} `json:"value,omitempty"`
}

// Echo of the request made.
type ContractUpdateHistoryRespEchoReq map[string]interface{}

type ContractUpdateHistoryRespMsgType string

const ContractUpdateHistoryRespMsgTypeContractUpdateHistory ContractUpdateHistoryRespMsgType = "contract_update_history"

// Specify limit order to update.
type ContractUpdateLimitOrder struct {
	// New stop loss value for a contract. To cancel, pass `null`.
	StopLoss interface{} `json:"stop_loss,omitempty"`

	// New take profit value for a contract. To cancel, pass `null`.
	TakeProfit interface{} `json:"take_profit,omitempty"`
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type ContractUpdatePassthrough map[string]interface{}

// Contract update status
type ContractUpdateResp struct {
	// Contains the update status of the request
	ContractUpdate *ContractUpdateRespContractUpdate `json:"contract_update,omitempty"`

	// Echo of the request made.
	EchoReq ContractUpdateRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType ContractUpdateRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Contains the update status of the request
type ContractUpdateRespContractUpdate struct {
	// The target spot price where the contract will be closed automatically at the
	// loss specified by the user.
	StopLoss *ContractUpdateRespContractUpdateStopLoss `json:"stop_loss,omitempty"`

	// The target spot price where the contract will be closed automatically at the
	// profit specified by the user.
	TakeProfit *ContractUpdateRespContractUpdateTakeProfit `json:"take_profit,omitempty"`
}

// The target spot price where the contract will be closed automatically at the
// loss specified by the user.
type ContractUpdateRespContractUpdateStopLoss struct {
	// Localized display name
	DisplayName *string `json:"display_name,omitempty"`

	// Stop loss amount
	OrderAmount interface{} `json:"order_amount,omitempty"`

	// Stop loss order epoch
	OrderDate *int `json:"order_date,omitempty"`

	// Stop loss pip-sized barrier value
	Value interface{} `json:"value,omitempty"`
}

// The target spot price where the contract will be closed automatically at the
// profit specified by the user.
type ContractUpdateRespContractUpdateTakeProfit struct {
	// Localized display name
	DisplayName *string `json:"display_name,omitempty"`

	// Take profit amount
	OrderAmount interface{} `json:"order_amount,omitempty"`

	// Take profit order epoch
	OrderDate *int `json:"order_date,omitempty"`

	// Take profit pip-sized barrier value
	Value interface{} `json:"value,omitempty"`
}

// Echo of the request made.
type ContractUpdateRespEchoReq map[string]interface{}

type ContractUpdateRespMsgType string

const ContractUpdateRespMsgTypeContractUpdate ContractUpdateRespMsgType = "contract_update"

// For a given symbol, get the list of currently available contracts, and the
// latest barrier and duration limits for each contract.
type ContractsFor struct {
	// The short symbol name (obtained from `active_symbols` call).
	ContractsFor string `json:"contracts_for"`

	// [Optional] Currency of the contract's stake and payout (obtained from
	// `payout_currencies` call).
	Currency string `json:"currency,omitempty"`

	// Deprecated - Replaced by landing_company_short.
	LandingCompany ContractsForLandingCompany `json:"landing_company,omitempty"`

	// [Optional] Indicates which landing company to get a list of contracts for. If
	// you are logged in, your account's landing company will override this field.
	// Note that when landing_company_short is set to 'virtual', landing_company will
	// take precendce until the deprecated field is removed from the api.
	LandingCompanyShort ContractsForLandingCompanyShort `json:"landing_company_short,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough ContractsForPassthrough `json:"passthrough,omitempty"`

	// [Optional] If you specify this field, only contracts tradable through that
	// contract type will be returned.
	ProductType *ContractsForProductType `json:"product_type,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type ContractsForLandingCompany string

const ContractsForLandingCompanyChampion ContractsForLandingCompany = "champion"
const ContractsForLandingCompanyChampionVirtual ContractsForLandingCompany = "champion-virtual"
const ContractsForLandingCompanyIom ContractsForLandingCompany = "iom"
const ContractsForLandingCompanyMalta ContractsForLandingCompany = "malta"
const ContractsForLandingCompanyMaltainvest ContractsForLandingCompany = "maltainvest"

type ContractsForLandingCompanyShort string

const ContractsForLandingCompanyShortChampion ContractsForLandingCompanyShort = "champion"
const ContractsForLandingCompanyShortChampionVirtual ContractsForLandingCompanyShort = "champion-virtual"
const ContractsForLandingCompanyShortIom ContractsForLandingCompanyShort = "iom"
const ContractsForLandingCompanyShortMalta ContractsForLandingCompanyShort = "malta"
const ContractsForLandingCompanyShortMaltainvest ContractsForLandingCompanyShort = "maltainvest"
const ContractsForLandingCompanyShortSvg ContractsForLandingCompanyShort = "svg"
const ContractsForLandingCompanyShortVanuatu ContractsForLandingCompanyShort = "vanuatu"
const ContractsForLandingCompanyShortVirtual ContractsForLandingCompanyShort = "virtual"
const ContractsForLandingCompanySvg ContractsForLandingCompany = "svg"
const ContractsForLandingCompanyVanuatu ContractsForLandingCompany = "vanuatu"
const ContractsForLandingCompanyVirtual ContractsForLandingCompany = "virtual"

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type ContractsForPassthrough map[string]interface{}

type ContractsForProductType string

const ContractsForProductTypeBasic ContractsForProductType = "basic"

// Get the list of currently available contracts
type ContractsForResp struct {
	// List of available contracts. Note: if the user is authenticated, then only
	// contracts allowed under his account will be returned.
	ContractsFor *ContractsForRespContractsFor `json:"contracts_for,omitempty"`

	// Echo of the request made.
	EchoReq ContractsForRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType ContractsForRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// List of available contracts. Note: if the user is authenticated, then only
// contracts allowed under his account will be returned.
type ContractsForRespContractsFor struct {
	// Array of available contracts details
	Available []ContractsForRespContractsForAvailableElem `json:"available"`

	// Symbol's next market-close time as an epoch value
	Close interface{} `json:"close,omitempty"`

	// Indicates the feed license for symbol, for example whether its realtime or
	// delayed
	FeedLicense *string `json:"feed_license,omitempty"`

	// Count of contracts available
	HitCount *float64 `json:"hit_count,omitempty"`

	// Array of non_available contracts details
	NonAvailable []interface{} `json:"non_available,omitempty"`

	// Symbol's next market-open time as an epoch value
	Open interface{} `json:"open,omitempty"`

	// Current spot price for this underlying
	Spot interface{} `json:"spot,omitempty"`
}

type ContractsForRespContractsForAvailableElem struct {
	// Array of available barriers for a predefined trading period
	AvailableBarriers []interface{} `json:"available_barriers,omitempty"`

	// Barrier Details.
	Barrier interface{} `json:"barrier,omitempty"`

	// Category of barrier.
	BarrierCategory string `json:"barrier_category"`

	// [Only for Vanilla] Barrier Choices
	BarrierChoices []interface{} `json:"barrier_choices,omitempty"`

	// Number of barriers.
	Barriers float64 `json:"barriers"`

	// Cancellation range
	CancellationRange []interface{} `json:"cancellation_range,omitempty"`

	// Category of contract.
	ContractCategory string `json:"contract_category"`

	// Category of the contract.
	ContractCategoryDisplay string `json:"contract_category_display"`

	// Display name for the type of contract.
	ContractDisplay *string `json:"contract_display,omitempty"`

	// Type of contract.
	ContractType string `json:"contract_type"`

	// Name of exchange
	ExchangeName string `json:"exchange_name"`

	// Array of barriers already expired
	ExpiredBarriers []interface{} `json:"expired_barriers,omitempty"`

	// Expiry Type.
	ExpiryType string `json:"expiry_type"`

	// Array of returned forward starting options
	ForwardStartingOptions []ContractsForRespContractsForAvailableElemForwardStartingOptionsElem `json:"forward_starting_options,omitempty"`

	// Growth rate range.
	GrowthRateRange []interface{} `json:"growth_rate_range,omitempty"`

	// High barrier Details.
	HighBarrier interface{} `json:"high_barrier,omitempty"`

	// Last digit range
	LastDigitRange []interface{} `json:"last_digit_range,omitempty"`

	// Low barrier Details.
	LowBarrier interface{} `json:"low_barrier,omitempty"`

	// Type of market.
	Market string `json:"market"`

	// Maximum contract duration
	MaxContractDuration string `json:"max_contract_duration"`

	// [Only for turbos options] Maximum contract stake
	MaxStake interface{} `json:"max_stake,omitempty"`

	// Minimum contract duration.
	MinContractDuration string `json:"min_contract_duration"`

	// [Only for turbos options] Minimum contract stake
	MinStake interface{} `json:"min_stake,omitempty"`

	// Multiplier range.
	MultiplierRange []interface{} `json:"multiplier_range,omitempty"`

	// Maximum payout.
	PayoutLimit *float64 `json:"payout_limit,omitempty"`

	// Type of sentiment.
	Sentiment string `json:"sentiment"`

	// Start Type.
	StartType string `json:"start_type"`

	// Type of submarket.
	Submarket string `json:"submarket"`

	// A hash of predefined trading period
	TradingPeriod ContractsForRespContractsForAvailableElemTradingPeriod `json:"trading_period,omitempty"`

	// Symbol code
	UnderlyingSymbol string `json:"underlying_symbol"`
}

type ContractsForRespContractsForAvailableElemForwardStartingOptionsElem struct {
	// The epoch value for the blackouts of forward starting session.
	Blackouts []interface{} `json:"blackouts,omitempty"`

	// The epoch value for the closing date of forward starting session.
	Close *string `json:"close,omitempty"`

	// The epoch value for the date of forward starting session.
	Date *string `json:"date,omitempty"`

	// The epoch value for the opening date of forward starting session.
	Open *string `json:"open,omitempty"`
}

// A hash of predefined trading period
type ContractsForRespContractsForAvailableElemTradingPeriod map[string]interface{}

// Echo of the request made.
type ContractsForRespEchoReq map[string]interface{}

type ContractsForRespMsgType string

const ContractsForRespMsgTypeContractsFor ContractsForRespMsgType = "contracts_for"

// Start copy trader bets
type CopyStart struct {
	// [Optional] Used to set assets to be copied. E.x ["frxUSDJPY", "R_50"]
	Assets interface{} `json:"assets,omitempty"`

	// API tokens identifying the accounts of trader which will be used to copy trades
	CopyStart string `json:"copy_start"`

	// [Optional] Used to set maximum trade stake to be copied.
	MaxTradeStake *float64 `json:"max_trade_stake,omitempty"`

	// [Optional] Used to set minimal trade stake to be copied.
	MinTradeStake *float64 `json:"min_trade_stake,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough CopyStartPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// [Optional] Used to set trade types to be copied. E.x ["CALL", "PUT"]
	TradeTypes interface{} `json:"trade_types,omitempty"`
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type CopyStartPassthrough map[string]interface{}

// A message with results is received
type CopyStartResp struct {
	// Copy start confirmation. Returns 1 is success.
	CopyStart *int `json:"copy_start,omitempty"`

	// Echo of the request made.
	EchoReq CopyStartRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType CopyStartRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type CopyStartRespEchoReq map[string]interface{}

type CopyStartRespMsgType string

const CopyStartRespMsgTypeCopyStart CopyStartRespMsgType = "copy_start"

// Stop copy trader bets
type CopyStop struct {
	// API tokens identifying the accounts which needs not to be copied
	CopyStop string `json:"copy_stop"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough CopyStopPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type CopyStopPassthrough map[string]interface{}

// A message with results is received
type CopyStopResp struct {
	// Copy stopping confirmation. Returns 1 is success.
	CopyStop *int `json:"copy_stop,omitempty"`

	// Echo of the request made.
	EchoReq CopyStopRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType CopyStopRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type CopyStopRespEchoReq map[string]interface{}

type CopyStopRespMsgType string

const CopyStopRespMsgTypeCopyStop CopyStopRespMsgType = "copy_stop"

// Retrieves a list of active copiers and/or traders for Copy Trading
type CopytradingList struct {
	// Must be `1`
	CopytradingList CopytradingListCopytradingList `json:"copytrading_list"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough CopytradingListPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type CopytradingListCopytradingList int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type CopytradingListPassthrough map[string]interface{}

// Details of copiers and/or traders for Copy Trading
type CopytradingListResp struct {
	// The trading information of copiers or traders.
	CopytradingList *CopytradingListRespCopytradingList `json:"copytrading_list,omitempty"`

	// Echo of the request made.
	EchoReq CopytradingListRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType CopytradingListRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// The trading information of copiers or traders.
type CopytradingListRespCopytradingList struct {
	// List of users who are currently copy trading the authenticated user
	Copiers []CopytradingListRespCopytradingListCopiersElem `json:"copiers"`

	// List of traders being followed by the authenticated user
	Traders []CopytradingListRespCopytradingListTradersElem `json:"traders"`
}

type CopytradingListRespCopytradingListCopiersElem struct {
	// The loginid of the copier's account.
	Loginid string `json:"loginid"`
}

type CopytradingListRespCopytradingListTradersElem struct {
	// The list of assets to copy the trades of.
	Assets []string `json:"assets,omitempty"`

	// The loginid of the trader's account.
	Loginid *string `json:"loginid,omitempty"`

	// Maximum trading stake set for the trader.
	MaxTradeStake interface{} `json:"max_trade_stake,omitempty"`

	// Minimum trading stake set for the trader.
	MinTradeStake interface{} `json:"min_trade_stake,omitempty"`

	// The token provided for the trader.
	Token *string `json:"token,omitempty"`

	// The type of trades set.
	TradeTypes []string `json:"trade_types,omitempty"`
}

// Echo of the request made.
type CopytradingListRespEchoReq map[string]interface{}

type CopytradingListRespMsgType string

const CopytradingListRespMsgTypeCopytradingList CopytradingListRespMsgType = "copytrading_list"

// Retrieve performance, trading, risk and copiers statistics of trader.
type CopytradingStatistics struct {
	// Must be `1`
	CopytradingStatistics CopytradingStatisticsCopytradingStatistics `json:"copytrading_statistics"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough CopytradingStatisticsPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// The ID of the target trader.
	TraderId string `json:"trader_id"`
}

type CopytradingStatisticsCopytradingStatistics int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type CopytradingStatisticsPassthrough map[string]interface{}

// The statistics of the trader.
type CopytradingStatisticsResp struct {
	// Statistics of the trader
	CopytradingStatistics *CopytradingStatisticsRespCopytradingStatistics `json:"copytrading_statistics,omitempty"`

	// Echo of the request made.
	EchoReq CopytradingStatisticsRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType CopytradingStatisticsRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Statistics of the trader
type CopytradingStatisticsRespCopytradingStatistics struct {
	// This is the epoch the investor started trading.
	ActiveSince int `json:"active_since"`

	// Average seconds of keeping positions open.
	AvgDuration int `json:"avg_duration"`

	// Average loss of trades in percentage.
	AvgLoss float64 `json:"avg_loss"`

	// Average profitable trades in percentage.
	AvgProfit float64 `json:"avg_profit"`

	// Number of copiers for this trader.
	Copiers float64 `json:"copiers"`

	// Represents the net change in equity for a 12-month period.
	Last12MonthsProfitableTrades float64 `json:"last_12months_profitable_trades"`

	// Represents the net change in equity per month.
	MonthlyProfitableTrades CopytradingStatisticsRespCopytradingStatisticsMonthlyProfitableTrades `json:"monthly_profitable_trades"`

	// Trader performance probability.
	PerformanceProbability float64 `json:"performance_probability"`

	// Total number of trades for all time.
	TotalTrades int `json:"total_trades"`

	// Represents the portfolio distribution by markets.
	TradesBreakdown CopytradingStatisticsRespCopytradingStatisticsTradesBreakdown `json:"trades_breakdown"`

	// Number of profit trades in percentage.
	TradesProfitable float64 `json:"trades_profitable"`

	// Represents the net change in equity per year.
	YearlyProfitableTrades CopytradingStatisticsRespCopytradingStatisticsYearlyProfitableTrades `json:"yearly_profitable_trades,omitempty"`
}

// Represents the net change in equity per month.
type CopytradingStatisticsRespCopytradingStatisticsMonthlyProfitableTrades map[string]interface{}

// Represents the portfolio distribution by markets.
type CopytradingStatisticsRespCopytradingStatisticsTradesBreakdown map[string]interface{}

// Represents the net change in equity per year.
type CopytradingStatisticsRespCopytradingStatisticsYearlyProfitableTrades map[string]interface{}

// Echo of the request made.
type CopytradingStatisticsRespEchoReq map[string]interface{}

type CopytradingStatisticsRespMsgType string

const CopytradingStatisticsRespMsgTypeCopytradingStatistics CopytradingStatisticsRespMsgType = "copytrading_statistics"

// The request for cryptocurrencies configuration.
type CryptoConfig struct {
	// Must be `1`
	CryptoConfig CryptoConfigCryptoConfig `json:"crypto_config"`

	// [Optional] Cryptocurrency code. Sending request with currency_code provides
	// crypto config for the sent cryptocurrency code only.
	CurrencyCode *string `json:"currency_code,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough CryptoConfigPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type CryptoConfigCryptoConfig int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type CryptoConfigPassthrough map[string]interface{}

// The response will display the configuration details related to cryptocurrencies
type CryptoConfigResp struct {
	// Provides cryptocurrencies configuration.
	CryptoConfig *CryptoConfigRespCryptoConfig `json:"crypto_config,omitempty"`

	// Echo of the request made.
	EchoReq CryptoConfigRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType CryptoConfigRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Provides cryptocurrencies configuration.
type CryptoConfigRespCryptoConfig struct {
	// Currency configuration including limitiations for each crypto currency.
	CurrenciesConfig CryptoConfigRespCryptoConfigCurrenciesConfig `json:"currencies_config"`
}

// Currency configuration including limitiations for each crypto currency.
type CryptoConfigRespCryptoConfigCurrenciesConfig map[string]interface{}

// Echo of the request made.
type CryptoConfigRespEchoReq map[string]interface{}

type CryptoConfigRespMsgType string

const CryptoConfigRespMsgTypeCryptoConfig CryptoConfigRespMsgType = "crypto_config"

// Request KYC information from client
type DocumentUpload struct {
	// Document file format
	DocumentFormat DocumentUploadDocumentFormat `json:"document_format"`

	// [Optional] Document ID (required for Passport, Proof of ID and Driver's
	// License)
	DocumentId *string `json:"document_id,omitempty"`

	// [Optional] 2-letter country code
	DocumentIssuingCountry *string `json:"document_issuing_country,omitempty"`

	// Document type
	DocumentType DocumentUploadDocumentType `json:"document_type"`

	// Must be `1`
	DocumentUpload DocumentUploadDocumentUpload `json:"document_upload"`

	// The checksum of the file to be uploaded
	ExpectedChecksum string `json:"expected_checksum"`

	// [Optional] Document expiration date (required for Passport, Proof of ID and
	// Driver's License)
	ExpirationDate *string `json:"expiration_date,omitempty"`

	// Document size (should be less than 10MB)
	FileSize int `json:"file_size"`

	// [Optional] Boolean value that indicates whether this document is lifetime valid
	// (only applies to POI document types, cancels out the expiration_date given if
	// any)
	LifetimeValid *DocumentUploadLifetimeValid `json:"lifetime_valid,omitempty"`

	// [Optional] To determine document side
	PageType *DocumentUploadPageType `json:"page_type,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough DocumentUploadPassthrough `json:"passthrough,omitempty"`

	// [Optional] It contains info about the proof of ownership being uploaded
	// (mandatory for proof_of_ownership document type)
	ProofOfOwnership *DocumentUploadProofOfOwnership `json:"proof_of_ownership,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type DocumentUploadDocumentFormat string

const DocumentUploadDocumentFormatGIF DocumentUploadDocumentFormat = "GIF"
const DocumentUploadDocumentFormatJPEG DocumentUploadDocumentFormat = "JPEG"
const DocumentUploadDocumentFormatJPG DocumentUploadDocumentFormat = "JPG"
const DocumentUploadDocumentFormatPDF DocumentUploadDocumentFormat = "PDF"
const DocumentUploadDocumentFormatPNG DocumentUploadDocumentFormat = "PNG"

type DocumentUploadDocumentType string

const DocumentUploadDocumentTypeAmlglobalcheck DocumentUploadDocumentType = "amlglobalcheck"
const DocumentUploadDocumentTypeArticleOfAssociation DocumentUploadDocumentType = "article_of_association"
const DocumentUploadDocumentTypeAuthorisationLetter DocumentUploadDocumentType = "authorisation_letter"
const DocumentUploadDocumentTypeBankstatement DocumentUploadDocumentType = "bankstatement"
const DocumentUploadDocumentTypeBirthCertificate DocumentUploadDocumentType = "birth_certificate"
const DocumentUploadDocumentTypeBrokerageStatement DocumentUploadDocumentType = "brokerage statement"
const DocumentUploadDocumentTypeBusinessDocumentsOthers DocumentUploadDocumentType = "business_documents_others"
const DocumentUploadDocumentTypeBusinessPoa DocumentUploadDocumentType = "business_poa"
const DocumentUploadDocumentTypeCoi DocumentUploadDocumentType = "coi"
const DocumentUploadDocumentTypeDeclarations DocumentUploadDocumentType = "declarations"
const DocumentUploadDocumentTypeDocverification DocumentUploadDocumentType = "docverification"
const DocumentUploadDocumentTypeDriverslicense DocumentUploadDocumentType = "driverslicense"
const DocumentUploadDocumentTypeDrivingLicence DocumentUploadDocumentType = "driving_licence"
const DocumentUploadDocumentTypeEddOthers DocumentUploadDocumentType = "edd_others"
const DocumentUploadDocumentTypeEmploymentContract DocumentUploadDocumentType = "employment_contract"
const DocumentUploadDocumentTypeInsuranceBill DocumentUploadDocumentType = "insurance_bill"
const DocumentUploadDocumentTypeMemorandum DocumentUploadDocumentType = "memorandum"
const DocumentUploadDocumentTypeNationalIdentityCard DocumentUploadDocumentType = "national_identity_card"
const DocumentUploadDocumentTypeNimcSlip DocumentUploadDocumentType = "nimc_slip"
const DocumentUploadDocumentTypeOther DocumentUploadDocumentType = "other"
const DocumentUploadDocumentTypePanCard DocumentUploadDocumentType = "pan_card"
const DocumentUploadDocumentTypePassport DocumentUploadDocumentType = "passport"
const DocumentUploadDocumentTypePayslip DocumentUploadDocumentType = "payslip"
const DocumentUploadDocumentTypePhoneBill DocumentUploadDocumentType = "phone_bill"
const DocumentUploadDocumentTypePoaOthers DocumentUploadDocumentType = "poa_others"
const DocumentUploadDocumentTypePoiOthers DocumentUploadDocumentType = "poi_others"
const DocumentUploadDocumentTypePowerOfAttorney DocumentUploadDocumentType = "power_of_attorney"
const DocumentUploadDocumentTypeProofOfOwnership DocumentUploadDocumentType = "proof_of_ownership"
const DocumentUploadDocumentTypeProofaddress DocumentUploadDocumentType = "proofaddress"
const DocumentUploadDocumentTypeProofid DocumentUploadDocumentType = "proofid"
const DocumentUploadDocumentTypeSelfieWithId DocumentUploadDocumentType = "selfie_with_id"
const DocumentUploadDocumentTypeStudentCard DocumentUploadDocumentType = "student_card"
const DocumentUploadDocumentTypeTaxPhotoId DocumentUploadDocumentType = "tax_photo_id"
const DocumentUploadDocumentTypeTaxReceipt DocumentUploadDocumentType = "tax_receipt"
const DocumentUploadDocumentTypeTaxReturn DocumentUploadDocumentType = "tax_return"
const DocumentUploadDocumentTypeUtilityBill DocumentUploadDocumentType = "utility_bill"
const DocumentUploadDocumentTypeVoterCard DocumentUploadDocumentType = "voter_card"

type DocumentUploadDocumentUpload int

type DocumentUploadLifetimeValid int

type DocumentUploadPageType string

const DocumentUploadPageTypeBack DocumentUploadPageType = "back"
const DocumentUploadPageTypeFront DocumentUploadPageType = "front"
const DocumentUploadPageTypePhoto DocumentUploadPageType = "photo"

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type DocumentUploadPassthrough map[string]interface{}

// [Optional] It contains info about the proof of ownership being uploaded
// (mandatory for proof_of_ownership document type)
type DocumentUploadProofOfOwnership struct {
	// A collection of unspecific information related to the proof of ownership being
	// uploaded
	Details DocumentUploadProofOfOwnershipDetails `json:"details"`

	// The id of the proof of ownership as shown in the /get_account_status proof of
	// ownership list
	Id float64 `json:"id"`
}

// A collection of unspecific information related to the proof of ownership being
// uploaded
type DocumentUploadProofOfOwnershipDetails map[string]interface{}

// Receive details of uploaded authentication documents
type DocumentUploadResp struct {
	// Details of the uploaded documents.
	DocumentUpload *DocumentUploadRespDocumentUpload `json:"document_upload,omitempty"`

	// Echo of the request made.
	EchoReq DocumentUploadRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType DocumentUploadRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Details of the uploaded documents.
type DocumentUploadRespDocumentUpload struct {
	// Current call type, add this to your binary payload metadata
	CallType float64 `json:"call_type"`

	// Hex encoded SHA-1 checksum of the file
	Checksum *string `json:"checksum,omitempty"`

	// 2-letter country code
	DocumentIssuingCountry *string `json:"document_issuing_country,omitempty"`

	// File size
	Size *float64 `json:"size,omitempty"`

	// Upload status (`success` or `failure`)
	Status *string `json:"status,omitempty"`

	// Current upload ID, add this to your binary payload metadata
	UploadId float64 `json:"upload_id"`
}

// Echo of the request made.
type DocumentUploadRespEchoReq map[string]interface{}

type DocumentUploadRespMsgType string

const DocumentUploadRespMsgTypeDocumentUpload DocumentUploadRespMsgType = "document_upload"

// Specify a currency to receive a list of events related to that specific
// currency. For example, specifying USD will return a list of USD-related events.
// If the currency is omitted, you will receive a list for all currencies.
type EconomicCalendar struct {
	// [Optional] Currency symbol.
	Currency *string `json:"currency,omitempty"`

	// Must be `1`
	EconomicCalendar EconomicCalendarEconomicCalendar `json:"economic_calendar"`

	// [Optional] End date.
	EndDate *int `json:"end_date,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough EconomicCalendarPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// [Optional] Start date.
	StartDate *int `json:"start_date,omitempty"`
}

type EconomicCalendarEconomicCalendar int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type EconomicCalendarPassthrough map[string]interface{}

// A list of economic events.
type EconomicCalendarResp struct {
	// Echo of the request made.
	EchoReq EconomicCalendarRespEchoReq `json:"echo_req"`

	// Economic calendar.
	EconomicCalendar *EconomicCalendarRespEconomicCalendar `json:"economic_calendar,omitempty"`

	// Action name of the request made.
	MsgType EconomicCalendarRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type EconomicCalendarRespEchoReq map[string]interface{}

// Economic calendar.
type EconomicCalendarRespEconomicCalendar struct {
	// Array of economic events
	Events []EconomicCalendarRespEconomicCalendarEventsElem `json:"events,omitempty"`
}

type EconomicCalendarRespEconomicCalendarEventsElem struct {
	// Actual value.
	Actual *EconomicCalendarRespEconomicCalendarEventsElemActual `json:"actual,omitempty"`

	// Currency symbol.
	Currency *string `json:"currency,omitempty"`

	// Event name.
	EventName *string `json:"event_name,omitempty"`

	// Forecasted value.
	Forecast *EconomicCalendarRespEconomicCalendarEventsElemForecast `json:"forecast,omitempty"`

	// Impact.
	Impact *int `json:"impact,omitempty"`

	// Previous value.
	Previous *EconomicCalendarRespEconomicCalendarEventsElemPrevious `json:"previous,omitempty"`

	// Release date.
	ReleaseDate *int `json:"release_date,omitempty"`
}

// Actual value.
type EconomicCalendarRespEconomicCalendarEventsElemActual struct {
	// Actual value.
	DisplayValue *string `json:"display_value,omitempty"`
}

// Forecasted value.
type EconomicCalendarRespEconomicCalendarEventsElemForecast struct {
	// Forecasted value.
	DisplayValue *string `json:"display_value,omitempty"`
}

// Previous value.
type EconomicCalendarRespEconomicCalendarEventsElemPrevious struct {
	// Previous value.
	DisplayValue *string `json:"display_value,omitempty"`
}

type EconomicCalendarRespMsgType string

const EconomicCalendarRespMsgTypeEconomicCalendar EconomicCalendarRespMsgType = "economic_calendar"

// Retrieves the exchange rates from a base currency to all currencies supported by
// the system.
type ExchangeRates struct {
	// Base currency (can be obtained from `payout_currencies` call)
	BaseCurrency string `json:"base_currency"`

	// Must be `1`
	ExchangeRates ExchangeRatesExchangeRates `json:"exchange_rates"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough ExchangeRatesPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// [Optional] 1 - to initiate a realtime stream of exchange rates relative to base
	// currency.
	Subscribe *ExchangeRatesSubscribe `json:"subscribe,omitempty"`

	// [Optional] Local currency
	TargetCurrency *string `json:"target_currency,omitempty"`
}

type ExchangeRatesExchangeRates int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type ExchangeRatesPassthrough map[string]interface{}

// The exchange rate values from the specified base currency to all currencies
// supported by the system.
type ExchangeRatesResp struct {
	// Echo of the request made.
	EchoReq ExchangeRatesRespEchoReq `json:"echo_req"`

	// Exchange rate values from base to all other currencies
	ExchangeRates *ExchangeRatesRespExchangeRates `json:"exchange_rates,omitempty"`

	// Action name of the request made.
	MsgType ExchangeRatesRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// For subscription requests only.
	Subscription *ExchangeRatesRespSubscription `json:"subscription,omitempty"`
}

// Echo of the request made.
type ExchangeRatesRespEchoReq map[string]interface{}

// Exchange rate values from base to all other currencies
type ExchangeRatesRespExchangeRates struct {
	// Base currency
	BaseCurrency *string `json:"base_currency,omitempty"`

	// Date retrieval epoch time represented as an integer number
	Date *int `json:"date,omitempty"`

	// Rates of exchanging a unit of base currency into the target currencies
	Rates ExchangeRatesRespExchangeRatesRates `json:"rates,omitempty"`
}

// Rates of exchanging a unit of base currency into the target currencies
type ExchangeRatesRespExchangeRatesRates map[string]interface{}

type ExchangeRatesRespMsgType string

const ExchangeRatesRespMsgTypeExchangeRates ExchangeRatesRespMsgType = "exchange_rates"

// For subscription requests only.
type ExchangeRatesRespSubscription struct {
	// A per-connection unique identifier. Can be passed to the `forget` API call to
	// unsubscribe.
	Id string `json:"id"`
}

type ExchangeRatesSubscribe int

// Immediately cancel the real-time stream of messages with a specific ID.
type Forget struct {
	// ID of the real-time stream of messages to cancel.
	Forget string `json:"forget"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough ForgetPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

// Immediately cancel the real-time streams of messages of given type.
type ForgetAll struct {
	// Cancel all streams by type. The value can be either a single type e.g.
	// `"ticks"`, or an array of multiple types e.g. `["candles", "ticks"]`.
	ForgetAll interface{} `json:"forget_all"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough ForgetAllPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type ForgetAllPassthrough map[string]interface{}

// The result of forget all request made.
type ForgetAllResp struct {
	// Echo of the request made.
	EchoReq ForgetAllRespEchoReq `json:"echo_req"`

	// IDs of the cancelled streams
	ForgetAll []interface{} `json:"forget_all,omitempty"`

	// Action name of the request made.
	MsgType ForgetAllRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type ForgetAllRespEchoReq map[string]interface{}

type ForgetAllRespMsgType string

const ForgetAllRespMsgTypeForgetAll ForgetAllRespMsgType = "forget_all"

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type ForgetPassthrough map[string]interface{}

// The result of forget request made.
type ForgetResp struct {
	// Echo of the request made.
	EchoReq ForgetRespEchoReq `json:"echo_req"`

	// If set to 1, stream exited and stopped. If set to 0, stream did not exist.
	Forget *ForgetRespForget `json:"forget,omitempty"`

	// Action name of the request made.
	MsgType ForgetRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type ForgetRespEchoReq map[string]interface{}

type ForgetRespForget int

type ForgetRespMsgType string

const ForgetRespMsgTypeForget ForgetRespMsgType = "forget"

// Get Account Status
type GetAccountStatus struct {
	// Must be `1`
	GetAccountStatus GetAccountStatusGetAccountStatus `json:"get_account_status"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough GetAccountStatusPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type GetAccountStatusGetAccountStatus int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type GetAccountStatusPassthrough map[string]interface{}

// A message with Account Status
type GetAccountStatusResp struct {
	// Echo of the request made.
	EchoReq GetAccountStatusRespEchoReq `json:"echo_req"`

	// Account status details
	GetAccountStatus *GetAccountStatusRespGetAccountStatus `json:"get_account_status,omitempty"`

	// Action name of the request made.
	MsgType GetAccountStatusRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type GetAccountStatusRespEchoReq map[string]interface{}

// Account status details
type GetAccountStatusRespGetAccountStatus struct {
	// This represents the authentication status of the user and it includes what
	// authentication is needed.
	Authentication *GetAccountStatusRespGetAccountStatusAuthentication `json:"authentication,omitempty"`

	// Contains missing profile fields required for cashier access.
	CashierMissingFields []string `json:"cashier_missing_fields,omitempty"`

	// If the cashier is unavailble, this array contains one or more error codes for
	// each reason.
	CashierValidation []string `json:"cashier_validation,omitempty"`

	// Provides cashier details for client currency.
	CurrencyConfig GetAccountStatusRespGetAccountStatusCurrencyConfig `json:"currency_config"`

	// Current P2P status of client.
	P2PStatus GetAccountStatusRespGetAccountStatusP2PStatus `json:"p2p_status"`

	// Indicates whether the client should be prompted to authenticate their account.
	PromptClientToAuthenticate GetAccountStatusRespGetAccountStatusPromptClientToAuthenticate `json:"prompt_client_to_authenticate"`

	// Client risk classification: `low`, `standard`, `high`.
	RiskClassification string `json:"risk_classification"`

	// Social identity provider a user signed up with.
	SocialIdentityProvider *GetAccountStatusRespGetAccountStatusSocialIdentityProvider `json:"social_identity_provider,omitempty"`

	// Account status. Possible status:
	// - `address_verified`: client's address is verified by third party services.
	// - `allow_document_upload`: client is allowed to upload documents.
	// - `age_verification`: client is age-verified.
	// - `authenticated`: client is fully authenticated.
	// - `cashier_locked`: cashier is locked.
	// - `crs_tin_information`: client has updated tax related information.
	// - `deposit_locked`: deposit is not allowed.
	// - `disabled`: account is disabled.
	// - `document_expired`: client's submitted proof-of-identity documents have
	// expired.
	// - `document_expiring_soon`: client's submitted proof-of-identity documents are
	// expiring within a month.
	// - `dxtrade_password_not_set`: Deriv X password is not set.
	// - `financial_assessment_not_complete`: client should complete their financial
	// assessment.
	// - `financial_information_not_complete`: client has not completed financial
	// assessment.
	// - `financial_risk_approval`: client has accepted financial risk disclosure.
	// - `max_turnover_limit_not_set`: client has not set financial limits on their
	// account. Applies to UK and Malta clients.
	// - `mt5_password_not_set`: MT5 password is not set.
	// - `mt5_withdrawal_locked`: MT5 deposits allowed, but withdrawal is not allowed.
	// - `needs_affiliate_coc_approval`: user must approve the Affiliate's Code of
	// Conduct Agreement.
	// - `no_trading`: trading is disabled.
	// - `no_withdrawal_or_trading`: client cannot trade or withdraw but can deposit.
	// - `p2p_blocked_for_pa`: p2p is blocked for the current payment agent client.
	// - `pa_withdrawal_explicitly_allowed`: withdrawal through payment agent is
	// allowed.
	// - `password_reset_required`: this client must reset their password.
	// - `professional`: this client has opted for a professional account.
	// - `professional_requested`: this client has requested for a professional
	// account.
	// - `professional_rejected`: this client's request for a professional account has
	// been rejected.
	// - `social_signup`: this client is using social signup.
	// - `trading_experience_not_complete`: client has not completed the trading
	// experience questionnaire.
	// - `ukgc_funds_protection`: client has acknowledged UKGC funds protection
	// notice.
	// - `unwelcome`: client cannot deposit or buy contracts, but can withdraw or sell
	// contracts.
	// - `withdrawal_locked`: deposits allowed but withdrawals are not allowed.
	// - `deposit_attempt`: this prevent a client from changing the account currency
	// after deposit attempt.
	// - `poi_name_mismatch`: client POI documents name mismatch.
	// - `allow_poa_resubmission`: the client can resubmit POA documents.
	// - `allow_poi_resubmission`: the client can resubmit POI documents.
	// - `shared_payment_method`: the client has been sharing payment methods.
	// - `personal_details_locked`: client is not allowed to edit personal profile
	// details.
	// - `transfers_blocked`: it block any transfer between two accounts.
	// - `df_deposit_requires_poi`: the DF deposit will be blocked until the client
	// gets age verified.
	Status []string `json:"status"`
}

// This represents the authentication status of the user and it includes what
// authentication is needed.
type GetAccountStatusRespGetAccountStatusAuthentication struct {
	// POI attempts made by the client
	Attempts *GetAccountStatusRespGetAccountStatusAuthenticationAttempts `json:"attempts,omitempty"`

	// The authentication status for document.
	Document *GetAccountStatusRespGetAccountStatusAuthenticationDocument `json:"document,omitempty"`

	// The authentication status for identity.
	Identity *GetAccountStatusRespGetAccountStatusAuthenticationIdentity `json:"identity,omitempty"`

	// The authentication status for source of income document.
	Income *GetAccountStatusRespGetAccountStatusAuthenticationIncome `json:"income,omitempty"`

	// An array containing the list of required authentication.
	NeedsVerification []string `json:"needs_verification"`

	// The current state of the proof of ownership.
	Ownership *GetAccountStatusRespGetAccountStatusAuthenticationOwnership `json:"ownership,omitempty"`
}

// POI attempts made by the client
type GetAccountStatusRespGetAccountStatusAuthenticationAttempts struct {
	// A number of POI attempts made by the client
	Count *int `json:"count,omitempty"`

	// A list of POI attempts made by the client in chronological descending order
	History []GetAccountStatusRespGetAccountStatusAuthenticationAttemptsHistoryElem `json:"history,omitempty"`

	// The latest POI attempt made by the client
	Latest interface{} `json:"latest,omitempty"`
}

type GetAccountStatusRespGetAccountStatusAuthenticationAttemptsHistoryElem struct {
	// 2-letter country code used to request the attempt.
	CountryCode *string `json:"country_code,omitempty"`

	// The document type of the attempt.
	DocumentType *string `json:"document_type,omitempty"`

	// The id of the attempt.
	Id *string `json:"id,omitempty"`

	// The service used to make the verification.
	Service *string `json:"service,omitempty"`

	// Status of the attempt.
	Status *GetAccountStatusRespGetAccountStatusAuthenticationAttemptsHistoryElemStatus `json:"status,omitempty"`

	// The epoch of the attempt.
	Timestamp *int `json:"timestamp,omitempty"`
}

type GetAccountStatusRespGetAccountStatusAuthenticationAttemptsHistoryElemStatus string

const GetAccountStatusRespGetAccountStatusAuthenticationAttemptsHistoryElemStatusExpired GetAccountStatusRespGetAccountStatusAuthenticationAttemptsHistoryElemStatus = "expired"
const GetAccountStatusRespGetAccountStatusAuthenticationAttemptsHistoryElemStatusNone GetAccountStatusRespGetAccountStatusAuthenticationAttemptsHistoryElemStatus = "none"
const GetAccountStatusRespGetAccountStatusAuthenticationAttemptsHistoryElemStatusPending GetAccountStatusRespGetAccountStatusAuthenticationAttemptsHistoryElemStatus = "pending"
const GetAccountStatusRespGetAccountStatusAuthenticationAttemptsHistoryElemStatusRejected GetAccountStatusRespGetAccountStatusAuthenticationAttemptsHistoryElemStatus = "rejected"
const GetAccountStatusRespGetAccountStatusAuthenticationAttemptsHistoryElemStatusVerified GetAccountStatusRespGetAccountStatusAuthenticationAttemptsHistoryElemStatus = "verified"

// The authentication status for document.
type GetAccountStatusRespGetAccountStatusAuthenticationDocument struct {
	// This is the epoch of the document expiry date.
	ExpiryDate *int `json:"expiry_date,omitempty"`

	// This represents the current status of the proof of address document submitted
	// for authentication.
	Status *GetAccountStatusRespGetAccountStatusAuthenticationDocumentStatus `json:"status,omitempty"`
}

type GetAccountStatusRespGetAccountStatusAuthenticationDocumentStatus string

const GetAccountStatusRespGetAccountStatusAuthenticationDocumentStatusExpired GetAccountStatusRespGetAccountStatusAuthenticationDocumentStatus = "expired"
const GetAccountStatusRespGetAccountStatusAuthenticationDocumentStatusNone GetAccountStatusRespGetAccountStatusAuthenticationDocumentStatus = "none"
const GetAccountStatusRespGetAccountStatusAuthenticationDocumentStatusPending GetAccountStatusRespGetAccountStatusAuthenticationDocumentStatus = "pending"
const GetAccountStatusRespGetAccountStatusAuthenticationDocumentStatusRejected GetAccountStatusRespGetAccountStatusAuthenticationDocumentStatus = "rejected"
const GetAccountStatusRespGetAccountStatusAuthenticationDocumentStatusSuspected GetAccountStatusRespGetAccountStatusAuthenticationDocumentStatus = "suspected"
const GetAccountStatusRespGetAccountStatusAuthenticationDocumentStatusVerified GetAccountStatusRespGetAccountStatusAuthenticationDocumentStatus = "verified"

// The authentication status for identity.
type GetAccountStatusRespGetAccountStatusAuthenticationIdentity struct {
	// This is the epoch of the document expiry date.
	ExpiryDate *int `json:"expiry_date,omitempty"`

	// This shows the information about the authentication services implemented
	Services *GetAccountStatusRespGetAccountStatusAuthenticationIdentityServices `json:"services,omitempty"`

	// This represent the current status for proof of identity document submitted for
	// authentication.
	Status *GetAccountStatusRespGetAccountStatusAuthenticationIdentityStatus `json:"status,omitempty"`
}

// This shows the information about the authentication services implemented
type GetAccountStatusRespGetAccountStatusAuthenticationIdentityServices struct {
	// This shows the information related to IDV supported services
	Idv *GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesIdv `json:"idv,omitempty"`

	// This shows the information related to the manual POI checks
	Manual *GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesManual `json:"manual,omitempty"`

	// This shows the information related to Onfido supported services
	Onfido *GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesOnfido `json:"onfido,omitempty"`
}

// This shows the information related to IDV supported services
type GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesIdv struct {
	// This is the epoch of the document expiry date.
	ExpiryDate *int `json:"expiry_date,omitempty"`

	// Show the last IDV reported reasons for the rejected cases
	LastRejected []string `json:"last_rejected,omitempty"`

	// Shows the latest document properties detected and reported by IDVS
	ReportedProperties GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesIdvReportedProperties `json:"reported_properties,omitempty"`

	// This represents the status of the latest IDV check.
	Status *GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesIdvStatus `json:"status,omitempty"`

	// This shows the number of IDV submissions left for the client
	SubmissionsLeft *int `json:"submissions_left,omitempty"`
}

// Shows the latest document properties detected and reported by IDVS
type GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesIdvReportedProperties map[string]interface{}

type GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesIdvStatus string

const GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesIdvStatusExpired GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesIdvStatus = "expired"
const GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesIdvStatusNone GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesIdvStatus = "none"
const GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesIdvStatusPending GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesIdvStatus = "pending"
const GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesIdvStatusRejected GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesIdvStatus = "rejected"
const GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesIdvStatusVerified GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesIdvStatus = "verified"

// This shows the information related to the manual POI checks
type GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesManual struct {
	// This represents the status of the current manual POI check.
	Status *GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesManualStatus `json:"status,omitempty"`
}

type GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesManualStatus string

const GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesManualStatusExpired GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesManualStatus = "expired"
const GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesManualStatusNone GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesManualStatus = "none"
const GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesManualStatusPending GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesManualStatus = "pending"
const GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesManualStatusRejected GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesManualStatus = "rejected"
const GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesManualStatusSuspected GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesManualStatus = "suspected"
const GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesManualStatusVerified GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesManualStatus = "verified"

// This shows the information related to Onfido supported services
type GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesOnfido struct {
	// 3 letter country code for Onfide SDK
	CountryCode *string `json:"country_code,omitempty"`

	// This shows the list of documents types supported by Onfido
	Documents []string `json:"documents,omitempty"`

	// This shows the list of documents types supported.
	DocumentsSupported []string `json:"documents_supported,omitempty"`

	// This shows the information if the country is supported by Onfido
	IsCountrySupported *GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesOnfidoIsCountrySupported `json:"is_country_supported,omitempty"`

	// Show the last Onfido reported reasons for the rejected cases
	LastRejected []string `json:"last_rejected,omitempty"`

	// Shows the latest document properties detected and reported by Onfido
	ReportedProperties GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesOnfidoReportedProperties `json:"reported_properties,omitempty"`

	// This represents the status of the latest Onfido check.
	Status *GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesOnfidoStatus `json:"status,omitempty"`

	// This shows the number of Onfido submissions left for the client
	SubmissionsLeft *int `json:"submissions_left,omitempty"`
}

type GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesOnfidoIsCountrySupported int

// Shows the latest document properties detected and reported by Onfido
type GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesOnfidoReportedProperties map[string]interface{}

type GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesOnfidoStatus string

const GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesOnfidoStatusExpired GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesOnfidoStatus = "expired"
const GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesOnfidoStatusNone GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesOnfidoStatus = "none"
const GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesOnfidoStatusPending GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesOnfidoStatus = "pending"
const GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesOnfidoStatusRejected GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesOnfidoStatus = "rejected"
const GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesOnfidoStatusSuspected GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesOnfidoStatus = "suspected"
const GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesOnfidoStatusVerified GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesOnfidoStatus = "verified"

type GetAccountStatusRespGetAccountStatusAuthenticationIdentityStatus string

const GetAccountStatusRespGetAccountStatusAuthenticationIdentityStatusExpired GetAccountStatusRespGetAccountStatusAuthenticationIdentityStatus = "expired"
const GetAccountStatusRespGetAccountStatusAuthenticationIdentityStatusNone GetAccountStatusRespGetAccountStatusAuthenticationIdentityStatus = "none"
const GetAccountStatusRespGetAccountStatusAuthenticationIdentityStatusPending GetAccountStatusRespGetAccountStatusAuthenticationIdentityStatus = "pending"
const GetAccountStatusRespGetAccountStatusAuthenticationIdentityStatusRejected GetAccountStatusRespGetAccountStatusAuthenticationIdentityStatus = "rejected"
const GetAccountStatusRespGetAccountStatusAuthenticationIdentityStatusSuspected GetAccountStatusRespGetAccountStatusAuthenticationIdentityStatus = "suspected"
const GetAccountStatusRespGetAccountStatusAuthenticationIdentityStatusVerified GetAccountStatusRespGetAccountStatusAuthenticationIdentityStatus = "verified"

// The authentication status for source of income document.
type GetAccountStatusRespGetAccountStatusAuthenticationIncome struct {
	// Epoch of the source of income document expiry date.
	ExpiryDate *int `json:"expiry_date,omitempty"`

	// Current status of the proof of income document submitted for authentication.
	Status *GetAccountStatusRespGetAccountStatusAuthenticationIncomeStatus `json:"status,omitempty"`
}

type GetAccountStatusRespGetAccountStatusAuthenticationIncomeStatus string

const GetAccountStatusRespGetAccountStatusAuthenticationIncomeStatusLocked GetAccountStatusRespGetAccountStatusAuthenticationIncomeStatus = "locked"
const GetAccountStatusRespGetAccountStatusAuthenticationIncomeStatusNone GetAccountStatusRespGetAccountStatusAuthenticationIncomeStatus = "none"
const GetAccountStatusRespGetAccountStatusAuthenticationIncomeStatusPending GetAccountStatusRespGetAccountStatusAuthenticationIncomeStatus = "pending"
const GetAccountStatusRespGetAccountStatusAuthenticationIncomeStatusRejected GetAccountStatusRespGetAccountStatusAuthenticationIncomeStatus = "rejected"
const GetAccountStatusRespGetAccountStatusAuthenticationIncomeStatusVerified GetAccountStatusRespGetAccountStatusAuthenticationIncomeStatus = "verified"

// The current state of the proof of ownership.
type GetAccountStatusRespGetAccountStatusAuthenticationOwnership struct {
	// The list of proof of ownership requests to fullfil
	Requests []GetAccountStatusRespGetAccountStatusAuthenticationOwnershipRequestsElem `json:"requests,omitempty"`

	// This represents the current status of the proof of ownership
	Status *GetAccountStatusRespGetAccountStatusAuthenticationOwnershipStatus `json:"status,omitempty"`
}

type GetAccountStatusRespGetAccountStatusAuthenticationOwnershipRequestsElem struct {
	// The request timestamp of creation
	CreationTime *string `json:"creation_time,omitempty"`

	// Number of documents required to be uploaded for proof of ownership
	DocumentsRequired *float64 `json:"documents_required,omitempty"`

	// The identifier of the proof of ownership request
	Id *float64 `json:"id,omitempty"`

	// The display name of the payment method being requested
	PaymentMethod *string `json:"payment_method,omitempty"`
}

type GetAccountStatusRespGetAccountStatusAuthenticationOwnershipStatus string

const GetAccountStatusRespGetAccountStatusAuthenticationOwnershipStatusNone GetAccountStatusRespGetAccountStatusAuthenticationOwnershipStatus = "none"
const GetAccountStatusRespGetAccountStatusAuthenticationOwnershipStatusPending GetAccountStatusRespGetAccountStatusAuthenticationOwnershipStatus = "pending"
const GetAccountStatusRespGetAccountStatusAuthenticationOwnershipStatusRejected GetAccountStatusRespGetAccountStatusAuthenticationOwnershipStatus = "rejected"
const GetAccountStatusRespGetAccountStatusAuthenticationOwnershipStatusVerified GetAccountStatusRespGetAccountStatusAuthenticationOwnershipStatus = "verified"

// Provides cashier details for client currency.
type GetAccountStatusRespGetAccountStatusCurrencyConfig map[string]interface{}

type GetAccountStatusRespGetAccountStatusP2PStatus string

const GetAccountStatusRespGetAccountStatusP2PStatusActive GetAccountStatusRespGetAccountStatusP2PStatus = "active"
const GetAccountStatusRespGetAccountStatusP2PStatusNone GetAccountStatusRespGetAccountStatusP2PStatus = "none"
const GetAccountStatusRespGetAccountStatusP2PStatusPermBan GetAccountStatusRespGetAccountStatusP2PStatus = "perm_ban"
const GetAccountStatusRespGetAccountStatusP2PStatusTempBan GetAccountStatusRespGetAccountStatusP2PStatus = "temp_ban"

type GetAccountStatusRespGetAccountStatusPromptClientToAuthenticate int

type GetAccountStatusRespGetAccountStatusSocialIdentityProvider string

const GetAccountStatusRespGetAccountStatusSocialIdentityProviderApple GetAccountStatusRespGetAccountStatusSocialIdentityProvider = "apple"
const GetAccountStatusRespGetAccountStatusSocialIdentityProviderFacebook GetAccountStatusRespGetAccountStatusSocialIdentityProvider = "facebook"
const GetAccountStatusRespGetAccountStatusSocialIdentityProviderGoogle GetAccountStatusRespGetAccountStatusSocialIdentityProvider = "google"

type GetAccountStatusRespMsgType string

const GetAccountStatusRespMsgTypeGetAccountStatus GetAccountStatusRespMsgType = "get_account_status"

// This call gets the financial assessment details. The 'financial assessment' is a
// questionnaire that clients of certain Landing Companies need to complete, due to
// regulatory and KYC (know your client) requirements.
type GetFinancialAssessment struct {
	// Must be `1`
	GetFinancialAssessment GetFinancialAssessmentGetFinancialAssessment `json:"get_financial_assessment"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough GetFinancialAssessmentPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type GetFinancialAssessmentGetFinancialAssessment int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type GetFinancialAssessmentPassthrough map[string]interface{}

// This call gets the financial assessment details of client's account.
type GetFinancialAssessmentResp struct {
	// Echo of the request made.
	EchoReq GetFinancialAssessmentRespEchoReq `json:"echo_req"`

	// Client's financial assessment details
	GetFinancialAssessment *GetFinancialAssessmentRespGetFinancialAssessment `json:"get_financial_assessment,omitempty"`

	// Action name of the request made.
	MsgType GetFinancialAssessmentRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type GetFinancialAssessmentRespEchoReq map[string]interface{}

// Client's financial assessment details
type GetFinancialAssessmentRespGetFinancialAssessment struct {
	// The anticipated account turnover
	AccountTurnover *string `json:"account_turnover,omitempty"`

	// Binary options trading experience
	BinaryOptionsTradingExperience *string `json:"binary_options_trading_experience,omitempty"`

	// Binary options trading frequency
	BinaryOptionsTradingFrequency *string `json:"binary_options_trading_frequency,omitempty"`

	// How much experience do you have in CFD trading?
	CfdExperience *string `json:"cfd_experience,omitempty"`

	// How many CFD trades have you placed in the past 12 months?
	CfdFrequency *string `json:"cfd_frequency,omitempty"`

	// CFD Score
	CfdScore *int `json:"cfd_score,omitempty"`

	// In your understanding, CFD trading allows you to:
	CfdTradingDefinition *string `json:"cfd_trading_definition,omitempty"`

	// CFDs trading experience
	CfdTradingExperience *string `json:"cfd_trading_experience,omitempty"`

	// CFDs trading frequency
	CfdTradingFrequency *string `json:"cfd_trading_frequency,omitempty"`

	// Commodities trading experience
	CommoditiesTradingExperience *string `json:"commodities_trading_experience,omitempty"`

	// Commodities trading frequency
	CommoditiesTradingFrequency *string `json:"commodities_trading_frequency,omitempty"`

	// Level of Education
	EducationLevel *string `json:"education_level,omitempty"`

	// Industry of Employment
	EmploymentIndustry *string `json:"employment_industry,omitempty"`

	// Employment Status
	EmploymentStatus *string `json:"employment_status,omitempty"`

	// Estimated Net Worth
	EstimatedWorth *string `json:"estimated_worth,omitempty"`

	// Financial Information Score
	FinancialInformationScore *int `json:"financial_information_score,omitempty"`

	// Forex trading experience
	ForexTradingExperience *string `json:"forex_trading_experience,omitempty"`

	// Forex trading frequency
	ForexTradingFrequency *string `json:"forex_trading_frequency,omitempty"`

	// Income Source
	IncomeSource *string `json:"income_source,omitempty"`

	// Indices trading experience
	IndicesTradingExperience *string `json:"indices_trading_experience,omitempty"`

	// Indices trading frequency
	IndicesTradingFrequency *string `json:"indices_trading_frequency,omitempty"`

	// How does leverage affect CFD trading?
	LeverageImpactTrading *string `json:"leverage_impact_trading,omitempty"`

	// Leverage trading is high-risk, so it's a good idea to use risk management
	// features such as stop loss. Stop loss allows you to
	LeverageTradingHighRiskStopLoss *string `json:"leverage_trading_high_risk_stop_loss,omitempty"`

	// Net Annual Income
	NetIncome *string `json:"net_income,omitempty"`

	// Occupation
	Occupation *string `json:"occupation,omitempty"`

	// Trading experience in other financial derivatives
	OtherDerivativesTradingExperience *string `json:"other_derivatives_trading_experience,omitempty"`

	// Trading frequency in other financial derivatives
	OtherDerivativesTradingFrequency *string `json:"other_derivatives_trading_frequency,omitempty"`

	// Trading experience in other financial instruments
	OtherInstrumentsTradingExperience *string `json:"other_instruments_trading_experience,omitempty"`

	// Trading frequency in other financial instruments
	OtherInstrumentsTradingFrequency *string `json:"other_instruments_trading_frequency,omitempty"`

	// When would you be required to pay an initial margin?
	RequiredInitialMargin *string `json:"required_initial_margin,omitempty"`

	// Do you understand that you could potentially lose 100% of the money you use to
	// trade?
	RiskTolerance *string `json:"risk_tolerance,omitempty"`

	// How much knowledge and experience do you have in relation to online trading?
	SourceOfExperience *string `json:"source_of_experience,omitempty"`

	// Source of wealth
	SourceOfWealth *string `json:"source_of_wealth,omitempty"`

	// Stocks trading experience
	StocksTradingExperience *string `json:"stocks_trading_experience,omitempty"`

	// Stocks trading frequency
	StocksTradingFrequency *string `json:"stocks_trading_frequency,omitempty"`

	// Total Score
	TotalScore *int `json:"total_score,omitempty"`

	// How much experience do you have with other financial instruments?
	TradingExperienceFinancialInstruments *string `json:"trading_experience_financial_instruments,omitempty"`

	// How many trades have you placed with other financial instruments in the past 12
	// months?
	TradingFrequencyFinancialInstruments *string `json:"trading_frequency_financial_instruments,omitempty"`

	// Trading Experience Score
	TradingScore *int `json:"trading_score,omitempty"`
}

type GetFinancialAssessmentRespMsgType string

const GetFinancialAssessmentRespMsgTypeGetFinancialAssessment GetFinancialAssessmentRespMsgType = "get_financial_assessment"

// Trading and Withdrawal Limits for a given user
type GetLimits struct {
	// Must be `1`
	GetLimits GetLimitsGetLimits `json:"get_limits"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough GetLimitsPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type GetLimitsGetLimits int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type GetLimitsPassthrough map[string]interface{}

// Trading and Withdrawal Limits
type GetLimitsResp struct {
	// Echo of the request made.
	EchoReq GetLimitsRespEchoReq `json:"echo_req"`

	// Trading limits of real account user
	GetLimits *GetLimitsRespGetLimits `json:"get_limits,omitempty"`

	// Action name of the request made.
	MsgType GetLimitsRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type GetLimitsRespEchoReq map[string]interface{}

// Trading limits of real account user
type GetLimitsRespGetLimits struct {
	// Maximum account cash balance
	AccountBalance interface{} `json:"account_balance,omitempty"`

	// Cumulative daily transfer limits
	DailyCumulativeAmountTransfers GetLimitsRespGetLimitsDailyCumulativeAmountTransfers `json:"daily_cumulative_amount_transfers,omitempty"`

	// Daily transfers
	DailyTransfers GetLimitsRespGetLimitsDailyTransfers `json:"daily_transfers,omitempty"`

	// Maximum daily turnover
	DailyTurnover *float64 `json:"daily_turnover,omitempty"`

	// Lifetime withdrawal limit
	LifetimeLimit *float64 `json:"lifetime_limit,omitempty"`

	// Contains limitation information for each market.
	MarketSpecific GetLimitsRespGetLimitsMarketSpecific `json:"market_specific,omitempty"`

	// Number of days for num_of_days_limit withdrawal limit
	NumOfDays *int `json:"num_of_days,omitempty"`

	// Withdrawal limit for num_of_days days
	NumOfDaysLimit *float64 `json:"num_of_days_limit,omitempty"`

	// Maximum number of open positions
	OpenPositions *int `json:"open_positions,omitempty"`

	// Maximum aggregate payouts on open positions
	Payout *float64 `json:"payout,omitempty"`

	// Maximum payout for each symbol based on different barrier types.
	PayoutPerSymbol interface{} `json:"payout_per_symbol,omitempty"`

	// Maximum aggregate payouts on open positions per symbol and contract type. This
	// limit can be exceeded up to the overall payout limit if there is no prior open
	// position.
	PayoutPerSymbolAndContractType *float64 `json:"payout_per_symbol_and_contract_type,omitempty"`

	// Amount left to reach withdrawal limit
	Remainder *float64 `json:"remainder,omitempty"`

	// Total withdrawal for num_of_days days
	WithdrawalForXDaysMonetary *float64 `json:"withdrawal_for_x_days_monetary,omitempty"`

	// Total withdrawal since inception
	WithdrawalSinceInceptionMonetary *float64 `json:"withdrawal_since_inception_monetary,omitempty"`
}

// Cumulative daily transfer limits
type GetLimitsRespGetLimitsDailyCumulativeAmountTransfers map[string]interface{}

// Daily transfers
type GetLimitsRespGetLimitsDailyTransfers map[string]interface{}

// Contains limitation information for each market.
type GetLimitsRespGetLimitsMarketSpecific map[string]interface{}

type GetLimitsRespMsgType string

const GetLimitsRespMsgTypeGetLimits GetLimitsRespMsgType = "get_limits"

// Allows users to exclude themselves from the website for certain periods of time,
// or to set limits on their trading activities. This facility is a regulatory
// requirement for certain Landing Companies.
type GetSelfExclusion struct {
	// Must be `1`
	GetSelfExclusion GetSelfExclusionGetSelfExclusion `json:"get_self_exclusion"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough GetSelfExclusionPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type GetSelfExclusionGetSelfExclusion int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type GetSelfExclusionPassthrough map[string]interface{}

// A message with User Self-Exclusion
type GetSelfExclusionResp struct {
	// Echo of the request made.
	EchoReq GetSelfExclusionRespEchoReq `json:"echo_req"`

	// List of values set for self exclusion.
	GetSelfExclusion *GetSelfExclusionRespGetSelfExclusion `json:"get_self_exclusion,omitempty"`

	// Action name of the request made.
	MsgType GetSelfExclusionRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type GetSelfExclusionRespEchoReq map[string]interface{}

// List of values set for self exclusion.
type GetSelfExclusionRespGetSelfExclusion struct {
	// Exclude me from the website (for a minimum of 6 months, up to a maximum of 5
	// years). Note: uplifting this self-exclusion may require contacting the company.
	ExcludeUntil *string `json:"exclude_until,omitempty"`

	// 30-day limit on deposits
	Max30DayDeposit *float64 `json:"max_30day_deposit,omitempty"`

	// 30-day limit on losses
	Max30DayLosses *float64 `json:"max_30day_losses,omitempty"`

	// 30-day turnover limit
	Max30DayTurnover *float64 `json:"max_30day_turnover,omitempty"`

	// 7-day limit on deposits
	Max7DayDeposit *float64 `json:"max_7day_deposit,omitempty"`

	// 7-day limit on losses
	Max7DayLosses *float64 `json:"max_7day_losses,omitempty"`

	// 7-day turnover limit
	Max7DayTurnover *float64 `json:"max_7day_turnover,omitempty"`

	// Maximum account cash balance
	MaxBalance *float64 `json:"max_balance,omitempty"`

	// Daily limit on deposits
	MaxDeposit *float64 `json:"max_deposit,omitempty"`

	// Daily limit on losses
	MaxLosses *float64 `json:"max_losses,omitempty"`

	// Maximum number of open positions
	MaxOpenBets *int `json:"max_open_bets,omitempty"`

	// Daily turnover limit
	MaxTurnover *float64 `json:"max_turnover,omitempty"`

	// Session duration limit, in minutes
	SessionDurationLimit *int `json:"session_duration_limit,omitempty"`

	// Exclude me from the website (for up to 6 weeks). The time is in epoch format.
	// Note: unlike `exclude_until`, this self-exclusion will be lifted automatically
	// at the expiry of the timeout period.
	TimeoutUntil *int `json:"timeout_until,omitempty"`
}

type GetSelfExclusionRespMsgType string

const GetSelfExclusionRespMsgTypeGetSelfExclusion GetSelfExclusionRespMsgType = "get_self_exclusion"

// Get User Settings (email, date of birth, address etc)
type GetSettings struct {
	// Must be `1`
	GetSettings GetSettingsGetSettings `json:"get_settings"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough GetSettingsPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type GetSettingsGetSettings int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type GetSettingsPassthrough map[string]interface{}

// A message with User Settings
type GetSettingsResp struct {
	// Echo of the request made.
	EchoReq GetSettingsRespEchoReq `json:"echo_req"`

	// User information and settings.
	GetSettings *GetSettingsRespGetSettings `json:"get_settings,omitempty"`

	// Action name of the request made.
	MsgType GetSettingsRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type GetSettingsRespEchoReq map[string]interface{}

// User information and settings.
type GetSettingsRespGetSettings struct {
	// Purpose and reason for requesting the account opening. Only applicable for real
	// money account.
	AccountOpeningReason interface{} `json:"account_opening_reason,omitempty"`

	// City (note: Only available for users who have at least one real account)
	AddressCity *string `json:"address_city,omitempty"`

	// Address line 1 (note: Only available for users who have at least one real
	// account)
	AddressLine1 *string `json:"address_line_1,omitempty"`

	// Address line 2 (note: Only available for users who have at least one real
	// account)
	AddressLine2 *string `json:"address_line_2,omitempty"`

	// Post Code (note: Only available for users who have at least one real account)
	AddressPostcode *string `json:"address_postcode,omitempty"`

	// State (note: Only available for users who have at least one real account)
	AddressState *string `json:"address_state,omitempty"`

	// Boolean value 1 or 0, indicating permission to allow others to follow your
	// trades. Note: not applicable for Virtual account. Only allow for real money
	// account.
	AllowCopiers *GetSettingsRespGetSettingsAllowCopiers `json:"allow_copiers,omitempty"`

	// Country of legal citizenship, 2-letter country code.
	Citizen *string `json:"citizen,omitempty"`

	// Latest terms and conditions version accepted by client
	ClientTncStatus interface{} `json:"client_tnc_status,omitempty"`

	// Cooldown expiration epoch date when a client fails appropriateness tests
	CoolingOffExpirationDate interface{} `json:"cooling_off_expiration_date,omitempty"`

	// User Country (same as residence field) - deprecated
	Country interface{} `json:"country,omitempty"`

	// 2-letter country code ISO standard
	CountryCode interface{} `json:"country_code,omitempty"`

	// Epoch of user's birthday (note: Only available for users who have at least one
	// real account)
	DateOfBirth interface{} `json:"date_of_birth,omitempty"`

	// Boolean value 1 or 0, indicating if user email belong to dxtrade exception
	// list.
	DxtradeUserException *GetSettingsRespGetSettingsDxtradeUserException `json:"dxtrade_user_exception,omitempty"`

	// User Email
	Email *string `json:"email,omitempty"`

	// Boolean value 1 or 0, indicating permission to use email address for any
	// contact which may include marketing
	EmailConsent *GetSettingsRespGetSettingsEmailConsent `json:"email_consent,omitempty"`

	// Employment Status.
	EmploymentStatus *GetSettingsRespGetSettingsEmploymentStatus `json:"employment_status,omitempty"`

	// Contains features that are enabled or disabled for this user
	FeatureFlag *GetSettingsRespGetSettingsFeatureFlag `json:"feature_flag,omitempty"`

	// First name (note: Only available for users who have at least one real account)
	FirstName *string `json:"first_name,omitempty"`

	// Returns 1 if the client has a secret answer, 0 otherwise.
	HasSecretAnswer *GetSettingsRespGetSettingsHasSecretAnswer `json:"has_secret_answer,omitempty"`

	// A list of profile fields which are immutable (read-only unless they are not set
	// yet) due to landing company regulations and the current status of the account.
	ImmutableFields []string `json:"immutable_fields,omitempty"`

	// Boolean value 1 or 0, indicating whether is payment agent (note: not applicable
	// for virtual money accounts)
	IsAuthenticatedPaymentAgent *GetSettingsRespGetSettingsIsAuthenticatedPaymentAgent `json:"is_authenticated_payment_agent,omitempty"`

	// Last name (note: Only available for users who have at least one real account)
	LastName *string `json:"last_name,omitempty"`

	// Indicates client's self-declaration of not being a PEP/RCA (Politically Exposed
	// Person/Relatives and Close Associates). Note: returned for real accounts only.
	NonPepDeclaration *GetSettingsRespGetSettingsNonPepDeclaration `json:"non_pep_declaration,omitempty"`

	// Telephone (note: Only available for users who have at least one real account)
	Phone interface{} `json:"phone,omitempty"`

	// Place of birth, 2-letter country code.
	PlaceOfBirth interface{} `json:"place_of_birth,omitempty"`

	// User's preferred language, ISO standard code of language
	PreferredLanguage interface{} `json:"preferred_language,omitempty"`

	// Boolean value 1 or 0, indicating if client has requested professional status.
	RequestProfessionalStatus *GetSettingsRespGetSettingsRequestProfessionalStatus `json:"request_professional_status,omitempty"`

	// User Country
	Residence interface{} `json:"residence,omitempty"`

	// Salutation (note: Only available for users who have at least one real account)
	Salutation *string `json:"salutation,omitempty"`

	// Tax identification number. Only applicable for real money account.
	TaxIdentificationNumber interface{} `json:"tax_identification_number,omitempty"`

	// Residence for tax purpose. Comma separated iso country code if multiple
	// jurisdictions. Only applicable for real money account.
	TaxResidence interface{} `json:"tax_residence,omitempty"`

	// Boolean value 1 or 0, indicating if client has enabled the Trading Hub
	// dashboard
	TradingHub *int `json:"trading_hub,omitempty"`

	// Hash generated using user details to verify whether the user is legitimate for
	// our customer support system.
	UserHash interface{} `json:"user_hash,omitempty"`
}

type GetSettingsRespGetSettingsAllowCopiers int

type GetSettingsRespGetSettingsDxtradeUserException int

type GetSettingsRespGetSettingsEmailConsent int

type GetSettingsRespGetSettingsEmploymentStatus string

const GetSettingsRespGetSettingsEmploymentStatusEmployed GetSettingsRespGetSettingsEmploymentStatus = "Employed"
const GetSettingsRespGetSettingsEmploymentStatusPensioner GetSettingsRespGetSettingsEmploymentStatus = "Pensioner"
const GetSettingsRespGetSettingsEmploymentStatusSelfEmployed GetSettingsRespGetSettingsEmploymentStatus = "Self-Employed"
const GetSettingsRespGetSettingsEmploymentStatusStudent GetSettingsRespGetSettingsEmploymentStatus = "Student"
const GetSettingsRespGetSettingsEmploymentStatusUnemployed GetSettingsRespGetSettingsEmploymentStatus = "Unemployed"

// Contains features that are enabled or disabled for this user
type GetSettingsRespGetSettingsFeatureFlag struct {
	// Boolean value 1 or 0 indicating whether his feature this enabled or not
	Wallet *GetSettingsRespGetSettingsFeatureFlagWallet `json:"wallet,omitempty"`
}

type GetSettingsRespGetSettingsFeatureFlagWallet int

type GetSettingsRespGetSettingsHasSecretAnswer int

type GetSettingsRespGetSettingsIsAuthenticatedPaymentAgent int

type GetSettingsRespGetSettingsNonPepDeclaration int

type GetSettingsRespGetSettingsRequestProfessionalStatus int

type GetSettingsRespMsgType string

const GetSettingsRespMsgTypeGetSettings GetSettingsRespMsgType = "get_settings"

// Adds document information such as issuing country, id and type for identity
// verification processes.
type IdentityVerificationDocumentAdd struct {
	// [Optional] Additional info required by some document types.
	DocumentAdditional *string `json:"document_additional,omitempty"`

	// The identification number of the document.
	DocumentNumber string `json:"document_number"`

	// The type of the document based on provided `issuing_country` (can obtained from
	// `residence_list` call).
	DocumentType string `json:"document_type"`

	// Must be `1`
	IdentityVerificationDocumentAdd IdentityVerificationDocumentAddIdentityVerificationDocumentAdd `json:"identity_verification_document_add"`

	// 2-letter country code (can obtained from `residence_list` call).
	IssuingCountry string `json:"issuing_country"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough IdentityVerificationDocumentAddPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type IdentityVerificationDocumentAddIdentityVerificationDocumentAdd int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type IdentityVerificationDocumentAddPassthrough map[string]interface{}

// Adds document information such as issuing country, id and type for identity
// verification processes.
type IdentityVerificationDocumentAddResp struct {
	// Echo of the request made.
	EchoReq IdentityVerificationDocumentAddRespEchoReq `json:"echo_req"`

	// 1 on success
	IdentityVerificationDocumentAdd *IdentityVerificationDocumentAddRespIdentityVerificationDocumentAdd `json:"identity_verification_document_add,omitempty"`

	// Action name of the request made.
	MsgType IdentityVerificationDocumentAddRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type IdentityVerificationDocumentAddRespEchoReq map[string]interface{}

type IdentityVerificationDocumentAddRespIdentityVerificationDocumentAdd int

type IdentityVerificationDocumentAddRespMsgType string

const IdentityVerificationDocumentAddRespMsgTypeIdentityVerificationDocumentAdd IdentityVerificationDocumentAddRespMsgType = "identity_verification_document_add"

// The company has a number of licensed subsidiaries in various jurisdictions,
// which are called Landing Companies. This call will return the appropriate
// Landing Company for clients of a given country. The landing company may differ
// for Gaming contracts (Synthetic Indices) and Financial contracts (Forex, Stock
// Indices, Commodities).
type LandingCompany struct {
	// Client's 2-letter country code (obtained from `residence_list` call).
	LandingCompany string `json:"landing_company"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough LandingCompanyPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

// The company has a number of licensed subsidiaries in various jurisdictions,
// which are called Landing Companies (and which are wholly owned subsidiaries of
// the Deriv Group). This call provides information about each Landing Company.
type LandingCompanyDetails struct {
	// [Optional] Will return an extra field `tin_not_mandatory` indicating if the
	// landing company does not require tax identification number for the provided
	// country.
	Country *string `json:"country,omitempty"`

	// Landing company shortcode.
	LandingCompanyDetails LandingCompanyDetailsLandingCompanyDetails `json:"landing_company_details"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough LandingCompanyDetailsPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type LandingCompanyDetailsLandingCompanyDetails string

const LandingCompanyDetailsLandingCompanyDetailsBvi LandingCompanyDetailsLandingCompanyDetails = "bvi"
const LandingCompanyDetailsLandingCompanyDetailsChampion LandingCompanyDetailsLandingCompanyDetails = "champion"
const LandingCompanyDetailsLandingCompanyDetailsChampionVirtual LandingCompanyDetailsLandingCompanyDetails = "champion-virtual"
const LandingCompanyDetailsLandingCompanyDetailsDsl LandingCompanyDetailsLandingCompanyDetails = "dsl"
const LandingCompanyDetailsLandingCompanyDetailsIom LandingCompanyDetailsLandingCompanyDetails = "iom"
const LandingCompanyDetailsLandingCompanyDetailsLabuan LandingCompanyDetailsLandingCompanyDetails = "labuan"
const LandingCompanyDetailsLandingCompanyDetailsMalta LandingCompanyDetailsLandingCompanyDetails = "malta"
const LandingCompanyDetailsLandingCompanyDetailsMaltainvest LandingCompanyDetailsLandingCompanyDetails = "maltainvest"
const LandingCompanyDetailsLandingCompanyDetailsSamoa LandingCompanyDetailsLandingCompanyDetails = "samoa"
const LandingCompanyDetailsLandingCompanyDetailsSamoaVirtual LandingCompanyDetailsLandingCompanyDetails = "samoa-virtual"
const LandingCompanyDetailsLandingCompanyDetailsSvg LandingCompanyDetailsLandingCompanyDetails = "svg"
const LandingCompanyDetailsLandingCompanyDetailsVanuatu LandingCompanyDetailsLandingCompanyDetails = "vanuatu"
const LandingCompanyDetailsLandingCompanyDetailsVirtual LandingCompanyDetailsLandingCompanyDetails = "virtual"

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type LandingCompanyDetailsPassthrough map[string]interface{}

// A message with Landing Company.
type LandingCompanyDetailsResp struct {
	// Echo of the request made.
	EchoReq LandingCompanyDetailsRespEchoReq `json:"echo_req"`

	// The detailed information of the requested landing company.
	LandingCompanyDetails *LandingCompanyDetailsRespLandingCompanyDetails `json:"landing_company_details,omitempty"`

	// Action name of the request made.
	MsgType LandingCompanyDetailsRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type LandingCompanyDetailsRespEchoReq map[string]interface{}

// The detailed information of the requested landing company.
type LandingCompanyDetailsRespLandingCompanyDetails struct {
	// Landing Company address.
	Address interface{} `json:"address,omitempty"`

	// Special conditions for changing sensitive fields
	ChangeableFields LandingCompanyDetailsRespLandingCompanyDetailsChangeableFields `json:"changeable_fields,omitempty"`

	// Landing Company country.
	Country *string `json:"country,omitempty"`

	// The configuration of each currency.
	CurrencyConfig *LandingCompanyDetailsRespLandingCompanyDetailsCurrencyConfig `json:"currency_config,omitempty"`

	// Flag to indicate whether reality check is applicable for this Landing Company.
	// `1`: applicable, `0`: not applicable. The Reality Check is a feature that gives
	// a summary of the client's trades and account balances on a regular basis
	// throughout his session, and is a regulatory requirement for certain Landing
	// Companies.
	HasRealityCheck *LandingCompanyDetailsRespLandingCompanyDetailsHasRealityCheck `json:"has_reality_check,omitempty"`

	// Allowed contract types for this Landing Company
	LegalAllowedContractCategories []string `json:"legal_allowed_contract_categories,omitempty"`

	// Allowable currencies for accounts with this Landing Company.
	LegalAllowedCurrencies []string `json:"legal_allowed_currencies,omitempty"`

	// Allowed markets for this Landing Company
	LegalAllowedMarkets []string `json:"legal_allowed_markets,omitempty"`

	// Default currency of client accounts with this Landing Company.
	LegalDefaultCurrency *string `json:"legal_default_currency,omitempty"`

	// Landing Company name.
	Name *string `json:"name,omitempty"`

	// Legal requirements for the given Landing Company.
	Requirements *LandingCompanyDetailsRespLandingCompanyDetailsRequirements `json:"requirements,omitempty"`

	// Landing Company shortcode.
	Shortcode *string `json:"shortcode,omitempty"`

	// Flag that indicates whether the landing company supports professional accounts
	// or not
	SupportProfessionalClient *LandingCompanyDetailsRespLandingCompanyDetailsSupportProfessionalClient `json:"support_professional_client,omitempty"`

	// Flag that indicates whether tax identifier number is not mandatory for the
	// current country and landing company.
	TinNotMandatory *LandingCompanyDetailsRespLandingCompanyDetailsTinNotMandatory `json:"tin_not_mandatory,omitempty"`
}

// Special conditions for changing sensitive fields
type LandingCompanyDetailsRespLandingCompanyDetailsChangeableFields map[string]interface{}

// The configuration of each currency.
type LandingCompanyDetailsRespLandingCompanyDetailsCurrencyConfig struct {
	// Name of commodities.
	Commodities LandingCompanyDetailsRespLandingCompanyDetailsCurrencyConfigCommodities `json:"commodities,omitempty"`

	// Name of cryptocurrency.
	Cryptocurrency LandingCompanyDetailsRespLandingCompanyDetailsCurrencyConfigCryptocurrency `json:"cryptocurrency,omitempty"`

	// Name of forex.
	Forex LandingCompanyDetailsRespLandingCompanyDetailsCurrencyConfigForex `json:"forex,omitempty"`

	// Name of indices.
	Indices LandingCompanyDetailsRespLandingCompanyDetailsCurrencyConfigIndices `json:"indices,omitempty"`

	// Name of market.
	Market *LandingCompanyDetailsRespLandingCompanyDetailsCurrencyConfigMarket `json:"market,omitempty"`

	// Name of synthetic index.
	SyntheticIndex LandingCompanyDetailsRespLandingCompanyDetailsCurrencyConfigSyntheticIndex `json:"synthetic_index,omitempty"`
}

// Name of commodities.
type LandingCompanyDetailsRespLandingCompanyDetailsCurrencyConfigCommodities map[string]interface{}

// Name of cryptocurrency.
type LandingCompanyDetailsRespLandingCompanyDetailsCurrencyConfigCryptocurrency map[string]interface{}

// Name of forex.
type LandingCompanyDetailsRespLandingCompanyDetailsCurrencyConfigForex map[string]interface{}

// Name of indices.
type LandingCompanyDetailsRespLandingCompanyDetailsCurrencyConfigIndices map[string]interface{}

// Name of market.
type LandingCompanyDetailsRespLandingCompanyDetailsCurrencyConfigMarket struct {
	// Currency Symbol.
	Currency *LandingCompanyDetailsRespLandingCompanyDetailsCurrencyConfigMarketCurrency `json:"currency,omitempty"`
}

// Currency Symbol.
type LandingCompanyDetailsRespLandingCompanyDetailsCurrencyConfigMarketCurrency struct {
	// Maximum payout for this currency in this market.
	MaxPayout *int `json:"max_payout,omitempty"`

	// Minimum stake for this currency in this market.
	MinStake *int `json:"min_stake,omitempty"`
}

// Name of synthetic index.
type LandingCompanyDetailsRespLandingCompanyDetailsCurrencyConfigSyntheticIndex map[string]interface{}

type LandingCompanyDetailsRespLandingCompanyDetailsHasRealityCheck int

// Legal requirements for the given Landing Company.
type LandingCompanyDetailsRespLandingCompanyDetailsRequirements struct {
	// After first deposit requirements
	AfterFirstDeposit *LandingCompanyDetailsRespLandingCompanyDetailsRequirementsAfterFirstDeposit `json:"after_first_deposit,omitempty"`

	// Compliance requirements
	Compliance *LandingCompanyDetailsRespLandingCompanyDetailsRequirementsCompliance `json:"compliance,omitempty"`

	// Sign up requirements
	Signup []string `json:"signup,omitempty"`

	// Withdrawal requirements
	Withdrawal []string `json:"withdrawal,omitempty"`
}

// After first deposit requirements
type LandingCompanyDetailsRespLandingCompanyDetailsRequirementsAfterFirstDeposit struct {
	// Financial assessment requirements
	FinancialAssessment []string `json:"financial_assessment,omitempty"`
}

// Compliance requirements
type LandingCompanyDetailsRespLandingCompanyDetailsRequirementsCompliance struct {
	// Compliance MT5 requirements
	Mt5 []string `json:"mt5,omitempty"`

	// Compliance tax information requirements
	TaxInformation []string `json:"tax_information,omitempty"`
}

type LandingCompanyDetailsRespLandingCompanyDetailsSupportProfessionalClient int

type LandingCompanyDetailsRespLandingCompanyDetailsTinNotMandatory int

type LandingCompanyDetailsRespMsgType string

const LandingCompanyDetailsRespMsgTypeLandingCompanyDetails LandingCompanyDetailsRespMsgType = "landing_company_details"

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type LandingCompanyPassthrough map[string]interface{}

// Returns the Landing Company for clients of a given country.
type LandingCompanyResp struct {
	// Echo of the request made.
	EchoReq LandingCompanyRespEchoReq `json:"echo_req"`

	// Landing Company
	LandingCompany *LandingCompanyRespLandingCompany `json:"landing_company,omitempty"`

	// Action name of the request made.
	MsgType LandingCompanyRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type LandingCompanyRespEchoReq map[string]interface{}

// Landing Company
type LandingCompanyRespLandingCompany struct {
	// Flag to indicate if address parseable or not
	AddressParseable *LandingCompanyRespLandingCompanyAddressParseable `json:"address_parseable,omitempty"`

	// Config for all account types (Synthetic Indices and Financials).
	AllCompany *LandingCompanyRespLandingCompanyAllCompany `json:"all_company,omitempty"`

	// Config structure with document types ,taxRequired ,tin format details.
	Config LandingCompanyRespLandingCompanyConfig `json:"config,omitempty"`

	// Available CTrader accounts.
	Ctrader *LandingCompanyRespLandingCompanyCtrader `json:"ctrader,omitempty"`

	// Available DerivEZ accounts.
	Derivez *LandingCompanyRespLandingCompanyDerivez `json:"derivez,omitempty"`

	// Available Deriv X all account types (Synthetic Indices and Financials).
	DxtradeAllCompany *LandingCompanyRespLandingCompanyDxtradeAllCompany `json:"dxtrade_all_company,omitempty"`

	// Available Deriv X financial account types (all except Synthetic Indices).
	DxtradeFinancialCompany *LandingCompanyRespLandingCompanyDxtradeFinancialCompany `json:"dxtrade_financial_company,omitempty"`

	// Available Deriv X gaming account types (Synthetic Indices).
	DxtradeGamingCompany *LandingCompanyRespLandingCompanyDxtradeGamingCompany `json:"dxtrade_gaming_company,omitempty"`

	// Landing Company for financial contracts (all except Synthetic Indices)
	FinancialCompany interface{} `json:"financial_company,omitempty"`

	// Forbidden postcode pattern
	ForbiddenPostcodePattern *string `json:"forbidden_postcode_pattern,omitempty"`

	// Landing Company for gaming contracts (Synthetic Indices)
	GamingCompany interface{} `json:"gaming_company,omitempty"`

	// Country code
	Id *string `json:"id,omitempty"`

	// Flag to indicate if idv is supported or not
	IsIdvSupported *LandingCompanyRespLandingCompanyIsIdvSupported `json:"is_idv_supported,omitempty"`

	// Open mf account lc details.
	LcToOpenMfAccount *string `json:"lc_to_open_mf_account,omitempty"`

	// Minimum age
	MinimumAge *int `json:"minimum_age,omitempty"`

	// Flag to indicate if mt5 age verification detail.
	Mt5AgeVerification *LandingCompanyRespLandingCompanyMt5AgeVerification `json:"mt5_age_verification,omitempty"`

	// Landing Company for MT5 standard combined all Synthetic and financial,
	// currently has Financial as subtype.
	MtAllCompany interface{} `json:"mt_all_company,omitempty"`

	// Landing Company for MT5 financial contracts (all except Synthetic Indices),
	// currently divided into Financial STP, Financial (standard) as subtypes.
	MtFinancialCompany interface{} `json:"mt_financial_company,omitempty"`

	// Landing Company for MT5 standard gaming contracts (Synthetic Indices),
	// currently has Financial as subtype.
	MtGamingCompany interface{} `json:"mt_gaming_company,omitempty"`

	// Country name
	Name *string `json:"name,omitempty"`

	// Flag to indicate whether max turnover limit settings.
	NeedSetMaxTurnoverLimit *LandingCompanyRespLandingCompanyNeedSetMaxTurnoverLimit `json:"need_set_max_turnover_limit,omitempty"`

	// Flag to indicate province settings.
	NoProvince *LandingCompanyRespLandingCompanyNoProvince `json:"no_province,omitempty"`

	// Flag to indicate whether address postcode is required or not.
	RequireAddressPostcode *LandingCompanyRespLandingCompanyRequireAddressPostcode `json:"require_address_postcode,omitempty"`

	// Flag to indicate whether age verification required ofr synthetic or not.
	RequireAgeVerifiedForSynthetic *LandingCompanyRespLandingCompanyRequireAgeVerifiedForSynthetic `json:"require_age_verified_for_synthetic,omitempty"`

	// Flag to indicate whether poi is required.
	RequirePoi *LandingCompanyRespLandingCompanyRequirePoi `json:"require_poi,omitempty"`

	// Flag to indicate whether verification required if age not verified.
	RequireVerificationWhenNotAgeVerified *LandingCompanyRespLandingCompanyRequireVerificationWhenNotAgeVerified `json:"require_verification_when_not_age_verified,omitempty"`

	// Flag to indicate whether to skip deposit verifcation or not.
	SkipDepositVerification *LandingCompanyRespLandingCompanySkipDepositVerification `json:"skip_deposit_verification,omitempty"`

	// Flag to indicate ukgc funds protection setting.
	UkgcFundsProtection *LandingCompanyRespLandingCompanyUkgcFundsProtection `json:"ukgc_funds_protection,omitempty"`

	// Virtual Company
	VirtualCompany *string `json:"virtual_company,omitempty"`
}

type LandingCompanyRespLandingCompanyAddressParseable int

type LandingCompanyRespLandingCompanyAllCompany string

const LandingCompanyRespLandingCompanyAllCompanyNone LandingCompanyRespLandingCompanyAllCompany = "none"
const LandingCompanyRespLandingCompanyAllCompanySvg LandingCompanyRespLandingCompanyAllCompany = "svg"

// Config structure with document types ,taxRequired ,tin format details.
type LandingCompanyRespLandingCompanyConfig map[string]interface{}

// Available CTrader accounts.
type LandingCompanyRespLandingCompanyCtrader struct {
	// CTrader all account types (Synthetic Indices and Financials).
	All *LandingCompanyRespLandingCompanyCtraderAll `json:"all,omitempty"`
}

// CTrader all account types (Synthetic Indices and Financials).
type LandingCompanyRespLandingCompanyCtraderAll struct {
	// For standard client
	Standard *LandingCompanyRespLandingCompanyCtraderAllStandard `json:"standard,omitempty"`
}

type LandingCompanyRespLandingCompanyCtraderAllStandard string

const LandingCompanyRespLandingCompanyCtraderAllStandardNone LandingCompanyRespLandingCompanyCtraderAllStandard = "none"
const LandingCompanyRespLandingCompanyCtraderAllStandardSvg LandingCompanyRespLandingCompanyCtraderAllStandard = "svg"

// Available DerivEZ accounts.
type LandingCompanyRespLandingCompanyDerivez struct {
	// DerivEZ all account types (Synthetic Indices and Financials).
	All *LandingCompanyRespLandingCompanyDerivezAll `json:"all,omitempty"`
}

// DerivEZ all account types (Synthetic Indices and Financials).
type LandingCompanyRespLandingCompanyDerivezAll struct {
	// For standard client
	Standard *LandingCompanyRespLandingCompanyDerivezAllStandard `json:"standard,omitempty"`
}

type LandingCompanyRespLandingCompanyDerivezAllStandard string

const LandingCompanyRespLandingCompanyDerivezAllStandardNone LandingCompanyRespLandingCompanyDerivezAllStandard = "none"
const LandingCompanyRespLandingCompanyDerivezAllStandardSvg LandingCompanyRespLandingCompanyDerivezAllStandard = "svg"

// Available Deriv X all account types (Synthetic Indices and Financials).
type LandingCompanyRespLandingCompanyDxtradeAllCompany struct {
	// Landing Company details.
	Standard *LandingCompanyRespLandingCompanyDxtradeAllCompanyStandard `json:"standard,omitempty"`
}

// Landing Company details.
type LandingCompanyRespLandingCompanyDxtradeAllCompanyStandard struct {
	// Landing Company address
	Address interface{} `json:"address,omitempty"`

	// Special conditions for changing sensitive fields
	ChangeableFields LandingCompanyRespLandingCompanyDxtradeAllCompanyStandardChangeableFields `json:"changeable_fields,omitempty"`

	// Landing Company country of incorporation
	Country *string `json:"country,omitempty"`

	// The configuration of each currency.
	CurrencyConfig LandingCompanyRespLandingCompanyDxtradeAllCompanyStandardCurrencyConfig `json:"currency_config,omitempty"`

	// Flag to indicate whether reality check is applicable for this Landing Company.
	// `1`: applicable, `0`: not applicable. The Reality Check is a feature that gives
	// a summary of the client's trades and account balances on a regular basis
	// throughout his session, and is a regulatory requirement for certain Landing
	// Companies.
	HasRealityCheck *LandingCompanyRespLandingCompanyDxtradeAllCompanyStandardHasRealityCheck `json:"has_reality_check,omitempty"`

	// Allowed contract types
	LegalAllowedContractCategories []string `json:"legal_allowed_contract_categories,omitempty"`

	// Allowable currencies
	LegalAllowedCurrencies []string `json:"legal_allowed_currencies,omitempty"`

	// Allowable markets
	LegalAllowedMarkets []string `json:"legal_allowed_markets,omitempty"`

	// Default account currency
	LegalDefaultCurrency *string `json:"legal_default_currency,omitempty"`

	// Landing Company legal name
	Name *string `json:"name,omitempty"`

	// Legal requirements for the Landing Company
	Requirements *LandingCompanyRespLandingCompanyDxtradeAllCompanyStandardRequirements `json:"requirements,omitempty"`

	// Landing Company short code
	Shortcode *string `json:"shortcode,omitempty"`

	// Flag that indicates whether the landing company supports professional accounts
	// or not
	SupportProfessionalClient *LandingCompanyRespLandingCompanyDxtradeAllCompanyStandardSupportProfessionalClient `json:"support_professional_client,omitempty"`

	// Flag that indicates whether tax identifier number is not mandatory for the
	// current country and landing company.
	TinNotMandatory *LandingCompanyRespLandingCompanyDxtradeAllCompanyStandardTinNotMandatory `json:"tin_not_mandatory,omitempty"`
}

// Special conditions for changing sensitive fields
type LandingCompanyRespLandingCompanyDxtradeAllCompanyStandardChangeableFields map[string]interface{}

// The configuration of each currency.
type LandingCompanyRespLandingCompanyDxtradeAllCompanyStandardCurrencyConfig map[string]interface{}

type LandingCompanyRespLandingCompanyDxtradeAllCompanyStandardHasRealityCheck int

// Legal requirements for the Landing Company
type LandingCompanyRespLandingCompanyDxtradeAllCompanyStandardRequirements struct {
	// After first deposit requirements
	AfterFirstDeposit *LandingCompanyRespLandingCompanyDxtradeAllCompanyStandardRequirementsAfterFirstDeposit `json:"after_first_deposit,omitempty"`

	// Compliance requirements
	Compliance *LandingCompanyRespLandingCompanyDxtradeAllCompanyStandardRequirementsCompliance `json:"compliance,omitempty"`

	// Sign up requirements
	Signup []string `json:"signup,omitempty"`

	// Withdrawal requirements
	Withdrawal []string `json:"withdrawal,omitempty"`
}

// After first deposit requirements
type LandingCompanyRespLandingCompanyDxtradeAllCompanyStandardRequirementsAfterFirstDeposit struct {
	// Financial assessment requirements
	FinancialAssessment []string `json:"financial_assessment,omitempty"`
}

// Compliance requirements
type LandingCompanyRespLandingCompanyDxtradeAllCompanyStandardRequirementsCompliance struct {
	// Compliance MT5 requirements
	Mt5 []string `json:"mt5,omitempty"`

	// Compliance tax information requirements
	TaxInformation []string `json:"tax_information,omitempty"`
}

type LandingCompanyRespLandingCompanyDxtradeAllCompanyStandardSupportProfessionalClient int

type LandingCompanyRespLandingCompanyDxtradeAllCompanyStandardTinNotMandatory int

// Available Deriv X financial account types (all except Synthetic Indices).
type LandingCompanyRespLandingCompanyDxtradeFinancialCompany struct {
	// Landing Company details.
	Standard *LandingCompanyRespLandingCompanyDxtradeFinancialCompanyStandard `json:"standard,omitempty"`
}

// Landing Company details.
type LandingCompanyRespLandingCompanyDxtradeFinancialCompanyStandard struct {
	// Landing Company address
	Address interface{} `json:"address,omitempty"`

	// Special conditions for changing sensitive fields
	ChangeableFields LandingCompanyRespLandingCompanyDxtradeFinancialCompanyStandardChangeableFields `json:"changeable_fields,omitempty"`

	// Landing Company country of incorporation
	Country *string `json:"country,omitempty"`

	// The configuration of each currency.
	CurrencyConfig LandingCompanyRespLandingCompanyDxtradeFinancialCompanyStandardCurrencyConfig `json:"currency_config,omitempty"`

	// Flag to indicate whether reality check is applicable for this Landing Company.
	// `1`: applicable, `0`: not applicable. The Reality Check is a feature that gives
	// a summary of the client's trades and account balances on a regular basis
	// throughout his session, and is a regulatory requirement for certain Landing
	// Companies.
	HasRealityCheck *LandingCompanyRespLandingCompanyDxtradeFinancialCompanyStandardHasRealityCheck `json:"has_reality_check,omitempty"`

	// Allowed contract types
	LegalAllowedContractCategories []string `json:"legal_allowed_contract_categories,omitempty"`

	// Allowable currencies
	LegalAllowedCurrencies []string `json:"legal_allowed_currencies,omitempty"`

	// Allowable markets
	LegalAllowedMarkets []string `json:"legal_allowed_markets,omitempty"`

	// Default account currency
	LegalDefaultCurrency *string `json:"legal_default_currency,omitempty"`

	// Landing Company legal name
	Name *string `json:"name,omitempty"`

	// Legal requirements for the Landing Company
	Requirements *LandingCompanyRespLandingCompanyDxtradeFinancialCompanyStandardRequirements `json:"requirements,omitempty"`

	// Landing Company short code
	Shortcode *string `json:"shortcode,omitempty"`

	// Flag that indicates whether the landing company supports professional accounts
	// or not
	SupportProfessionalClient *LandingCompanyRespLandingCompanyDxtradeFinancialCompanyStandardSupportProfessionalClient `json:"support_professional_client,omitempty"`

	// Flag that indicates whether tax identifier number is not mandatory for the
	// current country and landing company.
	TinNotMandatory *LandingCompanyRespLandingCompanyDxtradeFinancialCompanyStandardTinNotMandatory `json:"tin_not_mandatory,omitempty"`
}

// Special conditions for changing sensitive fields
type LandingCompanyRespLandingCompanyDxtradeFinancialCompanyStandardChangeableFields map[string]interface{}

// The configuration of each currency.
type LandingCompanyRespLandingCompanyDxtradeFinancialCompanyStandardCurrencyConfig map[string]interface{}

type LandingCompanyRespLandingCompanyDxtradeFinancialCompanyStandardHasRealityCheck int

// Legal requirements for the Landing Company
type LandingCompanyRespLandingCompanyDxtradeFinancialCompanyStandardRequirements struct {
	// After first deposit requirements
	AfterFirstDeposit *LandingCompanyRespLandingCompanyDxtradeFinancialCompanyStandardRequirementsAfterFirstDeposit `json:"after_first_deposit,omitempty"`

	// Compliance requirements
	Compliance *LandingCompanyRespLandingCompanyDxtradeFinancialCompanyStandardRequirementsCompliance `json:"compliance,omitempty"`

	// Sign up requirements
	Signup []string `json:"signup,omitempty"`

	// Withdrawal requirements
	Withdrawal []string `json:"withdrawal,omitempty"`
}

// After first deposit requirements
type LandingCompanyRespLandingCompanyDxtradeFinancialCompanyStandardRequirementsAfterFirstDeposit struct {
	// Financial assessment requirements
	FinancialAssessment []string `json:"financial_assessment,omitempty"`
}

// Compliance requirements
type LandingCompanyRespLandingCompanyDxtradeFinancialCompanyStandardRequirementsCompliance struct {
	// Compliance MT5 requirements
	Mt5 []string `json:"mt5,omitempty"`

	// Compliance tax information requirements
	TaxInformation []string `json:"tax_information,omitempty"`
}

type LandingCompanyRespLandingCompanyDxtradeFinancialCompanyStandardSupportProfessionalClient int

type LandingCompanyRespLandingCompanyDxtradeFinancialCompanyStandardTinNotMandatory int

// Available Deriv X gaming account types (Synthetic Indices).
type LandingCompanyRespLandingCompanyDxtradeGamingCompany struct {
	// Landing Company details.
	Standard *LandingCompanyRespLandingCompanyDxtradeGamingCompanyStandard `json:"standard,omitempty"`
}

// Landing Company details.
type LandingCompanyRespLandingCompanyDxtradeGamingCompanyStandard struct {
	// Landing Company address
	Address interface{} `json:"address,omitempty"`

	// Special conditions for changing sensitive fields
	ChangeableFields LandingCompanyRespLandingCompanyDxtradeGamingCompanyStandardChangeableFields `json:"changeable_fields,omitempty"`

	// Landing Company country of incorporation
	Country *string `json:"country,omitempty"`

	// The configuration of each currency.
	CurrencyConfig LandingCompanyRespLandingCompanyDxtradeGamingCompanyStandardCurrencyConfig `json:"currency_config,omitempty"`

	// Flag to indicate whether reality check is applicable for this Landing Company.
	// `1`: applicable, `0`: not applicable. The Reality Check is a feature that gives
	// a summary of the client's trades and account balances on a regular basis
	// throughout his session, and is a regulatory requirement for certain Landing
	// Companies.
	HasRealityCheck *LandingCompanyRespLandingCompanyDxtradeGamingCompanyStandardHasRealityCheck `json:"has_reality_check,omitempty"`

	// Allowed contract types
	LegalAllowedContractCategories []string `json:"legal_allowed_contract_categories,omitempty"`

	// Allowable currencies
	LegalAllowedCurrencies []string `json:"legal_allowed_currencies,omitempty"`

	// Allowable markets
	LegalAllowedMarkets []string `json:"legal_allowed_markets,omitempty"`

	// Default account currency
	LegalDefaultCurrency *string `json:"legal_default_currency,omitempty"`

	// Landing Company legal name
	Name *string `json:"name,omitempty"`

	// Legal requirements for the Landing Company
	Requirements *LandingCompanyRespLandingCompanyDxtradeGamingCompanyStandardRequirements `json:"requirements,omitempty"`

	// Landing Company short code
	Shortcode *string `json:"shortcode,omitempty"`

	// Flag that indicates whether the landing company supports professional accounts
	// or not
	SupportProfessionalClient *LandingCompanyRespLandingCompanyDxtradeGamingCompanyStandardSupportProfessionalClient `json:"support_professional_client,omitempty"`

	// Flag that indicates whether tax identifier number is not mandatory for the
	// current country and landing company.
	TinNotMandatory *LandingCompanyRespLandingCompanyDxtradeGamingCompanyStandardTinNotMandatory `json:"tin_not_mandatory,omitempty"`
}

// Special conditions for changing sensitive fields
type LandingCompanyRespLandingCompanyDxtradeGamingCompanyStandardChangeableFields map[string]interface{}

// The configuration of each currency.
type LandingCompanyRespLandingCompanyDxtradeGamingCompanyStandardCurrencyConfig map[string]interface{}

type LandingCompanyRespLandingCompanyDxtradeGamingCompanyStandardHasRealityCheck int

// Legal requirements for the Landing Company
type LandingCompanyRespLandingCompanyDxtradeGamingCompanyStandardRequirements struct {
	// After first deposit requirements
	AfterFirstDeposit *LandingCompanyRespLandingCompanyDxtradeGamingCompanyStandardRequirementsAfterFirstDeposit `json:"after_first_deposit,omitempty"`

	// Compliance requirements
	Compliance *LandingCompanyRespLandingCompanyDxtradeGamingCompanyStandardRequirementsCompliance `json:"compliance,omitempty"`

	// Sign up requirements
	Signup []string `json:"signup,omitempty"`

	// Withdrawal requirements
	Withdrawal []string `json:"withdrawal,omitempty"`
}

// After first deposit requirements
type LandingCompanyRespLandingCompanyDxtradeGamingCompanyStandardRequirementsAfterFirstDeposit struct {
	// Financial assessment requirements
	FinancialAssessment []string `json:"financial_assessment,omitempty"`
}

// Compliance requirements
type LandingCompanyRespLandingCompanyDxtradeGamingCompanyStandardRequirementsCompliance struct {
	// Compliance MT5 requirements
	Mt5 []string `json:"mt5,omitempty"`

	// Compliance tax information requirements
	TaxInformation []string `json:"tax_information,omitempty"`
}

type LandingCompanyRespLandingCompanyDxtradeGamingCompanyStandardSupportProfessionalClient int

type LandingCompanyRespLandingCompanyDxtradeGamingCompanyStandardTinNotMandatory int

type LandingCompanyRespLandingCompanyIsIdvSupported int

type LandingCompanyRespLandingCompanyMt5AgeVerification int

type LandingCompanyRespLandingCompanyNeedSetMaxTurnoverLimit int

type LandingCompanyRespLandingCompanyNoProvince int

type LandingCompanyRespLandingCompanyRequireAddressPostcode int

type LandingCompanyRespLandingCompanyRequireAgeVerifiedForSynthetic int

type LandingCompanyRespLandingCompanyRequirePoi int

type LandingCompanyRespLandingCompanyRequireVerificationWhenNotAgeVerified int

type LandingCompanyRespLandingCompanySkipDepositVerification int

type LandingCompanyRespLandingCompanyUkgcFundsProtection int

type LandingCompanyRespMsgType string

const LandingCompanyRespMsgTypeLandingCompany LandingCompanyRespMsgType = "landing_company"

// Retrieve a summary of login history for user.
type LoginHistory struct {
	// [Optional] Apply limit to count of login history records.
	Limit int `json:"limit,omitempty"`

	// Must be `1`
	LoginHistory LoginHistoryLoginHistory `json:"login_history"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough LoginHistoryPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type LoginHistoryLoginHistory int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type LoginHistoryPassthrough map[string]interface{}

// Recent login/logout history records
type LoginHistoryResp struct {
	// Echo of the request made.
	EchoReq LoginHistoryRespEchoReq `json:"echo_req"`

	// Array of records of client login/logout activities
	LoginHistory []LoginHistoryRespLoginHistoryElem `json:"login_history,omitempty"`

	// Action name of the request made.
	MsgType LoginHistoryRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type LoginHistoryRespEchoReq map[string]interface{}

// User login history
type LoginHistoryRespLoginHistoryElem struct {
	// Type of action.
	Action string `json:"action"`

	// Provides details about browser, device used during login or logout
	Environment string `json:"environment"`

	// Status of activity: 1 - success, 0 - failure
	Status LoginHistoryRespLoginHistoryElemStatus `json:"status"`

	// Epoch time of the activity
	Time int `json:"time"`
}

type LoginHistoryRespLoginHistoryElemStatus int

type LoginHistoryRespMsgType string

const LoginHistoryRespMsgTypeLoginHistory LoginHistoryRespMsgType = "login_history"

// Logout the session
type Logout struct {
	// Must be `1`
	Logout LogoutLogout `json:"logout"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough LogoutPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type LogoutLogout int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type LogoutPassthrough map[string]interface{}

// The response of logout request made.
type LogoutResp struct {
	// Echo of the request made.
	EchoReq LogoutRespEchoReq `json:"echo_req"`

	// The result of logout request which is 1
	Logout *LogoutRespLogout `json:"logout,omitempty"`

	// Action name of the request made.
	MsgType LogoutRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type LogoutRespEchoReq map[string]interface{}

type LogoutRespLogout int

type LogoutRespMsgType string

const LogoutRespMsgTypeLogout LogoutRespMsgType = "logout"

// This call allows deposit into MT5 account from Binary account.
type Mt5Deposit struct {
	// Amount to deposit (in the currency of from_binary); min = $1 or an equivalent
	// amount, max = $20000 or an equivalent amount
	Amount *float64 `json:"amount,omitempty"`

	// Binary account loginid to transfer money from
	FromBinary *string `json:"from_binary,omitempty"`

	// Must be `1`
	Mt5Deposit Mt5DepositMt5Deposit `json:"mt5_deposit"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough Mt5DepositPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// MT5 account login to deposit money to
	ToMt5 string `json:"to_mt5"`
}

type Mt5DepositMt5Deposit int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type Mt5DepositPassthrough map[string]interface{}

// The result of MT5 deposit request.
type Mt5DepositResp struct {
	// Withdrawal reference ID of Binary account
	BinaryTransactionId *int `json:"binary_transaction_id,omitempty"`

	// Echo of the request made.
	EchoReq Mt5DepositRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType Mt5DepositRespMsgType `json:"msg_type"`

	// 1 on success
	Mt5Deposit *int `json:"mt5_deposit,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type Mt5DepositRespEchoReq map[string]interface{}

type Mt5DepositRespMsgType string

const Mt5DepositRespMsgTypeMt5Deposit Mt5DepositRespMsgType = "mt5_deposit"

// Get MT5 user account settings
type Mt5GetSettings struct {
	// MT5 user login
	Login string `json:"login"`

	// Must be `1`
	Mt5GetSettings Mt5GetSettingsMt5GetSettings `json:"mt5_get_settings"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough Mt5GetSettingsPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type Mt5GetSettingsMt5GetSettings int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type Mt5GetSettingsPassthrough map[string]interface{}

// Get MT5 user settings
type Mt5GetSettingsResp struct {
	// Echo of the request made.
	EchoReq Mt5GetSettingsRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType Mt5GetSettingsRespMsgType `json:"msg_type"`

	// MT5 user account details
	Mt5GetSettings *Mt5GetSettingsRespMt5GetSettings `json:"mt5_get_settings,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type Mt5GetSettingsRespEchoReq map[string]interface{}

type Mt5GetSettingsRespMsgType string

const Mt5GetSettingsRespMsgTypeMt5GetSettings Mt5GetSettingsRespMsgType = "mt5_get_settings"

// MT5 user account details
type Mt5GetSettingsRespMt5GetSettings struct {
	// Account type.
	AccountType *Mt5GetSettingsRespMt5GetSettingsAccountType `json:"account_type,omitempty"`

	// The address of the user. The maximum length of the address is 128 characters.
	Address *string `json:"address,omitempty"`

	// Account balance.
	Balance *string `json:"balance,omitempty"`

	// User's city of residence.
	City *string `json:"city,omitempty"`

	// Name of the client's company. The maximum length of the company name is 64
	// characters.
	Company *string `json:"company,omitempty"`

	// 2-letter country code.
	Country *string `json:"country,omitempty"`

	// MT5 account currency (`USD` or `EUR`) that depends on the MT5 company
	// (`vanuatu`, `svg`, `malta`).
	Currency *string `json:"currency,omitempty"`

	// Email address.
	Email *string `json:"email,omitempty"`

	// The group where account belongs to.
	Group *string `json:"group,omitempty"`

	// Landing company shortcode of the MT5 account.
	LandingCompanyShort *Mt5GetSettingsRespMt5GetSettingsLandingCompanyShort `json:"landing_company_short,omitempty"`

	// Client leverage (from 1 to 1000).
	Leverage *float64 `json:"leverage,omitempty"`

	// Login ID of the user's MT5 account.
	Login *string `json:"login,omitempty"`

	// Market type
	MarketType *Mt5GetSettingsRespMt5GetSettingsMarketType `json:"market_type,omitempty"`

	// Client's name. The maximum length of a client's symbol name is 128 characters.
	Name *string `json:"name,omitempty"`

	// User's phone number.
	Phone *string `json:"phone,omitempty"`

	// The user's phone password.
	PhonePassword *string `json:"phonePassword,omitempty"`

	// User's state (region) of residence.
	State *string `json:"state,omitempty"`

	// Sub account type
	SubAccountType *Mt5GetSettingsRespMt5GetSettingsSubAccountType `json:"sub_account_type,omitempty"`

	// User's zip code.
	ZipCode *string `json:"zipCode,omitempty"`
}

type Mt5GetSettingsRespMt5GetSettingsAccountType string

const Mt5GetSettingsRespMt5GetSettingsAccountTypeDemo Mt5GetSettingsRespMt5GetSettingsAccountType = "demo"
const Mt5GetSettingsRespMt5GetSettingsAccountTypeReal Mt5GetSettingsRespMt5GetSettingsAccountType = "real"

type Mt5GetSettingsRespMt5GetSettingsLandingCompanyShort string

const Mt5GetSettingsRespMt5GetSettingsLandingCompanyShortBvi Mt5GetSettingsRespMt5GetSettingsLandingCompanyShort = "bvi"
const Mt5GetSettingsRespMt5GetSettingsLandingCompanyShortLabuan Mt5GetSettingsRespMt5GetSettingsLandingCompanyShort = "labuan"
const Mt5GetSettingsRespMt5GetSettingsLandingCompanyShortMalta Mt5GetSettingsRespMt5GetSettingsLandingCompanyShort = "malta"
const Mt5GetSettingsRespMt5GetSettingsLandingCompanyShortMaltainvest Mt5GetSettingsRespMt5GetSettingsLandingCompanyShort = "maltainvest"
const Mt5GetSettingsRespMt5GetSettingsLandingCompanyShortSvg Mt5GetSettingsRespMt5GetSettingsLandingCompanyShort = "svg"
const Mt5GetSettingsRespMt5GetSettingsLandingCompanyShortVanuatu Mt5GetSettingsRespMt5GetSettingsLandingCompanyShort = "vanuatu"

type Mt5GetSettingsRespMt5GetSettingsMarketType string

const Mt5GetSettingsRespMt5GetSettingsMarketTypeFinancial Mt5GetSettingsRespMt5GetSettingsMarketType = "financial"
const Mt5GetSettingsRespMt5GetSettingsMarketTypeSynthetic Mt5GetSettingsRespMt5GetSettingsMarketType = "synthetic"

type Mt5GetSettingsRespMt5GetSettingsSubAccountType string

const Mt5GetSettingsRespMt5GetSettingsSubAccountTypeFinancial Mt5GetSettingsRespMt5GetSettingsSubAccountType = "financial"
const Mt5GetSettingsRespMt5GetSettingsSubAccountTypeFinancialStp Mt5GetSettingsRespMt5GetSettingsSubAccountType = "financial_stp"

// Get list of MT5 accounts for client
type Mt5LoginList struct {
	// Must be `1`
	Mt5LoginList Mt5LoginListMt5LoginList `json:"mt5_login_list"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough Mt5LoginListPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type Mt5LoginListMt5LoginList int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type Mt5LoginListPassthrough map[string]interface{}

// Get list of MT5 accounts for client.
type Mt5LoginListResp struct {
	// Echo of the request made.
	EchoReq Mt5LoginListRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType Mt5LoginListRespMsgType `json:"msg_type"`

	// Array containing MT5 account objects.
	Mt5LoginList []Mt5LoginListRespMt5LoginListElem `json:"mt5_login_list,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type Mt5LoginListRespEchoReq map[string]interface{}

type Mt5LoginListRespMsgType string

const Mt5LoginListRespMsgTypeMt5LoginList Mt5LoginListRespMsgType = "mt5_login_list"

type Mt5LoginListRespMt5LoginListElem struct {
	// Account type.
	AccountType *Mt5LoginListRespMt5LoginListElemAccountType `json:"account_type,omitempty"`

	// Balance of the MT5 account.
	Balance *float64 `json:"balance,omitempty"`

	// Residence of the MT5 account.
	Country *string `json:"country,omitempty"`

	// Currency of the MT5 account.
	Currency *string `json:"currency,omitempty"`

	// Account balance, formatted to appropriate decimal places.
	DisplayBalance *string `json:"display_balance,omitempty"`

	// Email address of the MT5 account.
	Email *string `json:"email,omitempty"`

	// Error in MT5 account details.
	Error *Mt5LoginListRespMt5LoginListElemError `json:"error,omitempty"`

	// Group type of the MT5 account, e.g. `demo\svg_financial`
	Group *string `json:"group,omitempty"`

	// Landing company shortcode of the MT5 account.
	LandingCompanyShort *Mt5LoginListRespMt5LoginListElemLandingCompanyShort `json:"landing_company_short,omitempty"`

	// Leverage of the MT5 account (1 to 1000).
	Leverage *float64 `json:"leverage,omitempty"`

	// Login of MT5 account.
	Login *string `json:"login,omitempty"`

	// Market type
	MarketType *Mt5LoginListRespMt5LoginListElemMarketType `json:"market_type,omitempty"`

	// Name of the owner of the MT5 account.
	Name *string `json:"name,omitempty"`

	// Trade server name of the MT5 account.
	Server *string `json:"server,omitempty"`

	// Trade server information.
	ServerInfo *Mt5LoginListRespMt5LoginListElemServerInfo `json:"server_info,omitempty"`

	// MT5 account status.
	Status interface{} `json:"status,omitempty"`

	// Sub account category
	SubAccountCategory *Mt5LoginListRespMt5LoginListElemSubAccountCategory `json:"sub_account_category,omitempty"`

	// Sub account type refer to classic MT5 account
	SubAccountType *Mt5LoginListRespMt5LoginListElemSubAccountType `json:"sub_account_type,omitempty"`
}

type Mt5LoginListRespMt5LoginListElemAccountType string

const Mt5LoginListRespMt5LoginListElemAccountTypeDemo Mt5LoginListRespMt5LoginListElemAccountType = "demo"
const Mt5LoginListRespMt5LoginListElemAccountTypeReal Mt5LoginListRespMt5LoginListElemAccountType = "real"

// Error in MT5 account details.
type Mt5LoginListRespMt5LoginListElemError struct {
	// Error code string.
	Code *string `json:"code,omitempty"`

	// Extra information about the error.
	Details *Mt5LoginListRespMt5LoginListElemErrorDetails `json:"details,omitempty"`

	// Error message.
	MessageToClient *string `json:"message_to_client,omitempty"`
}

// Extra information about the error.
type Mt5LoginListRespMt5LoginListElemErrorDetails struct {
	// MT5 account type.
	AccountType *string `json:"account_type,omitempty"`

	// MT5 account login ID.
	Login *string `json:"login,omitempty"`

	// Trade server name of the MT5 account.
	Server *string `json:"server,omitempty"`

	// Trade server information.
	ServerInfo *Mt5LoginListRespMt5LoginListElemErrorDetailsServerInfo `json:"server_info,omitempty"`
}

// Trade server information.
type Mt5LoginListRespMt5LoginListElemErrorDetailsServerInfo struct {
	// The environment. E.g. Deriv-Server.
	Environment *Mt5LoginListRespMt5LoginListElemErrorDetailsServerInfoEnvironment `json:"environment,omitempty"`

	// Geographical location of the server.
	Geolocation *Mt5LoginListRespMt5LoginListElemErrorDetailsServerInfoGeolocation `json:"geolocation,omitempty"`

	// Server id.
	Id *string `json:"id,omitempty"`
}

type Mt5LoginListRespMt5LoginListElemErrorDetailsServerInfoEnvironment string

const Mt5LoginListRespMt5LoginListElemErrorDetailsServerInfoEnvironmentDerivDemo Mt5LoginListRespMt5LoginListElemErrorDetailsServerInfoEnvironment = "Deriv-Demo"
const Mt5LoginListRespMt5LoginListElemErrorDetailsServerInfoEnvironmentDerivServer Mt5LoginListRespMt5LoginListElemErrorDetailsServerInfoEnvironment = "Deriv-Server"
const Mt5LoginListRespMt5LoginListElemErrorDetailsServerInfoEnvironmentDerivServer02 Mt5LoginListRespMt5LoginListElemErrorDetailsServerInfoEnvironment = "Deriv-Server-02"

// Geographical location of the server.
type Mt5LoginListRespMt5LoginListElemErrorDetailsServerInfoGeolocation struct {
	// Internal server grouping.
	Group *string `json:"group,omitempty"`

	// Sever location.
	Location *string `json:"location,omitempty"`

	// Sever region.
	Region *string `json:"region,omitempty"`

	// Sever sequence.
	Sequence *int `json:"sequence,omitempty"`
}

type Mt5LoginListRespMt5LoginListElemLandingCompanyShort string

const Mt5LoginListRespMt5LoginListElemLandingCompanyShortBvi Mt5LoginListRespMt5LoginListElemLandingCompanyShort = "bvi"
const Mt5LoginListRespMt5LoginListElemLandingCompanyShortLabuan Mt5LoginListRespMt5LoginListElemLandingCompanyShort = "labuan"
const Mt5LoginListRespMt5LoginListElemLandingCompanyShortMalta Mt5LoginListRespMt5LoginListElemLandingCompanyShort = "malta"
const Mt5LoginListRespMt5LoginListElemLandingCompanyShortMaltainvest Mt5LoginListRespMt5LoginListElemLandingCompanyShort = "maltainvest"
const Mt5LoginListRespMt5LoginListElemLandingCompanyShortSeychelles Mt5LoginListRespMt5LoginListElemLandingCompanyShort = "seychelles"
const Mt5LoginListRespMt5LoginListElemLandingCompanyShortSvg Mt5LoginListRespMt5LoginListElemLandingCompanyShort = "svg"
const Mt5LoginListRespMt5LoginListElemLandingCompanyShortVanuatu Mt5LoginListRespMt5LoginListElemLandingCompanyShort = "vanuatu"

type Mt5LoginListRespMt5LoginListElemMarketType string

const Mt5LoginListRespMt5LoginListElemMarketTypeAll Mt5LoginListRespMt5LoginListElemMarketType = "all"
const Mt5LoginListRespMt5LoginListElemMarketTypeFinancial Mt5LoginListRespMt5LoginListElemMarketType = "financial"
const Mt5LoginListRespMt5LoginListElemMarketTypeSynthetic Mt5LoginListRespMt5LoginListElemMarketType = "synthetic"

// Trade server information.
type Mt5LoginListRespMt5LoginListElemServerInfo struct {
	// The environment. E.g. Deriv-Server.
	Environment *Mt5LoginListRespMt5LoginListElemServerInfoEnvironment `json:"environment,omitempty"`

	// Geographical location of the server.
	Geolocation *Mt5LoginListRespMt5LoginListElemServerInfoGeolocation `json:"geolocation,omitempty"`

	// Server id.
	Id *string `json:"id,omitempty"`
}

type Mt5LoginListRespMt5LoginListElemServerInfoEnvironment string

const Mt5LoginListRespMt5LoginListElemServerInfoEnvironmentDerivDemo Mt5LoginListRespMt5LoginListElemServerInfoEnvironment = "Deriv-Demo"
const Mt5LoginListRespMt5LoginListElemServerInfoEnvironmentDerivServer Mt5LoginListRespMt5LoginListElemServerInfoEnvironment = "Deriv-Server"
const Mt5LoginListRespMt5LoginListElemServerInfoEnvironmentDerivServer02 Mt5LoginListRespMt5LoginListElemServerInfoEnvironment = "Deriv-Server-02"

// Geographical location of the server.
type Mt5LoginListRespMt5LoginListElemServerInfoGeolocation struct {
	// Internal server grouping.
	Group *string `json:"group,omitempty"`

	// Sever location.
	Location *string `json:"location,omitempty"`

	// Sever region.
	Region *string `json:"region,omitempty"`

	// Sever sequence.
	Sequence *int `json:"sequence,omitempty"`
}

type Mt5LoginListRespMt5LoginListElemSubAccountCategory string

const Mt5LoginListRespMt5LoginListElemSubAccountCategoryBlank Mt5LoginListRespMt5LoginListElemSubAccountCategory = ""
const Mt5LoginListRespMt5LoginListElemSubAccountCategoryIbt Mt5LoginListRespMt5LoginListElemSubAccountCategory = "ibt"
const Mt5LoginListRespMt5LoginListElemSubAccountCategoryStp Mt5LoginListRespMt5LoginListElemSubAccountCategory = "stp"
const Mt5LoginListRespMt5LoginListElemSubAccountCategorySwapFree Mt5LoginListRespMt5LoginListElemSubAccountCategory = "swap_free"
const Mt5LoginListRespMt5LoginListElemSubAccountCategorySwapFreeHighRisk Mt5LoginListRespMt5LoginListElemSubAccountCategory = "swap_free_high_risk"

type Mt5LoginListRespMt5LoginListElemSubAccountType string

const Mt5LoginListRespMt5LoginListElemSubAccountTypeFinancial Mt5LoginListRespMt5LoginListElemSubAccountType = "financial"
const Mt5LoginListRespMt5LoginListElemSubAccountTypeFinancialStp Mt5LoginListRespMt5LoginListElemSubAccountType = "financial_stp"
const Mt5LoginListRespMt5LoginListElemSubAccountTypeStandard Mt5LoginListRespMt5LoginListElemSubAccountType = "standard"

// This call creates new MT5 user, either demo or real money user.
type Mt5NewAccount struct {
	// Account type. If set to 'financial', setting 'mt5_account_type' is also
	// required.
	AccountType Mt5NewAccountAccountType `json:"account_type"`

	// [Optional] The address of the user. The maximum length of this address field is
	// 128 characters.
	Address *string `json:"address,omitempty"`

	// [Optional] User's city of residence.
	City *string `json:"city,omitempty"`

	// [Optional] Name of the client's company. The maximum length of the company name
	// is 64 characters.
	Company *string `json:"company,omitempty"`

	// [Optional] 2-letter country code (value received from `residence_list` call).
	Country *string `json:"country,omitempty"`

	// [Optional] MT5 account currency, the default value will be the qualified
	// account currency.
	Currency *string `json:"currency,omitempty"`

	// [Optional] If set to 1, only validation is performed.
	DryRun Mt5NewAccountDryRun `json:"dry_run,omitempty"`

	// Email address
	Email string `json:"email"`

	// [Optional] The investor password of the account. For validation (Accepts any
	// printable ASCII character. Must be within 8-25 characters, and include numbers,
	// lowercase and uppercase letters. Must not be the same as the user's email
	// address).
	InvestPassword *string `json:"investPassword,omitempty"`

	// Client leverage (from 1 to 1000).
	Leverage float64 `json:"leverage"`

	// The master password of the account. For validation (Accepts any printable ASCII
	// character. Must be within 8-25 characters, and include numbers, lowercase and
	// uppercase letters. Must not be the same as the user's email address). This
	// field is required.
	MainPassword string `json:"mainPassword"`

	// [Optional] To choose whether account is conventional or swap_free. Unavailable
	// for financial_stp MT5_account_type
	Mt5AccountCategory *Mt5NewAccountMt5AccountCategory `json:"mt5_account_category,omitempty"`

	// [Optional] Financial: Variable spreads, High leverage. Financial STP: Variable
	// spreads, Medium Leverage, more products. If 'account_type' set to 'financial',
	// setting 'mt5_account_type' is also required.
	Mt5AccountType *Mt5NewAccountMt5AccountType `json:"mt5_account_type,omitempty"`

	// Must be `1`
	Mt5NewAccount Mt5NewAccountMt5NewAccount `json:"mt5_new_account"`

	// Client's name. The maximum length here is 101 characters.
	Name string `json:"name"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough Mt5NewAccountPassthrough `json:"passthrough,omitempty"`

	// [Optional] User's phone number.
	Phone interface{} `json:"phone,omitempty"`

	// [Optional] The user's phone password.
	PhonePassword *string `json:"phonePassword,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// [Optional] Trade server.
	Server *Mt5NewAccountServer `json:"server,omitempty"`

	// [Optional] User's state (region) of residence.
	State *string `json:"state,omitempty"`

	// [Optional] Indicate the sub account category that we have in the cfd group
	// naming convention.
	SubAccountCategory *Mt5NewAccountSubAccountCategory `json:"sub_account_category,omitempty"`

	// [Optional] User's zip code.
	ZipCode *string `json:"zipCode,omitempty"`
}

type Mt5NewAccountAccountType string

const Mt5NewAccountAccountTypeAll Mt5NewAccountAccountType = "all"
const Mt5NewAccountAccountTypeDemo Mt5NewAccountAccountType = "demo"
const Mt5NewAccountAccountTypeFinancial Mt5NewAccountAccountType = "financial"
const Mt5NewAccountAccountTypeGaming Mt5NewAccountAccountType = "gaming"

type Mt5NewAccountDryRun int

type Mt5NewAccountMt5AccountCategory string

const Mt5NewAccountMt5AccountCategoryConventional Mt5NewAccountMt5AccountCategory = "conventional"
const Mt5NewAccountMt5AccountCategorySwapFree Mt5NewAccountMt5AccountCategory = "swap_free"

type Mt5NewAccountMt5AccountType string

const Mt5NewAccountMt5AccountTypeFinancial Mt5NewAccountMt5AccountType = "financial"
const Mt5NewAccountMt5AccountTypeFinancialStp Mt5NewAccountMt5AccountType = "financial_stp"

type Mt5NewAccountMt5NewAccount int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type Mt5NewAccountPassthrough map[string]interface{}

// Create MT5 account Receive
type Mt5NewAccountResp struct {
	// Echo of the request made.
	EchoReq Mt5NewAccountRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType Mt5NewAccountRespMsgType `json:"msg_type"`

	// New MT5 account details
	Mt5NewAccount *Mt5NewAccountRespMt5NewAccount `json:"mt5_new_account,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type Mt5NewAccountRespEchoReq map[string]interface{}

type Mt5NewAccountRespMsgType string

const Mt5NewAccountRespMsgTypeMt5NewAccount Mt5NewAccountRespMsgType = "mt5_new_account"

// New MT5 account details
type Mt5NewAccountRespMt5NewAccount struct {
	// Account type.
	AccountType *Mt5NewAccountRespMt5NewAccountAccountType `json:"account_type,omitempty"`

	// Agent Details.
	Agent interface{} `json:"agent,omitempty"`

	// Account balance.
	Balance *float64 `json:"balance,omitempty"`

	// MT5 account currency (`USD` or `EUR`) that depends on the MT5 company
	// (`vanuatu`, `svg`, `malta`).
	Currency *string `json:"currency,omitempty"`

	// Account balance, formatted to appropriate decimal places.
	DisplayBalance *string `json:"display_balance,omitempty"`

	// Login ID of the user's new MT5 account. Login could have 2 types of prefixes:
	// MTD, MTR. MTD - for demo accounts and MTR for real money accounts.
	Login *string `json:"login,omitempty"`

	// With default value of conventional, unavailable for `financial_stp` sub account
	// type.
	Mt5AccountCategory *Mt5NewAccountRespMt5NewAccountMt5AccountCategory `json:"mt5_account_category,omitempty"`

	// Sub account type for classic MT5 account.
	Mt5AccountType *Mt5NewAccountRespMt5NewAccountMt5AccountType `json:"mt5_account_type,omitempty"`
}

type Mt5NewAccountRespMt5NewAccountAccountType string

const Mt5NewAccountRespMt5NewAccountAccountTypeAll Mt5NewAccountRespMt5NewAccountAccountType = "all"
const Mt5NewAccountRespMt5NewAccountAccountTypeDemo Mt5NewAccountRespMt5NewAccountAccountType = "demo"
const Mt5NewAccountRespMt5NewAccountAccountTypeFinancial Mt5NewAccountRespMt5NewAccountAccountType = "financial"
const Mt5NewAccountRespMt5NewAccountAccountTypeGaming Mt5NewAccountRespMt5NewAccountAccountType = "gaming"

type Mt5NewAccountRespMt5NewAccountMt5AccountCategory string

const Mt5NewAccountRespMt5NewAccountMt5AccountCategoryConventional Mt5NewAccountRespMt5NewAccountMt5AccountCategory = "conventional"
const Mt5NewAccountRespMt5NewAccountMt5AccountCategorySwapFree Mt5NewAccountRespMt5NewAccountMt5AccountCategory = "swap_free"

type Mt5NewAccountRespMt5NewAccountMt5AccountType string

const Mt5NewAccountRespMt5NewAccountMt5AccountTypeFinancial Mt5NewAccountRespMt5NewAccountMt5AccountType = "financial"
const Mt5NewAccountRespMt5NewAccountMt5AccountTypeFinancialStp Mt5NewAccountRespMt5NewAccountMt5AccountType = "financial_stp"
const Mt5NewAccountRespMt5NewAccountMt5AccountTypeStandard Mt5NewAccountRespMt5NewAccountMt5AccountType = "standard"

type Mt5NewAccountServer string

const Mt5NewAccountServerP01Ts01 Mt5NewAccountServer = "p01_ts01"
const Mt5NewAccountServerP01Ts02 Mt5NewAccountServer = "p01_ts02"
const Mt5NewAccountServerP01Ts03 Mt5NewAccountServer = "p01_ts03"
const Mt5NewAccountServerP01Ts04 Mt5NewAccountServer = "p01_ts04"
const Mt5NewAccountServerP02Ts02 Mt5NewAccountServer = "p02_ts02"

type Mt5NewAccountSubAccountCategory string

const Mt5NewAccountSubAccountCategorySwapFree Mt5NewAccountSubAccountCategory = "swap_free"
const Mt5NewAccountSubAccountCategorySwapFreeHighRisk Mt5NewAccountSubAccountCategory = "swap_free_high_risk"

// To change passwords of the MT5 account.
type Mt5PasswordChange struct {
	// MT5 user login
	Login string `json:"login"`

	// Must be `1`
	Mt5PasswordChange Mt5PasswordChangeMt5PasswordChange `json:"mt5_password_change"`

	// New password of the account. For validation (Accepts any printable ASCII
	// character. Must be within 8-25 characters, and include numbers, lowercase and
	// uppercase letters. Must not be the same as the user's email address).
	NewPassword string `json:"new_password"`

	// Old password for validation (non-empty string, accepts any printable ASCII
	// character)
	OldPassword string `json:"old_password"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough Mt5PasswordChangePassthrough `json:"passthrough,omitempty"`

	// [Optional] Type of the password to change.
	PasswordType Mt5PasswordChangePasswordType `json:"password_type,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type Mt5PasswordChangeMt5PasswordChange int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type Mt5PasswordChangePassthrough map[string]interface{}

type Mt5PasswordChangePasswordType string

const Mt5PasswordChangePasswordTypeInvestor Mt5PasswordChangePasswordType = "investor"
const Mt5PasswordChangePasswordTypeMain Mt5PasswordChangePasswordType = "main"

// MT5 user password change receive
type Mt5PasswordChangeResp struct {
	// Echo of the request made.
	EchoReq Mt5PasswordChangeRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType Mt5PasswordChangeRespMsgType `json:"msg_type"`

	// `1` on success
	Mt5PasswordChange *int `json:"mt5_password_change,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type Mt5PasswordChangeRespEchoReq map[string]interface{}

type Mt5PasswordChangeRespMsgType string

const Mt5PasswordChangeRespMsgTypeMt5PasswordChange Mt5PasswordChangeRespMsgType = "mt5_password_change"

// This call validates the main password for the MT5 user
type Mt5PasswordCheck struct {
	// MT5 user login
	Login string `json:"login"`

	// Must be `1`
	Mt5PasswordCheck Mt5PasswordCheckMt5PasswordCheck `json:"mt5_password_check"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough Mt5PasswordCheckPassthrough `json:"passthrough,omitempty"`

	// The password of the account.
	Password string `json:"password"`

	// [Optional] Type of the password to check.
	PasswordType Mt5PasswordCheckPasswordType `json:"password_type,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type Mt5PasswordCheckMt5PasswordCheck int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type Mt5PasswordCheckPassthrough map[string]interface{}

type Mt5PasswordCheckPasswordType string

const Mt5PasswordCheckPasswordTypeInvestor Mt5PasswordCheckPasswordType = "investor"
const Mt5PasswordCheckPasswordTypeMain Mt5PasswordCheckPasswordType = "main"

// MT5 user password check receive
type Mt5PasswordCheckResp struct {
	// Echo of the request made.
	EchoReq Mt5PasswordCheckRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType Mt5PasswordCheckRespMsgType `json:"msg_type"`

	// `1` on success
	Mt5PasswordCheck *int `json:"mt5_password_check,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type Mt5PasswordCheckRespEchoReq map[string]interface{}

type Mt5PasswordCheckRespMsgType string

const Mt5PasswordCheckRespMsgTypeMt5PasswordCheck Mt5PasswordCheckRespMsgType = "mt5_password_check"

// To reset the password of MT5 account.
type Mt5PasswordReset struct {
	// MT5 user login
	Login string `json:"login"`

	// Must be `1`
	Mt5PasswordReset Mt5PasswordResetMt5PasswordReset `json:"mt5_password_reset"`

	// New password of the account. For validation (Accepts any printable ASCII
	// character. Must be within 8-25 characters, and include numbers, lowercase and
	// uppercase letters. Must not be the same as the user's email address).
	NewPassword string `json:"new_password"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough Mt5PasswordResetPassthrough `json:"passthrough,omitempty"`

	// [Optional] Type of the password to reset.
	PasswordType Mt5PasswordResetPasswordType `json:"password_type,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// Email verification code (received from a `verify_email` call, which must be
	// done first)
	VerificationCode string `json:"verification_code"`
}

type Mt5PasswordResetMt5PasswordReset int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type Mt5PasswordResetPassthrough map[string]interface{}

type Mt5PasswordResetPasswordType string

const Mt5PasswordResetPasswordTypeInvestor Mt5PasswordResetPasswordType = "investor"
const Mt5PasswordResetPasswordTypeMain Mt5PasswordResetPasswordType = "main"

// MT5 user password reset receive
type Mt5PasswordResetResp struct {
	// Echo of the request made.
	EchoReq Mt5PasswordResetRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType Mt5PasswordResetRespMsgType `json:"msg_type"`

	// `1` on success
	Mt5PasswordReset *int `json:"mt5_password_reset,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type Mt5PasswordResetRespEchoReq map[string]interface{}

type Mt5PasswordResetRespMsgType string

const Mt5PasswordResetRespMsgTypeMt5PasswordReset Mt5PasswordResetRespMsgType = "mt5_password_reset"

// This call allows withdrawal from MT5 account to Binary account.
type Mt5Withdrawal struct {
	// Amount to withdraw (in the currency of the MT5 account); min = $1 or an
	// equivalent amount, max = $20000 or an equivalent amount.
	Amount float64 `json:"amount"`

	// MT5 account login to withdraw money from
	FromMt5 string `json:"from_mt5"`

	// Must be `1`
	Mt5Withdrawal Mt5WithdrawalMt5Withdrawal `json:"mt5_withdrawal"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough Mt5WithdrawalPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// Binary account loginid to transfer money to
	ToBinary string `json:"to_binary"`
}

type Mt5WithdrawalMt5Withdrawal int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type Mt5WithdrawalPassthrough map[string]interface{}

// The result of MT5 withdrawal request made.
type Mt5WithdrawalResp struct {
	// Deposit reference ID of Binary account.
	BinaryTransactionId *int `json:"binary_transaction_id,omitempty"`

	// Echo of the request made.
	EchoReq Mt5WithdrawalRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType Mt5WithdrawalRespMsgType `json:"msg_type"`

	// `1` on success
	Mt5Withdrawal *int `json:"mt5_withdrawal,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type Mt5WithdrawalRespEchoReq map[string]interface{}

type Mt5WithdrawalRespMsgType string

const Mt5WithdrawalRespMsgTypeMt5Withdrawal Mt5WithdrawalRespMsgType = "mt5_withdrawal"

// This call opens a new real-money account with the `maltainvest` Landing Company.
// This call can be made from a virtual-money account or real-money account at
// Deriv (Europe) Limited. If it is the latter, client information fields in this
// call will be ignored and data from your existing real-money account will be
// used.
type NewAccountMaltainvest struct {
	// Show whether client has accepted risk disclaimer.
	AcceptRisk *NewAccountMaltainvestAcceptRisk `json:"accept_risk,omitempty"`

	// [Optional] Purpose and reason for requesting the account opening.
	AccountOpeningReason *NewAccountMaltainvestAccountOpeningReason `json:"account_opening_reason,omitempty"`

	// [Optional] The anticipated account turnover.
	AccountTurnover *NewAccountMaltainvestAccountTurnover `json:"account_turnover,omitempty"`

	// Within 100 characters
	AddressCity string `json:"address_city"`

	// Within 70 characters, with no leading whitespaces and may contain
	// letters/numbers and/or any of following characters '.,:;()@#/-
	AddressLine1 string `json:"address_line_1"`

	// [Optional] Within 70 characters.
	AddressLine2 *string `json:"address_line_2,omitempty"`

	// [Optional] Within 20 characters and may not contain '+'.
	AddressPostcode *string `json:"address_postcode,omitempty"`

	// [Optional] Possible value receive from `states_list` call.
	AddressState *string `json:"address_state,omitempty"`

	// [Optional] Affiliate token, within 32 characters.
	AffiliateToken *string `json:"affiliate_token,omitempty"`

	// How much experience do you have in CFD trading?
	CfdExperience *NewAccountMaltainvestCfdExperience `json:"cfd_experience,omitempty"`

	// How many CFD trades have you placed in the past 12 months?
	CfdFrequency *NewAccountMaltainvestCfdFrequency `json:"cfd_frequency,omitempty"`

	// In your understanding, CFD trading allows you to:
	CfdTradingDefinition *NewAccountMaltainvestCfdTradingDefinition `json:"cfd_trading_definition,omitempty"`

	// [Optional] Country of legal citizenship, 2-letter country code. Possible value
	// receive from `residence_list` call.
	Citizen *string `json:"citizen,omitempty"`

	// [Optional] Indicates whether this is for a client requesting an account with
	// professional status.
	ClientType NewAccountMaltainvestClientType `json:"client_type,omitempty"`

	// [Optional] To set currency of the account. List of supported currencies can be
	// acquired with `payout_currencies` call.
	Currency *string `json:"currency,omitempty"`

	// Date of birth format: yyyy-mm-dd.
	DateOfBirth string `json:"date_of_birth"`

	// Level of Education
	EducationLevel *NewAccountMaltainvestEducationLevel `json:"education_level,omitempty"`

	// Industry of Employment.
	EmploymentIndustry *NewAccountMaltainvestEmploymentIndustry `json:"employment_industry,omitempty"`

	// Employment Status.
	EmploymentStatus NewAccountMaltainvestEmploymentStatus `json:"employment_status"`

	// Estimated Net Worth.
	EstimatedWorth *NewAccountMaltainvestEstimatedWorth `json:"estimated_worth,omitempty"`

	// Within 2-50 characters, use only letters, spaces, hyphens, full-stops or
	// apostrophes.
	FirstName string `json:"first_name"`

	// Income Source.
	IncomeSource *NewAccountMaltainvestIncomeSource `json:"income_source,omitempty"`

	// Within 2-50 characters, use only letters, spaces, hyphens, full-stops or
	// apostrophes.
	LastName string `json:"last_name"`

	// How does leverage affect CFD trading?
	LeverageImpactTrading *NewAccountMaltainvestLeverageImpactTrading `json:"leverage_impact_trading,omitempty"`

	// Leverage trading is high-risk, so it's a good idea to use risk management
	// features such as stop loss. Stop loss allows you to
	LeverageTradingHighRiskStopLoss *NewAccountMaltainvestLeverageTradingHighRiskStopLoss `json:"leverage_trading_high_risk_stop_loss,omitempty"`

	// Net Annual Income.
	NetIncome *NewAccountMaltainvestNetIncome `json:"net_income,omitempty"`

	// Must be `1`
	NewAccountMaltainvest NewAccountMaltainvestNewAccountMaltainvest `json:"new_account_maltainvest"`

	// [Optional] Indicates client's self-declaration of not being a PEP/RCA.
	NonPepDeclaration *int `json:"non_pep_declaration,omitempty"`

	// Occupation.
	Occupation *NewAccountMaltainvestOccupation `json:"occupation,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough NewAccountMaltainvestPassthrough `json:"passthrough,omitempty"`

	// [Optional] Starting with `+` followed by 9-35 digits, hyphens or space.
	Phone interface{} `json:"phone,omitempty"`

	// [Optional] Place of birth, 2-letter country code.
	PlaceOfBirth *string `json:"place_of_birth,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// When would you be required to pay an initial margin?
	RequiredInitialMargin *NewAccountMaltainvestRequiredInitialMargin `json:"required_initial_margin,omitempty"`

	// 2-letter country code, possible value receive from `residence_list` call.
	Residence string `json:"residence"`

	// Do you understand that you could potentially lose 100% of the money you use to
	// trade?
	RiskTolerance *NewAccountMaltainvestRiskTolerance `json:"risk_tolerance,omitempty"`

	// Accept any value in enum list.
	Salutation NewAccountMaltainvestSalutation `json:"salutation"`

	// [Optional] Answer to secret question, within 4-50 characters.
	SecretAnswer *string `json:"secret_answer,omitempty"`

	// [Optional] Accept any value in enum list.
	SecretQuestion *NewAccountMaltainvestSecretQuestion `json:"secret_question,omitempty"`

	// How much knowledge and experience do you have in relation to online trading?
	SourceOfExperience *NewAccountMaltainvestSourceOfExperience `json:"source_of_experience,omitempty"`

	// [Optional] Source of wealth.
	SourceOfWealth *NewAccountMaltainvestSourceOfWealth `json:"source_of_wealth,omitempty"`

	// Tax identification number. Only applicable for real money account. Required for
	// `maltainvest` landing company.
	TaxIdentificationNumber string `json:"tax_identification_number"`

	// Residence for tax purpose. Comma separated iso country code if multiple
	// jurisdictions. Only applicable for real money account. Required for
	// `maltainvest` landing company.
	TaxResidence string `json:"tax_residence"`

	// How much experience do you have with other financial instruments?
	TradingExperienceFinancialInstruments *NewAccountMaltainvestTradingExperienceFinancialInstruments `json:"trading_experience_financial_instruments,omitempty"`

	// How many trades have you placed with other financial instruments in the past 12
	// months?
	TradingFrequencyFinancialInstruments *NewAccountMaltainvestTradingFrequencyFinancialInstruments `json:"trading_frequency_financial_instruments,omitempty"`
}

type NewAccountMaltainvestAcceptRisk int

type NewAccountMaltainvestAccountOpeningReason string

const NewAccountMaltainvestAccountOpeningReasonHedging NewAccountMaltainvestAccountOpeningReason = "Hedging"
const NewAccountMaltainvestAccountOpeningReasonIncomeEarning NewAccountMaltainvestAccountOpeningReason = "Income Earning"
const NewAccountMaltainvestAccountOpeningReasonSpeculative NewAccountMaltainvestAccountOpeningReason = "Speculative"

type NewAccountMaltainvestAccountTurnover string

const NewAccountMaltainvestAccountTurnoverA100001500000 NewAccountMaltainvestAccountTurnover = "$100,001 - $500,000"
const NewAccountMaltainvestAccountTurnoverA2500050000 NewAccountMaltainvestAccountTurnover = "$25,000 - $50,000"
const NewAccountMaltainvestAccountTurnoverA50001100000 NewAccountMaltainvestAccountTurnover = "$50,001 - $100,000"
const NewAccountMaltainvestAccountTurnoverLessThan25000 NewAccountMaltainvestAccountTurnover = "Less than $25,000"
const NewAccountMaltainvestAccountTurnoverOver500000 NewAccountMaltainvestAccountTurnover = "Over $500,000"

type NewAccountMaltainvestCfdExperience string

const NewAccountMaltainvestCfdExperienceA12Years NewAccountMaltainvestCfdExperience = "1 - 2 years"
const NewAccountMaltainvestCfdExperienceLessThanAYear NewAccountMaltainvestCfdExperience = "Less than a year"
const NewAccountMaltainvestCfdExperienceNoExperience NewAccountMaltainvestCfdExperience = "No experience"
const NewAccountMaltainvestCfdExperienceOver3Years NewAccountMaltainvestCfdExperience = "Over 3 years"

type NewAccountMaltainvestCfdFrequency string

const NewAccountMaltainvestCfdFrequencyA1139TransactionsInThePast12Months NewAccountMaltainvestCfdFrequency = "11 - 39 transactions in the past 12 months"
const NewAccountMaltainvestCfdFrequencyA15TransactionsInThePast12Months NewAccountMaltainvestCfdFrequency = "1 - 5 transactions in the past 12 months"
const NewAccountMaltainvestCfdFrequencyA40TransactionsOrMoreInThePast12Months NewAccountMaltainvestCfdFrequency = "40 transactions or more in the past 12 months"
const NewAccountMaltainvestCfdFrequencyA610TransactionsInThePast12Months NewAccountMaltainvestCfdFrequency = "6 - 10 transactions in the past 12 months"
const NewAccountMaltainvestCfdFrequencyNoTransactionsInThePast12Months NewAccountMaltainvestCfdFrequency = "No transactions in the past 12 months"

type NewAccountMaltainvestCfdTradingDefinition string

const NewAccountMaltainvestCfdTradingDefinitionMakeALongTermInvestment NewAccountMaltainvestCfdTradingDefinition = "Make a long-term investment."
const NewAccountMaltainvestCfdTradingDefinitionPlaceABetOnThePriceMovement NewAccountMaltainvestCfdTradingDefinition = "Place a bet on the price movement."
const NewAccountMaltainvestCfdTradingDefinitionPurchaseSharesOfACompanyOrPhysicalCommodities NewAccountMaltainvestCfdTradingDefinition = "Purchase shares of a company or physical commodities."
const NewAccountMaltainvestCfdTradingDefinitionSpeculateOnThePriceMovement NewAccountMaltainvestCfdTradingDefinition = "Speculate on the price movement."

type NewAccountMaltainvestClientType string

const NewAccountMaltainvestClientTypeProfessional NewAccountMaltainvestClientType = "professional"
const NewAccountMaltainvestClientTypeRetail NewAccountMaltainvestClientType = "retail"

type NewAccountMaltainvestEducationLevel string

const NewAccountMaltainvestEducationLevelPrimary NewAccountMaltainvestEducationLevel = "Primary"
const NewAccountMaltainvestEducationLevelSecondary NewAccountMaltainvestEducationLevel = "Secondary"
const NewAccountMaltainvestEducationLevelTertiary NewAccountMaltainvestEducationLevel = "Tertiary"

type NewAccountMaltainvestEmploymentIndustry string

const NewAccountMaltainvestEmploymentIndustryAgriculture NewAccountMaltainvestEmploymentIndustry = "Agriculture"
const NewAccountMaltainvestEmploymentIndustryConstruction NewAccountMaltainvestEmploymentIndustry = "Construction"
const NewAccountMaltainvestEmploymentIndustryEducation NewAccountMaltainvestEmploymentIndustry = "Education"
const NewAccountMaltainvestEmploymentIndustryFinance NewAccountMaltainvestEmploymentIndustry = "Finance"
const NewAccountMaltainvestEmploymentIndustryFoodServices NewAccountMaltainvestEmploymentIndustry = "Food Services"
const NewAccountMaltainvestEmploymentIndustryHealth NewAccountMaltainvestEmploymentIndustry = "Health"
const NewAccountMaltainvestEmploymentIndustryInformationCommunicationsTechnology NewAccountMaltainvestEmploymentIndustry = "Information & Communications Technology"
const NewAccountMaltainvestEmploymentIndustryLegal NewAccountMaltainvestEmploymentIndustry = "Legal"
const NewAccountMaltainvestEmploymentIndustryManufacturing NewAccountMaltainvestEmploymentIndustry = "Manufacturing"
const NewAccountMaltainvestEmploymentIndustryRealEstate NewAccountMaltainvestEmploymentIndustry = "Real Estate"
const NewAccountMaltainvestEmploymentIndustryScienceEngineering NewAccountMaltainvestEmploymentIndustry = "Science & Engineering"
const NewAccountMaltainvestEmploymentIndustrySocialCultural NewAccountMaltainvestEmploymentIndustry = "Social & Cultural"
const NewAccountMaltainvestEmploymentIndustryTourism NewAccountMaltainvestEmploymentIndustry = "Tourism"
const NewAccountMaltainvestEmploymentIndustryUnemployed NewAccountMaltainvestEmploymentIndustry = "Unemployed"

type NewAccountMaltainvestEmploymentStatus string

const NewAccountMaltainvestEmploymentStatusEmployed NewAccountMaltainvestEmploymentStatus = "Employed"
const NewAccountMaltainvestEmploymentStatusPensioner NewAccountMaltainvestEmploymentStatus = "Pensioner"
const NewAccountMaltainvestEmploymentStatusSelfEmployed NewAccountMaltainvestEmploymentStatus = "Self-Employed"
const NewAccountMaltainvestEmploymentStatusStudent NewAccountMaltainvestEmploymentStatus = "Student"
const NewAccountMaltainvestEmploymentStatusUnemployed NewAccountMaltainvestEmploymentStatus = "Unemployed"

type NewAccountMaltainvestEstimatedWorth string

const NewAccountMaltainvestEstimatedWorthA100000250000 NewAccountMaltainvestEstimatedWorth = "$100,000 - $250,000"
const NewAccountMaltainvestEstimatedWorthA250001500000 NewAccountMaltainvestEstimatedWorth = "$250,001 - $500,000"
const NewAccountMaltainvestEstimatedWorthA5000011000000 NewAccountMaltainvestEstimatedWorth = "$500,001 - $1,000,000"
const NewAccountMaltainvestEstimatedWorthLessThan100000 NewAccountMaltainvestEstimatedWorth = "Less than $100,000"
const NewAccountMaltainvestEstimatedWorthOver1000000 NewAccountMaltainvestEstimatedWorth = "Over $1,000,000"

type NewAccountMaltainvestIncomeSource string

const NewAccountMaltainvestIncomeSourceInvestmentsDividends NewAccountMaltainvestIncomeSource = "Investments & Dividends"
const NewAccountMaltainvestIncomeSourcePension NewAccountMaltainvestIncomeSource = "Pension"
const NewAccountMaltainvestIncomeSourceSalariedEmployee NewAccountMaltainvestIncomeSource = "Salaried Employee"
const NewAccountMaltainvestIncomeSourceSavingsInheritance NewAccountMaltainvestIncomeSource = "Savings & Inheritance"
const NewAccountMaltainvestIncomeSourceSelfEmployed NewAccountMaltainvestIncomeSource = "Self-Employed"
const NewAccountMaltainvestIncomeSourceStateBenefits NewAccountMaltainvestIncomeSource = "State Benefits"

type NewAccountMaltainvestLeverageImpactTrading string

const NewAccountMaltainvestLeverageImpactTradingLeverageGuaranteesProfits NewAccountMaltainvestLeverageImpactTrading = "Leverage guarantees profits."
const NewAccountMaltainvestLeverageImpactTradingLeverageIsARiskMitigationTechnique NewAccountMaltainvestLeverageImpactTrading = "Leverage is a risk mitigation technique."
const NewAccountMaltainvestLeverageImpactTradingLeverageLetsYouOpenLargerPositionsForAFractionOfTheTradeSValue NewAccountMaltainvestLeverageImpactTrading = "Leverage lets you open larger positions for a fraction of the trade's value."
const NewAccountMaltainvestLeverageImpactTradingLeveragePreventsYouFromOpeningLargePositions NewAccountMaltainvestLeverageImpactTrading = "Leverage prevents you from opening large positions."

type NewAccountMaltainvestLeverageTradingHighRiskStopLoss string

const NewAccountMaltainvestLeverageTradingHighRiskStopLossCancelYourTradeAtAnyTimeWithinAChosenTimeframe NewAccountMaltainvestLeverageTradingHighRiskStopLoss = "Cancel your trade at any time within a chosen timeframe."
const NewAccountMaltainvestLeverageTradingHighRiskStopLossCloseYourTradeAutomaticallyWhenTheLossIsMoreThanOrEqualToASpecificAmount NewAccountMaltainvestLeverageTradingHighRiskStopLoss = "Close your trade automatically when the loss is more than or equal to a specific amount."
const NewAccountMaltainvestLeverageTradingHighRiskStopLossCloseYourTradeAutomaticallyWhenTheProfitIsMoreThanOrEqualToASpecificAmount NewAccountMaltainvestLeverageTradingHighRiskStopLoss = "Close your trade automatically when the profit is more than or equal to a specific amount."
const NewAccountMaltainvestLeverageTradingHighRiskStopLossMakeAGuaranteedProfitOnYourTrade NewAccountMaltainvestLeverageTradingHighRiskStopLoss = "Make a guaranteed profit on your trade."

type NewAccountMaltainvestNetIncome string

const NewAccountMaltainvestNetIncomeA100001500000 NewAccountMaltainvestNetIncome = "$100,001 - $500,000"
const NewAccountMaltainvestNetIncomeA2500050000 NewAccountMaltainvestNetIncome = "$25,000 - $50,000"
const NewAccountMaltainvestNetIncomeA50001100000 NewAccountMaltainvestNetIncome = "$50,001 - $100,000"
const NewAccountMaltainvestNetIncomeLessThan25000 NewAccountMaltainvestNetIncome = "Less than $25,000"
const NewAccountMaltainvestNetIncomeOver500000 NewAccountMaltainvestNetIncome = "Over $500,000"

type NewAccountMaltainvestNewAccountMaltainvest int

type NewAccountMaltainvestOccupation string

const NewAccountMaltainvestOccupationAgriculturalForestryAndFisheryWorkers NewAccountMaltainvestOccupation = "Agricultural, Forestry and Fishery Workers"
const NewAccountMaltainvestOccupationArmedForces NewAccountMaltainvestOccupation = "Armed Forces"
const NewAccountMaltainvestOccupationChiefExecutivesSeniorOfficialsAndLegislators NewAccountMaltainvestOccupation = "Chief Executives, Senior Officials and Legislators"
const NewAccountMaltainvestOccupationCleanersAndHelpers NewAccountMaltainvestOccupation = "Cleaners and Helpers"
const NewAccountMaltainvestOccupationClerks NewAccountMaltainvestOccupation = "Clerks"
const NewAccountMaltainvestOccupationCraftMetalElectricalAndElectronicsWorkers NewAccountMaltainvestOccupation = "Craft, Metal, Electrical and Electronics Workers"
const NewAccountMaltainvestOccupationGovernmentOfficers NewAccountMaltainvestOccupation = "Government Officers"
const NewAccountMaltainvestOccupationManagers NewAccountMaltainvestOccupation = "Managers"
const NewAccountMaltainvestOccupationMiningConstructionManufacturingAndTransportWorkers NewAccountMaltainvestOccupation = "Mining, Construction, Manufacturing and Transport Workers"
const NewAccountMaltainvestOccupationPersonalCareSalesAndServiceWorkers NewAccountMaltainvestOccupation = "Personal Care, Sales and Service Workers"
const NewAccountMaltainvestOccupationPlantAndMachineOperatorsAndAssemblers NewAccountMaltainvestOccupation = "Plant and Machine Operators and Assemblers"
const NewAccountMaltainvestOccupationProfessionals NewAccountMaltainvestOccupation = "Professionals"
const NewAccountMaltainvestOccupationStudents NewAccountMaltainvestOccupation = "Students"
const NewAccountMaltainvestOccupationUnemployed NewAccountMaltainvestOccupation = "Unemployed"

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type NewAccountMaltainvestPassthrough map[string]interface{}

type NewAccountMaltainvestRequiredInitialMargin string

const NewAccountMaltainvestRequiredInitialMarginAllOfTheAbove NewAccountMaltainvestRequiredInitialMargin = "All of the above."
const NewAccountMaltainvestRequiredInitialMarginWhenBuyingSharesOfACompany NewAccountMaltainvestRequiredInitialMargin = "When buying shares of a company."
const NewAccountMaltainvestRequiredInitialMarginWhenOpeningALeveragedCFDTrade NewAccountMaltainvestRequiredInitialMargin = "When opening a Leveraged CFD trade."
const NewAccountMaltainvestRequiredInitialMarginWhenTradingMultipliers NewAccountMaltainvestRequiredInitialMargin = "When trading Multipliers."

// Create maltainvest account Receive
type NewAccountMaltainvestResp struct {
	// Echo of the request made.
	EchoReq NewAccountMaltainvestRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType NewAccountMaltainvestRespMsgType `json:"msg_type"`

	// New `maltainvest` account details
	NewAccountMaltainvest *NewAccountMaltainvestRespNewAccountMaltainvest `json:"new_account_maltainvest,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type NewAccountMaltainvestRespEchoReq map[string]interface{}

type NewAccountMaltainvestRespMsgType string

const NewAccountMaltainvestRespMsgTypeNewAccountMaltainvest NewAccountMaltainvestRespMsgType = "new_account_maltainvest"

// New `maltainvest` account details
type NewAccountMaltainvestRespNewAccountMaltainvest struct {
	// Client ID of new `maltainvest` account
	ClientId string `json:"client_id"`

	// Landing company full name
	LandingCompany string `json:"landing_company"`

	// Landing company shortcode
	LandingCompanyShort *string `json:"landing_company_short,omitempty"`

	// Landing company shortcode
	LandingCompanyShortcode *string `json:"landing_company_shortcode,omitempty"`

	// OAuth token for client's login session
	OauthToken string `json:"oauth_token"`
}

type NewAccountMaltainvestRiskTolerance string

const NewAccountMaltainvestRiskToleranceNo NewAccountMaltainvestRiskTolerance = "No"
const NewAccountMaltainvestRiskToleranceYes NewAccountMaltainvestRiskTolerance = "Yes"

type NewAccountMaltainvestSalutation string

const NewAccountMaltainvestSalutationMiss NewAccountMaltainvestSalutation = "Miss"
const NewAccountMaltainvestSalutationMr NewAccountMaltainvestSalutation = "Mr"
const NewAccountMaltainvestSalutationMrs NewAccountMaltainvestSalutation = "Mrs"
const NewAccountMaltainvestSalutationMs NewAccountMaltainvestSalutation = "Ms"

type NewAccountMaltainvestSecretQuestion string

const NewAccountMaltainvestSecretQuestionBrandOfFirstCar NewAccountMaltainvestSecretQuestion = "Brand of first car"
const NewAccountMaltainvestSecretQuestionFavouriteArtist NewAccountMaltainvestSecretQuestion = "Favourite artist"
const NewAccountMaltainvestSecretQuestionFavouriteDish NewAccountMaltainvestSecretQuestion = "Favourite dish"
const NewAccountMaltainvestSecretQuestionMemorableDate NewAccountMaltainvestSecretQuestion = "Memorable date"
const NewAccountMaltainvestSecretQuestionMemorableTownCity NewAccountMaltainvestSecretQuestion = "Memorable town/city"
const NewAccountMaltainvestSecretQuestionMotherSMaidenName NewAccountMaltainvestSecretQuestion = "Mother's maiden name"
const NewAccountMaltainvestSecretQuestionNameOfFirstLove NewAccountMaltainvestSecretQuestion = "Name of first love"
const NewAccountMaltainvestSecretQuestionNameOfYourPet NewAccountMaltainvestSecretQuestion = "Name of your pet"

type NewAccountMaltainvestSourceOfExperience string

const NewAccountMaltainvestSourceOfExperienceIHaveAnAcademicDegreeProfessionalCertificationAndOrWorkExperience NewAccountMaltainvestSourceOfExperience = "I have an academic degree, professional certification, and/or work experience."
const NewAccountMaltainvestSourceOfExperienceIHaveAttendedSeminarsTrainingAndOrWorkshops NewAccountMaltainvestSourceOfExperience = "I have attended seminars, training, and/or workshops."
const NewAccountMaltainvestSourceOfExperienceIHaveLittleExperience NewAccountMaltainvestSourceOfExperience = "I have little experience."
const NewAccountMaltainvestSourceOfExperienceIHaveNoKnowledge NewAccountMaltainvestSourceOfExperience = "I have no knowledge."
const NewAccountMaltainvestSourceOfExperienceITradeForexCFDsAndOtherComplexFinancialInstruments NewAccountMaltainvestSourceOfExperience = "I trade forex CFDs and other complex financial instruments."

type NewAccountMaltainvestSourceOfWealth string

const NewAccountMaltainvestSourceOfWealthAccumulationOfIncomeSavings NewAccountMaltainvestSourceOfWealth = "Accumulation of Income/Savings"
const NewAccountMaltainvestSourceOfWealthCashBusiness NewAccountMaltainvestSourceOfWealth = "Cash Business"
const NewAccountMaltainvestSourceOfWealthCompanyOwnership NewAccountMaltainvestSourceOfWealth = "Company Ownership"
const NewAccountMaltainvestSourceOfWealthDivorceSettlement NewAccountMaltainvestSourceOfWealth = "Divorce Settlement"
const NewAccountMaltainvestSourceOfWealthInheritance NewAccountMaltainvestSourceOfWealth = "Inheritance"
const NewAccountMaltainvestSourceOfWealthInvestmentIncome NewAccountMaltainvestSourceOfWealth = "Investment Income"
const NewAccountMaltainvestSourceOfWealthSaleOfProperty NewAccountMaltainvestSourceOfWealth = "Sale of Property"

type NewAccountMaltainvestTradingExperienceFinancialInstruments string

const NewAccountMaltainvestTradingExperienceFinancialInstrumentsA12Years NewAccountMaltainvestTradingExperienceFinancialInstruments = "1 - 2 years"
const NewAccountMaltainvestTradingExperienceFinancialInstrumentsLessThanAYear NewAccountMaltainvestTradingExperienceFinancialInstruments = "Less than a year"
const NewAccountMaltainvestTradingExperienceFinancialInstrumentsNoExperience NewAccountMaltainvestTradingExperienceFinancialInstruments = "No experience"
const NewAccountMaltainvestTradingExperienceFinancialInstrumentsOver3Years NewAccountMaltainvestTradingExperienceFinancialInstruments = "Over 3 years"

type NewAccountMaltainvestTradingFrequencyFinancialInstruments string

const NewAccountMaltainvestTradingFrequencyFinancialInstrumentsA1139TransactionsInThePast12Months NewAccountMaltainvestTradingFrequencyFinancialInstruments = "11 - 39 transactions in the past 12 months"
const NewAccountMaltainvestTradingFrequencyFinancialInstrumentsA15TransactionsInThePast12Months NewAccountMaltainvestTradingFrequencyFinancialInstruments = "1 - 5 transactions in the past 12 months"
const NewAccountMaltainvestTradingFrequencyFinancialInstrumentsA40TransactionsOrMoreInThePast12Months NewAccountMaltainvestTradingFrequencyFinancialInstruments = "40 transactions or more in the past 12 months"
const NewAccountMaltainvestTradingFrequencyFinancialInstrumentsA610TransactionsInThePast12Months NewAccountMaltainvestTradingFrequencyFinancialInstruments = "6 - 10 transactions in the past 12 months"
const NewAccountMaltainvestTradingFrequencyFinancialInstrumentsNoTransactionsInThePast12Months NewAccountMaltainvestTradingFrequencyFinancialInstruments = "No transactions in the past 12 months"

// This call opens a new real-money account. This call can be made from a
// virtual-money or a real-money account. If it is the latter, client information
// fields in this call will be ignored and data from your existing real-money
// account will be used.
type NewAccountReal struct {
	// [Optional] Purpose and reason for requesting the account opening.
	AccountOpeningReason *NewAccountRealAccountOpeningReason `json:"account_opening_reason,omitempty"`

	// [Optional] The anticipated account turnover.
	AccountTurnover *NewAccountRealAccountTurnover `json:"account_turnover,omitempty"`

	// [Optional] Within 100 characters.
	AddressCity *string `json:"address_city,omitempty"`

	// Within 70 characters, with no leading whitespaces and may contain
	// letters/numbers and/or any of following characters '.,:;()@#/-
	AddressLine1 *string `json:"address_line_1,omitempty"`

	// [Optional] Within 70 characters.
	AddressLine2 *string `json:"address_line_2,omitempty"`

	// [Optional] Within 20 characters and may not contain '+'.
	AddressPostcode *string `json:"address_postcode,omitempty"`

	// [Optional] Possible value receive from `states_list` call.
	AddressState *string `json:"address_state,omitempty"`

	// [Optional] Affiliate token, within 32 characters.
	AffiliateToken *string `json:"affiliate_token,omitempty"`

	// [Optional] Country of legal citizenship, 2-letter country code.
	Citizen interface{} `json:"citizen,omitempty"`

	// [Optional] Indicates whether this is for a client requesting an account with
	// professional status.
	ClientType NewAccountRealClientType `json:"client_type,omitempty"`

	// [Optional] To set currency of the account. List of supported currencies can be
	// acquired with `payout_currencies` call.
	Currency *string `json:"currency,omitempty"`

	// Date of birth format: `yyyy-mm-dd`.
	DateOfBirth *string `json:"date_of_birth,omitempty"`

	// Within 2-50 characters, use only letters, spaces, hyphens, full-stops or
	// apostrophes.
	FirstName *string `json:"first_name,omitempty"`

	// Within 2-50 characters, use only letters, spaces, hyphens, full-stops or
	// apostrophes.
	LastName *string `json:"last_name,omitempty"`

	// Must be `1`
	NewAccountReal NewAccountRealNewAccountReal `json:"new_account_real"`

	// [Optional] Indicates client's self-declaration of not being a PEP/RCA
	// (Politically Exposed Person/Relatives and Close Associates).
	NonPepDeclaration *int `json:"non_pep_declaration,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough NewAccountRealPassthrough `json:"passthrough,omitempty"`

	// [Optional] Starting with `+` followed by 9-35 digits, hyphens or space.
	Phone interface{} `json:"phone,omitempty"`

	// [Optional] Place of birth, 2-letter country code.
	PlaceOfBirth *string `json:"place_of_birth,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// 2-letter country code, possible value receive from `residence_list` call.
	Residence *string `json:"residence,omitempty"`

	// [Optional] Accept any value in enum list.
	Salutation *NewAccountRealSalutation `json:"salutation,omitempty"`

	// [Optional] Answer to secret question, within 4-50 characters. Required for new
	// account and existing client details will be used if client open another
	// account.
	SecretAnswer *string `json:"secret_answer,omitempty"`

	// [Optional] Accept any value in enum list. Required for new account and existing
	// client details will be used if client open another account.
	SecretQuestion *NewAccountRealSecretQuestion `json:"secret_question,omitempty"`

	// [Optional] Tax identification number. Only applicable for real money account.
	// Required for `maltainvest` landing company.
	TaxIdentificationNumber *string `json:"tax_identification_number,omitempty"`

	// [Optional] Residence for tax purpose. Comma separated iso country code if
	// multiple jurisdictions. Only applicable for real money account. Required for
	// `maltainvest` landing company.
	TaxResidence *string `json:"tax_residence,omitempty"`
}

type NewAccountRealAccountOpeningReason string

const NewAccountRealAccountOpeningReasonHedging NewAccountRealAccountOpeningReason = "Hedging"
const NewAccountRealAccountOpeningReasonIncomeEarning NewAccountRealAccountOpeningReason = "Income Earning"
const NewAccountRealAccountOpeningReasonPeerToPeerExchange NewAccountRealAccountOpeningReason = "Peer-to-peer exchange"
const NewAccountRealAccountOpeningReasonSpeculative NewAccountRealAccountOpeningReason = "Speculative"

type NewAccountRealAccountTurnover string

const NewAccountRealAccountTurnoverA100001500000 NewAccountRealAccountTurnover = "$100,001 - $500,000"
const NewAccountRealAccountTurnoverA2500050000 NewAccountRealAccountTurnover = "$25,000 - $50,000"
const NewAccountRealAccountTurnoverA50001100000 NewAccountRealAccountTurnover = "$50,001 - $100,000"
const NewAccountRealAccountTurnoverLessThan25000 NewAccountRealAccountTurnover = "Less than $25,000"
const NewAccountRealAccountTurnoverOver500000 NewAccountRealAccountTurnover = "Over $500,000"

type NewAccountRealClientType string

const NewAccountRealClientTypeProfessional NewAccountRealClientType = "professional"
const NewAccountRealClientTypeRetail NewAccountRealClientType = "retail"

type NewAccountRealNewAccountReal int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type NewAccountRealPassthrough map[string]interface{}

// Create real account Receive
type NewAccountRealResp struct {
	// Echo of the request made.
	EchoReq NewAccountRealRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType NewAccountRealRespMsgType `json:"msg_type"`

	// New real money account details
	NewAccountReal *NewAccountRealRespNewAccountReal `json:"new_account_real,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type NewAccountRealRespEchoReq map[string]interface{}

type NewAccountRealRespMsgType string

const NewAccountRealRespMsgTypeNewAccountReal NewAccountRealRespMsgType = "new_account_real"

// New real money account details
type NewAccountRealRespNewAccountReal struct {
	// Client ID of new real money account
	ClientId string `json:"client_id"`

	// Currency of an account
	Currency *string `json:"currency,omitempty"`

	// Landing company full name
	LandingCompany string `json:"landing_company"`

	// Landing company shortcode
	LandingCompanyShort *string `json:"landing_company_short,omitempty"`

	// Landing company shortcode
	LandingCompanyShortcode *string `json:"landing_company_shortcode,omitempty"`

	// OAuth token for client's login session
	OauthToken string `json:"oauth_token"`
}

type NewAccountRealSalutation string

const NewAccountRealSalutationMiss NewAccountRealSalutation = "Miss"
const NewAccountRealSalutationMr NewAccountRealSalutation = "Mr"
const NewAccountRealSalutationMrs NewAccountRealSalutation = "Mrs"
const NewAccountRealSalutationMs NewAccountRealSalutation = "Ms"

type NewAccountRealSecretQuestion string

const NewAccountRealSecretQuestionBrandOfFirstCar NewAccountRealSecretQuestion = "Brand of first car"
const NewAccountRealSecretQuestionFavouriteArtist NewAccountRealSecretQuestion = "Favourite artist"
const NewAccountRealSecretQuestionFavouriteDish NewAccountRealSecretQuestion = "Favourite dish"
const NewAccountRealSecretQuestionMemorableDate NewAccountRealSecretQuestion = "Memorable date"
const NewAccountRealSecretQuestionMemorableTownCity NewAccountRealSecretQuestion = "Memorable town/city"
const NewAccountRealSecretQuestionMotherSMaidenName NewAccountRealSecretQuestion = "Mother's maiden name"
const NewAccountRealSecretQuestionNameOfFirstLove NewAccountRealSecretQuestion = "Name of first love"
const NewAccountRealSecretQuestionNameOfYourPet NewAccountRealSecretQuestion = "Name of your pet"

// Create a new virtual-money account.
type NewAccountVirtual struct {
	// [Optional] Affiliate token, within 32 characters.
	AffiliateToken *string `json:"affiliate_token,omitempty"`

	// Password (Accepts any printable ASCII character. Must be within 8-25
	// characters, and include numbers, lowercase and uppercase letters. Must not be
	// the same as the user's email address).
	ClientPassword *string `json:"client_password,omitempty"`

	// [Optional] Date of first contact, format: `yyyy-mm-dd` in GMT timezone.
	DateFirstContact *string `json:"date_first_contact,omitempty"`

	// [Optional] Boolean value: 1 or 0, indicating whether the client has given
	// consent for marketing emails.
	EmailConsent *NewAccountVirtualEmailConsent `json:"email_consent,omitempty"`

	// [Optional] Google Click Identifier to track source.
	GclidUrl *string `json:"gclid_url,omitempty"`

	// Must be `1`
	NewAccountVirtual NewAccountVirtualNewAccountVirtual `json:"new_account_virtual"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough NewAccountVirtualPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// 2-letter country code (obtained from `residence_list` call).
	Residence *string `json:"residence,omitempty"`

	// [Optional] Show whether user has used mobile or desktop.
	SignupDevice *NewAccountVirtualSignupDevice `json:"signup_device,omitempty"`

	// Account type
	Type NewAccountVirtualType `json:"type,omitempty"`

	// [Optional] Identifier of particular ad. Value must match Regex pattern to be
	// recorded
	UtmAdId interface{} `json:"utm_ad_id,omitempty"`

	// [Optional] Identifier of ad group in the campaign. Value must match Regex
	// pattern to be recorded
	UtmAdgroupId interface{} `json:"utm_adgroup_id,omitempty"`

	// [Optional] Unique identifier of click on AdRoll ads platform. Value must match
	// Regex pattern to be recorded
	UtmAdrollclkId interface{} `json:"utm_adrollclk_id,omitempty"`

	// [Optional] Identifies a specific product promotion or strategic campaign such
	// as a spring sale or other promotions. Value must match Regex pattern to be
	// recorded
	UtmCampaign interface{} `json:"utm_campaign,omitempty"`

	// [Optional] Identifier of paid ad campaign. Value must match Regex pattern to be
	// recorded
	UtmCampaignId interface{} `json:"utm_campaign_id,omitempty"`

	// [Optional] Used to differentiate similar content, or links within the same ad.
	// Value must match Regex pattern to be recorded
	UtmContent interface{} `json:"utm_content,omitempty"`

	// [Optional] Unique identifier of click on Facebook ads platform. Value must
	// match Regex pattern to be recorded
	UtmFbclId interface{} `json:"utm_fbcl_id,omitempty"`

	// [Optional] Unique visitor identifier on Google Ads platform. Value must match
	// Regex pattern to be recorded
	UtmGlClientId interface{} `json:"utm_gl_client_id,omitempty"`

	// [Optional] Identifies the medium the link was used upon such as: email, CPC, or
	// other methods of sharing. Value must match Regex pattern to be recorded
	UtmMedium interface{} `json:"utm_medium,omitempty"`

	// [Optional] Unique click identifier on Microsoft Bing ads platform. Value must
	// match Regex pattern to be recorded
	UtmMsclkId interface{} `json:"utm_msclk_id,omitempty"`

	// [Optional] Identifies the source of traffic such as: search engine, newsletter,
	// or other referral. Value must match Regex pattern to be recorded
	UtmSource interface{} `json:"utm_source,omitempty"`

	// [Optional] Used to send information related to the campaign term like paid
	// search keywords. Value must match Regex pattern to be recorded
	UtmTerm interface{} `json:"utm_term,omitempty"`

	// Email verification code (received from a `verify_email` call, which must be
	// done first).
	VerificationCode *string `json:"verification_code,omitempty"`
}

type NewAccountVirtualEmailConsent int

type NewAccountVirtualNewAccountVirtual int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type NewAccountVirtualPassthrough map[string]interface{}

// Create virtual-money account
type NewAccountVirtualResp struct {
	// Echo of the request made.
	EchoReq NewAccountVirtualRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType NewAccountVirtualRespMsgType `json:"msg_type"`

	// New virtual-money account details
	NewAccountVirtual *NewAccountVirtualRespNewAccountVirtual `json:"new_account_virtual,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type NewAccountVirtualRespEchoReq map[string]interface{}

type NewAccountVirtualRespMsgType string

const NewAccountVirtualRespMsgTypeNewAccountVirtual NewAccountVirtualRespMsgType = "new_account_virtual"

// New virtual-money account details
type NewAccountVirtualRespNewAccountVirtual struct {
	// Account balance
	Balance float64 `json:"balance"`

	// ID of the new virtual-money account
	ClientId string `json:"client_id"`

	// Account currency
	Currency string `json:"currency"`

	// Email of the new virtual-money account
	Email string `json:"email"`

	// Oauth token for the client's login session (so that the user may be logged in
	// immediately)
	OauthToken string `json:"oauth_token"`

	// Refresh token to perform PTA, only for the first ever created account
	RefreshToken *string `json:"refresh_token,omitempty"`

	// Account type
	Type *NewAccountVirtualRespNewAccountVirtualType `json:"type,omitempty"`
}

type NewAccountVirtualRespNewAccountVirtualType string

const NewAccountVirtualRespNewAccountVirtualTypeTrading NewAccountVirtualRespNewAccountVirtualType = "trading"
const NewAccountVirtualRespNewAccountVirtualTypeWallet NewAccountVirtualRespNewAccountVirtualType = "wallet"

type NewAccountVirtualSignupDevice string

const NewAccountVirtualSignupDeviceDesktop NewAccountVirtualSignupDevice = "desktop"
const NewAccountVirtualSignupDeviceMobile NewAccountVirtualSignupDevice = "mobile"

type NewAccountVirtualType string

const NewAccountVirtualTypeTrading NewAccountVirtualType = "trading"
const NewAccountVirtualTypeWallet NewAccountVirtualType = "wallet"

// List all my used OAuth applications.
type OauthApps struct {
	// Must be `1`
	OauthApps OauthAppsOauthApps `json:"oauth_apps"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough OauthAppsPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type OauthAppsOauthApps int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type OauthAppsPassthrough map[string]interface{}

// A message with used applications
type OauthAppsResp struct {
	// Echo of the request made.
	EchoReq OauthAppsRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType OauthAppsRespMsgType `json:"msg_type"`

	// List of 3rd party OAuth applications that used for the authorized account.
	OauthApps []OauthAppsRespOauthAppsElem `json:"oauth_apps,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type OauthAppsRespEchoReq map[string]interface{}

type OauthAppsRespMsgType string

const OauthAppsRespMsgTypeOauthApps OauthAppsRespMsgType = "oauth_apps"

type OauthAppsRespOauthAppsElem struct {
	// Application ID.
	AppId int `json:"app_id"`

	// Markup added to contract prices (as a percentage of contract payout)
	AppMarkupPercentage float64 `json:"app_markup_percentage"`

	// The last date which the application has been used.
	LastUsed interface{} `json:"last_used"`

	// Application name
	Name string `json:"name"`

	// Boolean value: 1 or 0, indicating 1 if app is an official app and 0 incase of
	// unofficial app
	Official OauthAppsRespOauthAppsElemOfficial `json:"official"`

	// The list of permission scopes grant for each app.
	Scopes []string `json:"scopes"`
}

type OauthAppsRespOauthAppsElemOfficial int

// Creates a P2P (Peer to Peer) advert. Can only be used by an approved P2P
// advertiser.
type P2PAdvertCreate struct {
	// The total amount of the advert, in advertiser's account currency.
	Amount float64 `json:"amount"`

	// [Optional] Indicates if this is block trade ad or not. Default: 0.
	BlockTrade P2PAdvertCreateBlockTrade `json:"block_trade,omitempty"`

	// [Optional] Advertiser contact information.
	ContactInfo *string `json:"contact_info,omitempty"`

	// [Optional] General information about the advert.
	Description *string `json:"description,omitempty"`

	// [Optional] Local currency for this advert. If not provided, will use the
	// currency of client's residence by default.
	LocalCurrency *string `json:"local_currency,omitempty"`

	// Maximum allowed amount for the orders of this advert, in advertiser's
	// `account_currency`. Should be more than or equal to `min_order_amount`
	MaxOrderAmount float64 `json:"max_order_amount"`

	// Minimum allowed amount for the orders of this advert, in advertiser's
	// `account_currency`. Should be less than or equal to `max_order_amount`.
	MinOrderAmount float64 `json:"min_order_amount"`

	// Must be 1
	P2PAdvertCreate P2PAdvertCreateP2PAdvertCreate `json:"p2p_advert_create"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough P2PAdvertCreatePassthrough `json:"passthrough,omitempty"`

	// [Optional] Payment instructions.
	PaymentInfo *string `json:"payment_info,omitempty"`

	// [Optional] Payment method name (deprecated).
	PaymentMethod *string `json:"payment_method,omitempty"`

	// IDs of previously saved payment methods as returned from
	// p2p_advertiser_payment_methods, only applicable for sell ads.
	PaymentMethodIds []int `json:"payment_method_ids,omitempty"`

	// Payment method identifiers as returned from p2p_payment_methods, only
	// applicable for buy ads.
	PaymentMethodNames []string `json:"payment_method_names,omitempty"`

	// Conversion rate from advertiser's account currency to `local_currency`. An
	// absolute rate value (fixed), or percentage offset from current market rate
	// (floating).
	Rate float64 `json:"rate"`

	// Type of rate, fixed or floating.
	RateType P2PAdvertCreateRateType `json:"rate_type,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// The advertisement represents the intention to perform this action on your Deriv
	// account funds.
	Type P2PAdvertCreateType `json:"type"`
}

type P2PAdvertCreateBlockTrade int

type P2PAdvertCreateP2PAdvertCreate int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type P2PAdvertCreatePassthrough map[string]interface{}

type P2PAdvertCreateRateType string

const P2PAdvertCreateRateTypeFixed P2PAdvertCreateRateType = "fixed"
const P2PAdvertCreateRateTypeFloat P2PAdvertCreateRateType = "float"

// Returns the information of the created  P2P (Peer to Peer) advert.
type P2PAdvertCreateResp struct {
	// Echo of the request made.
	EchoReq P2PAdvertCreateRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType P2PAdvertCreateRespMsgType `json:"msg_type"`

	// The information of the created P2P advert.
	P2PAdvertCreate *P2PAdvertCreateRespP2PAdvertCreate `json:"p2p_advert_create,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type P2PAdvertCreateRespEchoReq map[string]interface{}

type P2PAdvertCreateRespMsgType string

const P2PAdvertCreateRespMsgTypeP2PAdvertCreate P2PAdvertCreateRespMsgType = "p2p_advert_create"

// The information of the created P2P advert.
type P2PAdvertCreateRespP2PAdvertCreate struct {
	// Currency for this advert. This is the system currency to be transferred between
	// advertiser and client.
	AccountCurrency string `json:"account_currency"`

	// The number of active orders against this advert.
	ActiveOrders int `json:"active_orders"`

	// Details of the advertiser for this advert.
	AdvertiserDetails P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetails `json:"advertiser_details"`

	// The total amount specified in advert, in `account_currency`.
	Amount float64 `json:"amount"`

	// The total amount specified in advert, in `account_currency`, formatted to
	// appropriate decimal places.
	AmountDisplay string `json:"amount_display"`

	// Indicates if this is block trade advert or not.
	BlockTrade P2PAdvertCreateRespP2PAdvertCreateBlockTrade `json:"block_trade"`

	// Advertiser contact information. Only applicable for 'sell adverts'.
	ContactInfo *string `json:"contact_info,omitempty"`

	// Type of transaction from the opposite party's perspective.
	CounterpartyType P2PAdvertCreateRespP2PAdvertCreateCounterpartyType `json:"counterparty_type"`

	// The target country code of the advert.
	Country string `json:"country"`

	// The advert creation time in epoch.
	CreatedTime int `json:"created_time"`

	// General information about the advert.
	Description string `json:"description"`

	// Conversion rate from account currency to local currency, using current market
	// rate if applicable.
	EffectiveRate interface{} `json:"effective_rate"`

	// Conversion rate from account currency to local currency, using current market
	// rate if applicable, formatted to appropriate decimal places.
	EffectiveRateDisplay interface{} `json:"effective_rate_display"`

	// The unique identifier for this advert.
	Id string `json:"id"`

	// The activation status of the advert.
	IsActive P2PAdvertCreateRespP2PAdvertCreateIsActive `json:"is_active"`

	// Indicates that this advert will appear on the main advert list.
	IsVisible P2PAdvertCreateRespP2PAdvertCreateIsVisible `json:"is_visible"`

	// Local currency for this advert. This is the form of payment to be arranged
	// directly between advertiser and client.
	LocalCurrency string `json:"local_currency"`

	// Maximum order amount specified in advert, in `account_currency`.
	MaxOrderAmount float64 `json:"max_order_amount"`

	// Maximum order amount specified in advert, in `account_currency`, formatted to
	// appropriate decimal places.
	MaxOrderAmountDisplay string `json:"max_order_amount_display"`

	// Maximum order amount at this time, in `account_currency`.
	MaxOrderAmountLimit float64 `json:"max_order_amount_limit"`

	// Maximum order amount at this time, in `account_currency`, formatted to
	// appropriate decimal places.
	MaxOrderAmountLimitDisplay string `json:"max_order_amount_limit_display"`

	// Minimum order amount specified in advert, in `account_currency`.
	MinOrderAmount float64 `json:"min_order_amount"`

	// Minimum order amount specified in advert, in `account_currency`, formatted to
	// appropriate decimal places.
	MinOrderAmountDisplay string `json:"min_order_amount_display"`

	// Minimum order amount at this time, in `account_currency`.
	MinOrderAmountLimit float64 `json:"min_order_amount_limit"`

	// Minimum order amount at this time, in `account_currency`, formatted to
	// appropriate decimal places.
	MinOrderAmountLimitDisplay string `json:"min_order_amount_limit_display"`

	// Payment instructions. Only applicable for 'sell adverts'.
	PaymentInfo *string `json:"payment_info,omitempty"`

	// Payment method name (deprecated).
	PaymentMethod interface{} `json:"payment_method"`

	// Details of available payment methods (sell adverts only).
	PaymentMethodDetails P2PAdvertCreateRespP2PAdvertCreatePaymentMethodDetails `json:"payment_method_details,omitempty"`

	// Names of supported payment methods.
	PaymentMethodNames []string `json:"payment_method_names,omitempty"`

	// Cost of the advert in local currency.
	Price interface{} `json:"price"`

	// Cost of the advert in local currency, formatted to appropriate decimal places.
	PriceDisplay interface{} `json:"price_display"`

	// Conversion rate from advertiser's account currency to `local_currency`. An
	// absolute rate value (fixed), or percentage offset from current market rate
	// (floating).
	Rate float64 `json:"rate"`

	// Conversion rate formatted to appropriate decimal places.
	RateDisplay string `json:"rate_display"`

	// Type of rate, fixed or floating.
	RateType P2PAdvertCreateRespP2PAdvertCreateRateType `json:"rate_type"`

	// Amount currently available for orders, in `account_currency`.
	RemainingAmount float64 `json:"remaining_amount"`

	// Amount currently available for orders, in `account_currency`, formatted to
	// appropriate decimal places.
	RemainingAmountDisplay string `json:"remaining_amount_display"`

	// The type of advertisement in relation to the advertiser's Deriv account.
	Type P2PAdvertCreateRespP2PAdvertCreateType `json:"type"`

	// Reasons why an advert is not visible. Possible values:
	// - `advert_inactive`: the advert is set inactive.
	// - `advert_max_limit`: the minimum order amount exceeds the system maximum
	// order.
	// - `advert_min_limit`: the maximum order amount is too small to be shown on the
	// advert list.
	// - `advert_remaining`: the remaining amount of the advert is below the minimum
	// order.
	// - `advertiser_ads_paused`: the advertiser has paused all adverts.
	// - `advertiser_approval`: the advertiser's proof of identity is not verified.
	// - `advertiser_balance`: the advertiser's P2P balance is less than the minimum
	// order.
	// - `advertiser_block_trade_ineligible`: the advertiser is not currently eligible
	// for block trading.
	// - `advertiser_daily_limit`: the advertiser's remaining daily limit is less than
	// the minimum order.
	// - `advertiser_temp_ban`: the advertiser is temporarily banned from P2P.
	VisibilityStatus []P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem `json:"visibility_status,omitempty"`
}

// Details of the advertiser for this advert.
type P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetails struct {
	// The total number of orders completed in the past 30 days.
	CompletedOrdersCount int `json:"completed_orders_count"`

	// The advertiser's first name.
	FirstName *string `json:"first_name,omitempty"`

	// The advertiser's unique identifier.
	Id string `json:"id"`

	// Indicates if the advertiser is currently online.
	IsOnline P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetailsIsOnline `json:"is_online"`

	// The advertiser's last name.
	LastName *string `json:"last_name,omitempty"`

	// Epoch of the latest time the advertiser was online, up to 6 months.
	LastOnlineTime interface{} `json:"last_online_time"`

	// The advertiser's displayed name.
	Name string `json:"name"`

	// Average rating of the advertiser, range is 1-5.
	RatingAverage interface{} `json:"rating_average"`

	// Number of ratings given to the advertiser.
	RatingCount int `json:"rating_count"`

	// Percentage of users who have recommended the advertiser.
	RecommendedAverage interface{} `json:"recommended_average"`

	// Number of times the advertiser has been recommended.
	RecommendedCount interface{} `json:"recommended_count"`

	// The percentage of successfully completed orders made by or placed against the
	// advertiser within the past 30 days.
	TotalCompletionRate interface{} `json:"total_completion_rate"`
}

type P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetailsIsOnline int

type P2PAdvertCreateRespP2PAdvertCreateBlockTrade int

type P2PAdvertCreateRespP2PAdvertCreateCounterpartyType string

const P2PAdvertCreateRespP2PAdvertCreateCounterpartyTypeBuy P2PAdvertCreateRespP2PAdvertCreateCounterpartyType = "buy"
const P2PAdvertCreateRespP2PAdvertCreateCounterpartyTypeSell P2PAdvertCreateRespP2PAdvertCreateCounterpartyType = "sell"

type P2PAdvertCreateRespP2PAdvertCreateIsActive int

type P2PAdvertCreateRespP2PAdvertCreateIsVisible int

// Details of available payment methods (sell adverts only).
type P2PAdvertCreateRespP2PAdvertCreatePaymentMethodDetails map[string]interface{}

type P2PAdvertCreateRespP2PAdvertCreateRateType string

const P2PAdvertCreateRespP2PAdvertCreateRateTypeFixed P2PAdvertCreateRespP2PAdvertCreateRateType = "fixed"
const P2PAdvertCreateRespP2PAdvertCreateRateTypeFloat P2PAdvertCreateRespP2PAdvertCreateRateType = "float"

type P2PAdvertCreateRespP2PAdvertCreateType string

const P2PAdvertCreateRespP2PAdvertCreateTypeBuy P2PAdvertCreateRespP2PAdvertCreateType = "buy"
const P2PAdvertCreateRespP2PAdvertCreateTypeSell P2PAdvertCreateRespP2PAdvertCreateType = "sell"

type P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem string

const P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElemAdvertInactive P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem = "advert_inactive"
const P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElemAdvertMaxLimit P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem = "advert_max_limit"
const P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElemAdvertMinLimit P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem = "advert_min_limit"
const P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElemAdvertRemaining P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem = "advert_remaining"
const P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElemAdvertiserAdsPaused P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem = "advertiser_ads_paused"
const P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElemAdvertiserApproval P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem = "advertiser_approval"
const P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElemAdvertiserBalance P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem = "advertiser_balance"
const P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElemAdvertiserBlockTradeIneligible P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem = "advertiser_block_trade_ineligible"
const P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElemAdvertiserDailyLimit P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem = "advertiser_daily_limit"
const P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElemAdvertiserTempBan P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem = "advertiser_temp_ban"

type P2PAdvertCreateType string

const P2PAdvertCreateTypeBuy P2PAdvertCreateType = "buy"
const P2PAdvertCreateTypeSell P2PAdvertCreateType = "sell"

// Retrieve information about a P2P advert.
type P2PAdvertInfo struct {
	// [Optional] The unique identifier for this advert. Optional when subscribe is 1.
	// If not provided, all advertiser adverts will be subscribed.
	Id *string `json:"id,omitempty"`

	// Must be 1
	P2PAdvertInfo P2PAdvertInfoP2PAdvertInfo `json:"p2p_advert_info"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough P2PAdvertInfoPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// [Optional] If set to 1, will send updates when changes occur. Optional when id
	// is provided.
	Subscribe *P2PAdvertInfoSubscribe `json:"subscribe,omitempty"`

	// [Optional] If set to 1, the maximum order amount will be adjusted to the
	// current balance and turnover limits of the account.
	UseClientLimits P2PAdvertInfoUseClientLimits `json:"use_client_limits,omitempty"`
}

type P2PAdvertInfoP2PAdvertInfo int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type P2PAdvertInfoPassthrough map[string]interface{}

// Returns information about the given advert ID.
type P2PAdvertInfoResp struct {
	// Echo of the request made.
	EchoReq P2PAdvertInfoRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType P2PAdvertInfoRespMsgType `json:"msg_type"`

	// P2P advert information.
	P2PAdvertInfo *P2PAdvertInfoRespP2PAdvertInfo `json:"p2p_advert_info,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// For subscription requests only.
	Subscription *P2PAdvertInfoRespSubscription `json:"subscription,omitempty"`
}

// Echo of the request made.
type P2PAdvertInfoRespEchoReq map[string]interface{}

type P2PAdvertInfoRespMsgType string

const P2PAdvertInfoRespMsgTypeP2PAdvertInfo P2PAdvertInfoRespMsgType = "p2p_advert_info"

// P2P advert information.
type P2PAdvertInfoRespP2PAdvertInfo struct {
	// Currency for this advert. This is the system currency to be transferred between
	// advertiser and client.
	AccountCurrency *string `json:"account_currency,omitempty"`

	// The number of active orders against this advert.
	ActiveOrders *int `json:"active_orders,omitempty"`

	// Details of the advertiser for this advert.
	AdvertiserDetails *P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetails `json:"advertiser_details,omitempty"`

	// The total amount specified in advert, in `account_currency`. It is only visible
	// to the advert owner.
	Amount *float64 `json:"amount,omitempty"`

	// The total amount specified in advert, in `account_currency`, formatted to
	// appropriate decimal places. It is only visible to the advert owner.
	AmountDisplay *string `json:"amount_display,omitempty"`

	// Indicates if this is block trade advert or not.
	BlockTrade *P2PAdvertInfoRespP2PAdvertInfoBlockTrade `json:"block_trade,omitempty"`

	// Advertiser contact information. Only applicable for 'sell adverts'.
	ContactInfo *string `json:"contact_info,omitempty"`

	// Type of transaction from the opposite party's perspective.
	CounterpartyType *P2PAdvertInfoRespP2PAdvertInfoCounterpartyType `json:"counterparty_type,omitempty"`

	// The target country code of the advert.
	Country *string `json:"country,omitempty"`

	// The advert creation time in epoch.
	CreatedTime *int `json:"created_time,omitempty"`

	// Days until automatic inactivation of this ad, if no activity occurs.
	DaysUntilArchive *int `json:"days_until_archive,omitempty"`

	// Indicates that the advert has been deleted.
	Deleted *P2PAdvertInfoRespP2PAdvertInfoDeleted `json:"deleted,omitempty"`

	// General information about the advert.
	Description *string `json:"description,omitempty"`

	// Conversion rate from account currency to local currency, using current market
	// rate if applicable.
	EffectiveRate interface{} `json:"effective_rate,omitempty"`

	// Conversion rate from account currency to local currency, using current market
	// rate if applicable, formatted to appropriate decimal places.
	EffectiveRateDisplay interface{} `json:"effective_rate_display,omitempty"`

	// The unique identifier for this advert.
	Id *string `json:"id,omitempty"`

	// The activation status of the advert.
	IsActive *P2PAdvertInfoRespP2PAdvertInfoIsActive `json:"is_active,omitempty"`

	// Indicates that this advert will appear on the main advert list. It is only
	// visible to the advert owner.
	IsVisible P2PAdvertInfoRespP2PAdvertInfoIsVisible `json:"is_visible,omitempty"`

	// Local currency for this advert. This is the form of payment to be arranged
	// directly between advertiser and client.
	LocalCurrency *string `json:"local_currency,omitempty"`

	// Maximum order amount specified in advert, in `account_currency`. It is only
	// visible for advertisers.
	MaxOrderAmount *float64 `json:"max_order_amount,omitempty"`

	// Maximum order amount specified in advert, in `account_currency`, formatted to
	// appropriate decimal places. It is only visible to the advert owner.
	MaxOrderAmountDisplay *string `json:"max_order_amount_display,omitempty"`

	// Maximum order amount at this time, in `account_currency`.
	MaxOrderAmountLimit *float64 `json:"max_order_amount_limit,omitempty"`

	// Maximum order amount at this time, in `account_currency`, formatted to
	// appropriate decimal places.
	MaxOrderAmountLimitDisplay *string `json:"max_order_amount_limit_display,omitempty"`

	// Minimum order amount specified in advert, in `account_currency`. It is only
	// visible for advertisers.
	MinOrderAmount *float64 `json:"min_order_amount,omitempty"`

	// Minimum order amount specified in advert, in `account_currency`, formatted to
	// appropriate decimal places. It is only visible to the advert owner.
	MinOrderAmountDisplay *string `json:"min_order_amount_display,omitempty"`

	// Minimum order amount at this time, in `account_currency`.
	MinOrderAmountLimit *float64 `json:"min_order_amount_limit,omitempty"`

	// Minimum order amount at this time, in `account_currency`, formatted to
	// appropriate decimal places.
	MinOrderAmountLimitDisplay *string `json:"min_order_amount_limit_display,omitempty"`

	// Payment instructions. Only applicable for 'sell adverts'.
	PaymentInfo *string `json:"payment_info,omitempty"`

	// Payment method name (deprecated).
	PaymentMethod interface{} `json:"payment_method,omitempty"`

	// Details of available payment methods (sell adverts only).
	PaymentMethodDetails P2PAdvertInfoRespP2PAdvertInfoPaymentMethodDetails `json:"payment_method_details,omitempty"`

	// Names of supported payment methods.
	PaymentMethodNames []string `json:"payment_method_names,omitempty"`

	// Cost of the advert in local currency.
	Price interface{} `json:"price,omitempty"`

	// Cost of the advert in local currency, formatted to appropriate decimal places.
	PriceDisplay interface{} `json:"price_display,omitempty"`

	// Conversion rate from advertiser's account currency to `local_currency`. An
	// absolute rate value (fixed), or percentage offset from current market rate
	// (floating).
	Rate *float64 `json:"rate,omitempty"`

	// Conversion rate formatted to appropriate decimal places.
	RateDisplay *string `json:"rate_display,omitempty"`

	// Type of rate, fixed or floating.
	RateType *P2PAdvertInfoRespP2PAdvertInfoRateType `json:"rate_type,omitempty"`

	// Amount currently available for orders, in `account_currency`. It is only
	// visible for advertisers.
	RemainingAmount *float64 `json:"remaining_amount,omitempty"`

	// Amount currently available for orders, in `account_currency`, formatted to
	// appropriate decimal places. It is only visible to the advert owner.
	RemainingAmountDisplay *string `json:"remaining_amount_display,omitempty"`

	// Whether this is a buy or a sell.
	Type *P2PAdvertInfoRespP2PAdvertInfoType `json:"type,omitempty"`

	// Reasons why an advert is not visible, only visible to the advert owner.
	// Possible values:
	// - `advert_inactive`: the advert is set inactive.
	// - `advert_max_limit`: the minimum order amount exceeds the system maximum
	// order.
	// - `advert_min_limit`: the maximum order amount is too small to be shown on the
	// advert list.
	// - `advert_remaining`: the remaining amount of the advert is below the minimum
	// order.
	// - `advertiser_ads_paused`: the advertiser has paused all adverts.
	// - `advertiser_approval`: the advertiser's proof of identity is not verified.
	// - `advertiser_balance`: the advertiser's P2P balance is less than the minimum
	// order.
	// - `advertiser_block_trade_ineligible`: the advertiser is not currently eligible
	// for block trading.
	// - `advertiser_daily_limit`: the advertiser's remaining daily limit is less than
	// the minimum order.
	// - `advertiser_temp_ban`: the advertiser is temporarily banned from P2P.
	VisibilityStatus []P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem `json:"visibility_status,omitempty"`
}

// Details of the advertiser for this advert.
type P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetails struct {
	// The total number of orders completed in the past 30 days.
	CompletedOrdersCount int `json:"completed_orders_count"`

	// The advertiser's first name.
	FirstName *string `json:"first_name,omitempty"`

	// The advertiser's unique identifier.
	Id string `json:"id"`

	// Indicates that the advertiser is blocked by the current user.
	IsBlocked *P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsBlocked `json:"is_blocked,omitempty"`

	// Indicates that the advertiser is a favourite of the current user.
	IsFavourite *P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsFavourite `json:"is_favourite,omitempty"`

	// Indicates if the advertiser is currently online.
	IsOnline P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsOnline `json:"is_online"`

	// Indicates that the advertiser was recommended in the most recent review by the
	// current user.
	IsRecommended *P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsRecommended `json:"is_recommended,omitempty"`

	// The advertiser's last name.
	LastName *string `json:"last_name,omitempty"`

	// Epoch of the latest time the advertiser was online, up to 6 months.
	LastOnlineTime interface{} `json:"last_online_time"`

	// The advertiser's displayed name.
	Name string `json:"name"`

	// Average rating of the advertiser, range is 1-5.
	RatingAverage interface{} `json:"rating_average"`

	// Number of ratings given to the advertiser.
	RatingCount int `json:"rating_count"`

	// Percentage of users who have recommended the advertiser.
	RecommendedAverage interface{} `json:"recommended_average"`

	// Number of times the advertiser has been recommended.
	RecommendedCount interface{} `json:"recommended_count"`

	// The percentage of successfully completed orders made by or placed against the
	// advertiser within the past 30 days.
	TotalCompletionRate interface{} `json:"total_completion_rate"`
}

type P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsBlocked int

type P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsFavourite int

type P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsOnline int

type P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsRecommended struct {
	Value interface{}
}

type P2PAdvertInfoRespP2PAdvertInfoBlockTrade int

type P2PAdvertInfoRespP2PAdvertInfoCounterpartyType string

const P2PAdvertInfoRespP2PAdvertInfoCounterpartyTypeBuy P2PAdvertInfoRespP2PAdvertInfoCounterpartyType = "buy"
const P2PAdvertInfoRespP2PAdvertInfoCounterpartyTypeSell P2PAdvertInfoRespP2PAdvertInfoCounterpartyType = "sell"

type P2PAdvertInfoRespP2PAdvertInfoDeleted int

type P2PAdvertInfoRespP2PAdvertInfoIsActive int

type P2PAdvertInfoRespP2PAdvertInfoIsVisible int

// Details of available payment methods (sell adverts only).
type P2PAdvertInfoRespP2PAdvertInfoPaymentMethodDetails map[string]interface{}

type P2PAdvertInfoRespP2PAdvertInfoRateType string

const P2PAdvertInfoRespP2PAdvertInfoRateTypeFixed P2PAdvertInfoRespP2PAdvertInfoRateType = "fixed"
const P2PAdvertInfoRespP2PAdvertInfoRateTypeFloat P2PAdvertInfoRespP2PAdvertInfoRateType = "float"

type P2PAdvertInfoRespP2PAdvertInfoType string

const P2PAdvertInfoRespP2PAdvertInfoTypeBuy P2PAdvertInfoRespP2PAdvertInfoType = "buy"
const P2PAdvertInfoRespP2PAdvertInfoTypeSell P2PAdvertInfoRespP2PAdvertInfoType = "sell"

type P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem string

const P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElemAdvertInactive P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem = "advert_inactive"
const P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElemAdvertMaxLimit P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem = "advert_max_limit"
const P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElemAdvertMinLimit P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem = "advert_min_limit"
const P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElemAdvertRemaining P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem = "advert_remaining"
const P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElemAdvertiserAdsPaused P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem = "advertiser_ads_paused"
const P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElemAdvertiserApproval P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem = "advertiser_approval"
const P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElemAdvertiserBalance P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem = "advertiser_balance"
const P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElemAdvertiserBlockTradeIneligible P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem = "advertiser_block_trade_ineligible"
const P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElemAdvertiserDailyLimit P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem = "advertiser_daily_limit"
const P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElemAdvertiserTempBan P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem = "advertiser_temp_ban"

// For subscription requests only.
type P2PAdvertInfoRespSubscription struct {
	// A per-connection unique identifier. Can be passed to the `forget` API call to
	// unsubscribe.
	Id string `json:"id"`
}

type P2PAdvertInfoSubscribe int

type P2PAdvertInfoUseClientLimits int

// Returns available adverts for use with `p2p_order_create` .
type P2PAdvertList struct {
	// [Optional] ID of the advertiser to list adverts for.
	AdvertiserId *string `json:"advertiser_id,omitempty"`

	// [Optional] Search for advertiser by name. Partial matches will be returned.
	AdvertiserName *string `json:"advertiser_name,omitempty"`

	// [Optional] How much to buy or sell, used to calculate prices.
	Amount *float64 `json:"amount,omitempty"`

	// [Optional] Return block trade adverts when 1, non-block trade adverts when 0
	// (default).
	BlockTrade P2PAdvertListBlockTrade `json:"block_trade,omitempty"`

	// [Optional] Filter the adverts by `counterparty_type`.
	CounterpartyType *P2PAdvertListCounterpartyType `json:"counterparty_type,omitempty"`

	// [Optional] Only show adverts from favourite advertisers. Default is 0.
	FavouritesOnly *P2PAdvertListFavouritesOnly `json:"favourites_only,omitempty"`

	// [Optional] Used for paging.
	Limit int `json:"limit,omitempty"`

	// [Optional] Currency to conduct payment transaction in. If not provided, only
	// ads from country of residence will be returned.
	LocalCurrency *string `json:"local_currency,omitempty"`

	// [Optional] Used for paging.
	Offset int `json:"offset,omitempty"`

	// Must be 1
	P2PAdvertList P2PAdvertListP2PAdvertList `json:"p2p_advert_list"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough P2PAdvertListPassthrough `json:"passthrough,omitempty"`

	// [Optional] Search by supported payment methods.
	PaymentMethod []string `json:"payment_method,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// [Optional] How the results are sorted.
	SortBy P2PAdvertListSortBy `json:"sort_by,omitempty"`

	// [Optional] If set to 1, ads that exceed this account's balance or turnover
	// limits will not be shown.
	UseClientLimits P2PAdvertListUseClientLimits `json:"use_client_limits,omitempty"`
}

type P2PAdvertListBlockTrade int

type P2PAdvertListCounterpartyType string

const P2PAdvertListCounterpartyTypeBuy P2PAdvertListCounterpartyType = "buy"
const P2PAdvertListCounterpartyTypeSell P2PAdvertListCounterpartyType = "sell"

type P2PAdvertListFavouritesOnly int

type P2PAdvertListP2PAdvertList int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type P2PAdvertListPassthrough map[string]interface{}

// Available adverts matching the requested criteria.
type P2PAdvertListResp struct {
	// Echo of the request made.
	EchoReq P2PAdvertListRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType P2PAdvertListRespMsgType `json:"msg_type"`

	// P2P adverts list.
	P2PAdvertList *P2PAdvertListRespP2PAdvertList `json:"p2p_advert_list,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type P2PAdvertListRespEchoReq map[string]interface{}

type P2PAdvertListRespMsgType string

const P2PAdvertListRespMsgTypeP2PAdvertList P2PAdvertListRespMsgType = "p2p_advert_list"

// P2P adverts list.
type P2PAdvertListRespP2PAdvertList struct {
	// List of adverts.
	List []P2PAdvertListRespP2PAdvertListListElem `json:"list"`
}

type P2PAdvertListRespP2PAdvertListListElem struct {
	// Currency for this advert. This is the system currency to be transferred between
	// advertiser and client.
	AccountCurrency string `json:"account_currency"`

	// The number of active orders against this advert.
	ActiveOrders *int `json:"active_orders,omitempty"`

	// Details of the advertiser for this advert.
	AdvertiserDetails P2PAdvertListRespP2PAdvertListListElemAdvertiserDetails `json:"advertiser_details"`

	// The total amount specified in advert, in `account_currency`. It is only visible
	// to the advert owner.
	Amount *float64 `json:"amount,omitempty"`

	// The total amount specified in advert, in `account_currency`, formatted to
	// appropriate decimal places. It is only visible to the advert owner.
	AmountDisplay *string `json:"amount_display,omitempty"`

	// Indicates if this is block trade advert or not.
	BlockTrade P2PAdvertListRespP2PAdvertListListElemBlockTrade `json:"block_trade"`

	// Advertiser contact information. Only applicable for 'sell adverts'.
	ContactInfo *string `json:"contact_info,omitempty"`

	// Type of transaction from the opposite party's perspective.
	CounterpartyType P2PAdvertListRespP2PAdvertListListElemCounterpartyType `json:"counterparty_type"`

	// The target country code of the advert.
	Country string `json:"country"`

	// The advert creation time in epoch.
	CreatedTime int `json:"created_time"`

	// Days until automatic inactivation of this ad, if no activity occurs.
	DaysUntilArchive *int `json:"days_until_archive,omitempty"`

	// General information about the advert.
	Description string `json:"description"`

	// Conversion rate from account currency to local currency, using current market
	// rate if applicable.
	EffectiveRate interface{} `json:"effective_rate"`

	// Conversion rate from account currency to local currency, using current market
	// rate if applicable, formatted to appropriate decimal places.
	EffectiveRateDisplay interface{} `json:"effective_rate_display"`

	// The unique identifier for this advert.
	Id string `json:"id"`

	// The activation status of the advert.
	IsActive P2PAdvertListRespP2PAdvertListListElemIsActive `json:"is_active"`

	// Indicates that this advert will appear on the main advert list.
	IsVisible P2PAdvertListRespP2PAdvertListListElemIsVisible `json:"is_visible"`

	// Local currency for this advert. This is the form of payment to be arranged
	// directly between advertiser and client.
	LocalCurrency string `json:"local_currency"`

	// Maximum order amount specified in advert, in `account_currency`. It is only
	// visible for advertisers.
	MaxOrderAmount *float64 `json:"max_order_amount,omitempty"`

	// Maximum order amount specified in advert, in `account_currency`, formatted to
	// appropriate decimal places. It is only visible to the advert owner.
	MaxOrderAmountDisplay *string `json:"max_order_amount_display,omitempty"`

	// Maximum order amount at this time, in `account_currency`.
	MaxOrderAmountLimit float64 `json:"max_order_amount_limit"`

	// Maximum order amount at this time, in `account_currency`, formatted to
	// appropriate decimal places.
	MaxOrderAmountLimitDisplay string `json:"max_order_amount_limit_display"`

	// Minimum order amount specified in advert, in `account_currency`. It is only
	// visible for advertisers.
	MinOrderAmount *float64 `json:"min_order_amount,omitempty"`

	// Minimum order amount specified in advert, in `account_currency`, formatted to
	// appropriate decimal places. It is only visible to the advert owner.
	MinOrderAmountDisplay *string `json:"min_order_amount_display,omitempty"`

	// Minimum order amount at this time, in `account_currency`.
	MinOrderAmountLimit float64 `json:"min_order_amount_limit"`

	// Minimum order amount at this time, in `account_currency`, formatted to
	// appropriate decimal places.
	MinOrderAmountLimitDisplay string `json:"min_order_amount_limit_display"`

	// Payment instructions. Only applicable for 'sell adverts'.
	PaymentInfo *string `json:"payment_info,omitempty"`

	// Payment method name (deprecated).
	PaymentMethod interface{} `json:"payment_method"`

	// Names of supported payment methods.
	PaymentMethodNames []string `json:"payment_method_names,omitempty"`

	// Cost of the advert in local currency.
	Price interface{} `json:"price"`

	// Cost of the advert in local currency, formatted to appropriate decimal places.
	PriceDisplay interface{} `json:"price_display"`

	// Conversion rate from advertiser's account currency to `local_currency`. An
	// absolute rate value (fixed), or percentage offset from current market rate
	// (floating).
	Rate float64 `json:"rate"`

	// Conversion rate formatted to appropriate decimal places.
	RateDisplay string `json:"rate_display"`

	// Type of rate, fixed or floating.
	RateType P2PAdvertListRespP2PAdvertListListElemRateType `json:"rate_type"`

	// Amount currently available for orders, in `account_currency`. It is only
	// visible to the advert owner.
	RemainingAmount *float64 `json:"remaining_amount,omitempty"`

	// Amount currently available for orders, in `account_currency`, formatted to
	// appropriate decimal places. It is only visible to the advert owner.
	RemainingAmountDisplay *string `json:"remaining_amount_display,omitempty"`

	// Whether this is a buy or a sell.
	Type P2PAdvertListRespP2PAdvertListListElemType `json:"type"`

	// Reasons why an advert is not visible, only visible to the advert owner.
	// Possible values:
	// - `advert_inactive`: the advert is set inactive.
	// - `advert_max_limit`: the minimum order amount exceeds the system maximum
	// order.
	// - `advert_min_limit`: the maximum order amount is too small to be shown on the
	// advert list.
	// - `advert_remaining`: the remaining amount of the advert is below the minimum
	// order.
	// - `advertiser_ads_paused`: the advertiser has paused all adverts.
	// - `advertiser_approval`: the advertiser's proof of identity is not verified.
	// - `advertiser_balance`: the advertiser's P2P balance is less than the minimum
	// order.
	// - `advertiser_block_trade_ineligible`: the advertiser is not currently eligible
	// for block trading.
	// - `advertiser_daily_limit`: the advertiser's remaining daily limit is less than
	// the minimum order.
	// - `advertiser_temp_ban`: the advertiser is temporarily banned from P2P.
	VisibilityStatus []P2PAdvertListRespP2PAdvertListListElemVisibilityStatusElem `json:"visibility_status,omitempty"`
}

// Details of the advertiser for this advert.
type P2PAdvertListRespP2PAdvertListListElemAdvertiserDetails struct {
	// The total number of orders completed in the past 30 days.
	CompletedOrdersCount int `json:"completed_orders_count"`

	// The advertiser's first name.
	FirstName *string `json:"first_name,omitempty"`

	// The advertiser's unique identifier.
	Id string `json:"id"`

	// Indicates that the advertiser is blocked by the current user.
	IsBlocked *P2PAdvertListRespP2PAdvertListListElemAdvertiserDetailsIsBlocked `json:"is_blocked,omitempty"`

	// Indicates that the advertiser is a favourite.
	IsFavourite *P2PAdvertListRespP2PAdvertListListElemAdvertiserDetailsIsFavourite `json:"is_favourite,omitempty"`

	// Indicates if the advertiser is currently online.
	IsOnline P2PAdvertListRespP2PAdvertListListElemAdvertiserDetailsIsOnline `json:"is_online"`

	// Indicates that the advertiser was recommended in the most recent review by the
	// current user.
	IsRecommended *P2PAdvertListRespP2PAdvertListListElemAdvertiserDetailsIsRecommended `json:"is_recommended,omitempty"`

	// The advertiser's last name.
	LastName *string `json:"last_name,omitempty"`

	// Epoch of the latest time the advertiser was online, up to 6 months.
	LastOnlineTime interface{} `json:"last_online_time"`

	// The advertiser's displayed name.
	Name string `json:"name"`

	// Average rating of the advertiser, range is 1-5.
	RatingAverage interface{} `json:"rating_average"`

	// Number of ratings given to the advertiser.
	RatingCount int `json:"rating_count"`

	// Percentage of users who have recommended the advertiser.
	RecommendedAverage interface{} `json:"recommended_average"`

	// Number of times the advertiser has been recommended.
	RecommendedCount interface{} `json:"recommended_count"`

	// The percentage of successfully completed orders made by or placed against the
	// advertiser within the past 30 days.
	TotalCompletionRate interface{} `json:"total_completion_rate"`
}

type P2PAdvertListRespP2PAdvertListListElemAdvertiserDetailsIsBlocked int

type P2PAdvertListRespP2PAdvertListListElemAdvertiserDetailsIsFavourite int

type P2PAdvertListRespP2PAdvertListListElemAdvertiserDetailsIsOnline int

type P2PAdvertListRespP2PAdvertListListElemAdvertiserDetailsIsRecommended struct {
	Value interface{}
}

type P2PAdvertListRespP2PAdvertListListElemBlockTrade int

type P2PAdvertListRespP2PAdvertListListElemCounterpartyType string

const P2PAdvertListRespP2PAdvertListListElemCounterpartyTypeBuy P2PAdvertListRespP2PAdvertListListElemCounterpartyType = "buy"
const P2PAdvertListRespP2PAdvertListListElemCounterpartyTypeSell P2PAdvertListRespP2PAdvertListListElemCounterpartyType = "sell"

type P2PAdvertListRespP2PAdvertListListElemIsActive int

type P2PAdvertListRespP2PAdvertListListElemIsVisible int

type P2PAdvertListRespP2PAdvertListListElemRateType string

const P2PAdvertListRespP2PAdvertListListElemRateTypeFixed P2PAdvertListRespP2PAdvertListListElemRateType = "fixed"
const P2PAdvertListRespP2PAdvertListListElemRateTypeFloat P2PAdvertListRespP2PAdvertListListElemRateType = "float"

type P2PAdvertListRespP2PAdvertListListElemType string

const P2PAdvertListRespP2PAdvertListListElemTypeBuy P2PAdvertListRespP2PAdvertListListElemType = "buy"
const P2PAdvertListRespP2PAdvertListListElemTypeSell P2PAdvertListRespP2PAdvertListListElemType = "sell"

type P2PAdvertListRespP2PAdvertListListElemVisibilityStatusElem string

const P2PAdvertListRespP2PAdvertListListElemVisibilityStatusElemAdvertInactive P2PAdvertListRespP2PAdvertListListElemVisibilityStatusElem = "advert_inactive"
const P2PAdvertListRespP2PAdvertListListElemVisibilityStatusElemAdvertMaxLimit P2PAdvertListRespP2PAdvertListListElemVisibilityStatusElem = "advert_max_limit"
const P2PAdvertListRespP2PAdvertListListElemVisibilityStatusElemAdvertMinLimit P2PAdvertListRespP2PAdvertListListElemVisibilityStatusElem = "advert_min_limit"
const P2PAdvertListRespP2PAdvertListListElemVisibilityStatusElemAdvertRemaining P2PAdvertListRespP2PAdvertListListElemVisibilityStatusElem = "advert_remaining"
const P2PAdvertListRespP2PAdvertListListElemVisibilityStatusElemAdvertiserAdsPaused P2PAdvertListRespP2PAdvertListListElemVisibilityStatusElem = "advertiser_ads_paused"
const P2PAdvertListRespP2PAdvertListListElemVisibilityStatusElemAdvertiserApproval P2PAdvertListRespP2PAdvertListListElemVisibilityStatusElem = "advertiser_approval"
const P2PAdvertListRespP2PAdvertListListElemVisibilityStatusElemAdvertiserBalance P2PAdvertListRespP2PAdvertListListElemVisibilityStatusElem = "advertiser_balance"
const P2PAdvertListRespP2PAdvertListListElemVisibilityStatusElemAdvertiserBlockTradeIneligible P2PAdvertListRespP2PAdvertListListElemVisibilityStatusElem = "advertiser_block_trade_ineligible"
const P2PAdvertListRespP2PAdvertListListElemVisibilityStatusElemAdvertiserDailyLimit P2PAdvertListRespP2PAdvertListListElemVisibilityStatusElem = "advertiser_daily_limit"
const P2PAdvertListRespP2PAdvertListListElemVisibilityStatusElemAdvertiserTempBan P2PAdvertListRespP2PAdvertListListElemVisibilityStatusElem = "advertiser_temp_ban"

type P2PAdvertListSortBy string

const P2PAdvertListSortByCompletion P2PAdvertListSortBy = "completion"
const P2PAdvertListSortByRate P2PAdvertListSortBy = "rate"
const P2PAdvertListSortByRating P2PAdvertListSortBy = "rating"
const P2PAdvertListSortByRecommended P2PAdvertListSortBy = "recommended"

type P2PAdvertListUseClientLimits int

// Updates a P2P advert. Can only be used by the advertiser.
type P2PAdvertUpdate struct {
	// [Optional] Advertiser contact information.
	ContactInfo *string `json:"contact_info,omitempty"`

	// [Optional] If set to 1, permanently deletes the advert.
	Delete *P2PAdvertUpdateDelete `json:"delete,omitempty"`

	// [Optional] General information about the advert.
	Description *string `json:"description,omitempty"`

	// The unique identifier for this advert.
	Id string `json:"id"`

	// [Optional] Activate or deactivate the advert.
	IsActive *P2PAdvertUpdateIsActive `json:"is_active,omitempty"`

	// [Optional] Local currency for this advert.
	LocalCurrency *string `json:"local_currency,omitempty"`

	// [Optional] Maximum allowed amount for the orders of this advert, in
	// advertiser's `account_currency`. Should be more than or equal to
	// `min_order_amount`.
	MaxOrderAmount *float64 `json:"max_order_amount,omitempty"`

	// [Optional] Minimum allowed amount for the orders of this advert, in
	// advertiser's `account_currency`. Should be less than or equal to
	// `max_order_amount`.
	MinOrderAmount *float64 `json:"min_order_amount,omitempty"`

	// Must be 1
	P2PAdvertUpdate P2PAdvertUpdateP2PAdvertUpdate `json:"p2p_advert_update"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough P2PAdvertUpdatePassthrough `json:"passthrough,omitempty"`

	// [Optional] Payment instructions.
	PaymentInfo *string `json:"payment_info,omitempty"`

	// [Optional] IDs of previously saved payment methods as returned from
	// p2p_advertiser_payment_methods, only applicable for sell ads. Exisiting methods
	// will be replaced.
	PaymentMethodIds []int `json:"payment_method_ids,omitempty"`

	// [Optional] Payment method identifiers as returned from p2p_payment_methods,
	// only applicable for buy ads. Exisiting methods will be replaced.
	PaymentMethodNames []string `json:"payment_method_names,omitempty"`

	// [Optional] Conversion rate from advertiser's account currency to
	// `local_currency`. An absolute rate value (fixed), or percentage offset from
	// current market rate (floating).
	Rate *float64 `json:"rate,omitempty"`

	// [Optional] Type of rate, fixed or floating.
	RateType *P2PAdvertUpdateRateType `json:"rate_type,omitempty"`

	// [Optional] The total available amount of the advert, in advertiser's account
	// currency.
	RemainingAmount *float64 `json:"remaining_amount,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type P2PAdvertUpdateDelete int

type P2PAdvertUpdateIsActive int

type P2PAdvertUpdateP2PAdvertUpdate int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type P2PAdvertUpdatePassthrough map[string]interface{}

type P2PAdvertUpdateRateType string

const P2PAdvertUpdateRateTypeFixed P2PAdvertUpdateRateType = "fixed"
const P2PAdvertUpdateRateTypeFloat P2PAdvertUpdateRateType = "float"

// Returns information about the updated advert.
type P2PAdvertUpdateResp struct {
	// Echo of the request made.
	EchoReq P2PAdvertUpdateRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType P2PAdvertUpdateRespMsgType `json:"msg_type"`

	// P2P updated advert information.
	P2PAdvertUpdate *P2PAdvertUpdateRespP2PAdvertUpdate `json:"p2p_advert_update,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type P2PAdvertUpdateRespEchoReq map[string]interface{}

type P2PAdvertUpdateRespMsgType string

const P2PAdvertUpdateRespMsgTypeP2PAdvertUpdate P2PAdvertUpdateRespMsgType = "p2p_advert_update"

// P2P updated advert information.
type P2PAdvertUpdateRespP2PAdvertUpdate struct {
	// Currency for this advert. This is the system currency to be transferred between
	// advertiser and client.
	AccountCurrency *string `json:"account_currency,omitempty"`

	// The number of active orders against this advert.
	ActiveOrders *int `json:"active_orders,omitempty"`

	// Details of the advertiser for this advert.
	AdvertiserDetails *P2PAdvertUpdateRespP2PAdvertUpdateAdvertiserDetails `json:"advertiser_details,omitempty"`

	// The total amount specified in advert, in `account_currency`.
	Amount *float64 `json:"amount,omitempty"`

	// The total amount specified in advert, in `account_currency`, formatted to
	// appropriate decimal places.
	AmountDisplay *string `json:"amount_display,omitempty"`

	// Indicates if this is block trade advert or not.
	BlockTrade *P2PAdvertUpdateRespP2PAdvertUpdateBlockTrade `json:"block_trade,omitempty"`

	// Advertiser contact information. Only applicable for 'sell adverts'.
	ContactInfo *string `json:"contact_info,omitempty"`

	// Type of transaction from the opposite party's perspective.
	CounterpartyType *P2PAdvertUpdateRespP2PAdvertUpdateCounterpartyType `json:"counterparty_type,omitempty"`

	// The target country code of the advert.
	Country *string `json:"country,omitempty"`

	// The advert creation time in epoch.
	CreatedTime *int `json:"created_time,omitempty"`

	// Days until automatic inactivation of this ad, if no activity occurs.
	DaysUntilArchive *int `json:"days_until_archive,omitempty"`

	// Indicates that the advert has been deleted.
	Deleted *P2PAdvertUpdateRespP2PAdvertUpdateDeleted `json:"deleted,omitempty"`

	// General information about the advert.
	Description *string `json:"description,omitempty"`

	// Conversion rate from account currency to local currency, using current market
	// rate if applicable.
	EffectiveRate interface{} `json:"effective_rate,omitempty"`

	// Conversion rate from account currency to local currency, using current market
	// rate if applicable, formatted to appropriate decimal places.
	EffectiveRateDisplay interface{} `json:"effective_rate_display,omitempty"`

	// The unique identifier for this advert.
	Id string `json:"id"`

	// The activation status of the advert.
	IsActive *P2PAdvertUpdateRespP2PAdvertUpdateIsActive `json:"is_active,omitempty"`

	// Indicates that this advert will appear on the main advert list.
	IsVisible P2PAdvertUpdateRespP2PAdvertUpdateIsVisible `json:"is_visible,omitempty"`

	// Local currency for this advert. This is the form of payment to be arranged
	// directly between advertiser and client.
	LocalCurrency *string `json:"local_currency,omitempty"`

	// Maximum order amount specified in advert, in `account_currency`.
	MaxOrderAmount *float64 `json:"max_order_amount,omitempty"`

	// Maximum order amount specified in advert, in `account_currency`, formatted to
	// appropriate decimal places.
	MaxOrderAmountDisplay *string `json:"max_order_amount_display,omitempty"`

	// Maximum order amount at this time, in `account_currency`.
	MaxOrderAmountLimit *float64 `json:"max_order_amount_limit,omitempty"`

	// Maximum order amount at this time, in `account_currency`, formatted to
	// appropriate decimal places.
	MaxOrderAmountLimitDisplay *string `json:"max_order_amount_limit_display,omitempty"`

	// Minimum order amount specified in advert, in `account_currency`. It is only
	// visible to the advert owner.
	MinOrderAmount *float64 `json:"min_order_amount,omitempty"`

	// Minimum order amount specified in advert, in `account_currency`, formatted to
	// appropriate decimal places.
	MinOrderAmountDisplay *string `json:"min_order_amount_display,omitempty"`

	// Minimum order amount at this time, in `account_currency`.
	MinOrderAmountLimit *float64 `json:"min_order_amount_limit,omitempty"`

	// Minimum order amount at this time, in `account_currency`, formatted to
	// appropriate decimal places.
	MinOrderAmountLimitDisplay *string `json:"min_order_amount_limit_display,omitempty"`

	// Payment instructions. Only applicable for 'sell adverts'.
	PaymentInfo *string `json:"payment_info,omitempty"`

	// Payment method name (deprecated).
	PaymentMethod interface{} `json:"payment_method,omitempty"`

	// Details of available payment methods (sell adverts only).
	PaymentMethodDetails P2PAdvertUpdateRespP2PAdvertUpdatePaymentMethodDetails `json:"payment_method_details,omitempty"`

	// Names of supported payment methods.
	PaymentMethodNames []string `json:"payment_method_names,omitempty"`

	// Cost of the advert in local currency.
	Price interface{} `json:"price,omitempty"`

	// Cost of the advert in local currency, formatted to appropriate decimal places.
	PriceDisplay interface{} `json:"price_display,omitempty"`

	// Conversion rate from advertiser's account currency to `local_currency`. An
	// absolute rate value (fixed), or percentage offset from current market rate
	// (floating).
	Rate *float64 `json:"rate,omitempty"`

	// Conversion rate formatted to appropriate decimal places.
	RateDisplay *string `json:"rate_display,omitempty"`

	// Type of rate, fixed or floating.
	RateType *P2PAdvertUpdateRespP2PAdvertUpdateRateType `json:"rate_type,omitempty"`

	// Amount currently available for orders, in `account_currency`.
	RemainingAmount *float64 `json:"remaining_amount,omitempty"`

	// Amount currently available for orders, in `account_currency`, formatted to
	// appropriate decimal places.
	RemainingAmountDisplay *string `json:"remaining_amount_display,omitempty"`

	// Whether this is a buy or a sell.
	Type *P2PAdvertUpdateRespP2PAdvertUpdateType `json:"type,omitempty"`

	// Reasons why an advert is not visible. Possible values:
	// - `advert_inactive`: the advert is set inactive.
	// - `advert_max_limit`: the minimum order amount exceeds the system maximum
	// order.
	// - `advert_min_limit`: the maximum order amount is too small to be shown on the
	// advert list.
	// - `advert_remaining`: the remaining amount of the advert is below the minimum
	// order.
	// - `advertiser_ads_paused`: the advertiser has paused all adverts.
	// - `advertiser_approval`: the advertiser's proof of identity is not verified.
	// - `advertiser_balance`: the advertiser's P2P balance is less than the minimum
	// order.
	// - `advertiser_block_trade_ineligible`: the advertiser is not currently eligible
	// for block trading.
	// - `advertiser_daily_limit`: the advertiser's remaining daily limit is less than
	// the minimum order.
	// - `advertiser_temp_ban`: the advertiser is temporarily banned from P2P.
	VisibilityStatus []P2PAdvertUpdateRespP2PAdvertUpdateVisibilityStatusElem `json:"visibility_status,omitempty"`
}

// Details of the advertiser for this advert.
type P2PAdvertUpdateRespP2PAdvertUpdateAdvertiserDetails struct {
	// The total number of orders completed in the past 30 days.
	CompletedOrdersCount int `json:"completed_orders_count"`

	// The advertiser's first name.
	FirstName *string `json:"first_name,omitempty"`

	// The advertiser's unique identifier.
	Id string `json:"id"`

	// Indicates if the advertiser is currently online.
	IsOnline P2PAdvertUpdateRespP2PAdvertUpdateAdvertiserDetailsIsOnline `json:"is_online"`

	// The advertiser's last name.
	LastName *string `json:"last_name,omitempty"`

	// Epoch of the latest time the advertiser was online, up to 6 months.
	LastOnlineTime interface{} `json:"last_online_time"`

	// The advertiser's displayed name.
	Name string `json:"name"`

	// Average rating of the advertiser, range is 1-5.
	RatingAverage interface{} `json:"rating_average"`

	// Number of ratings given to the advertiser.
	RatingCount int `json:"rating_count"`

	// Percentage of users who have recommended the advertiser.
	RecommendedAverage interface{} `json:"recommended_average"`

	// Number of times the advertiser has been recommended.
	RecommendedCount interface{} `json:"recommended_count"`

	// The percentage of successfully completed orders made by or placed against the
	// advertiser within the past 30 days.
	TotalCompletionRate interface{} `json:"total_completion_rate"`
}

type P2PAdvertUpdateRespP2PAdvertUpdateAdvertiserDetailsIsOnline int

type P2PAdvertUpdateRespP2PAdvertUpdateBlockTrade int

type P2PAdvertUpdateRespP2PAdvertUpdateCounterpartyType string

const P2PAdvertUpdateRespP2PAdvertUpdateCounterpartyTypeBuy P2PAdvertUpdateRespP2PAdvertUpdateCounterpartyType = "buy"
const P2PAdvertUpdateRespP2PAdvertUpdateCounterpartyTypeSell P2PAdvertUpdateRespP2PAdvertUpdateCounterpartyType = "sell"

type P2PAdvertUpdateRespP2PAdvertUpdateDeleted int

type P2PAdvertUpdateRespP2PAdvertUpdateIsActive int

type P2PAdvertUpdateRespP2PAdvertUpdateIsVisible int

// Details of available payment methods (sell adverts only).
type P2PAdvertUpdateRespP2PAdvertUpdatePaymentMethodDetails map[string]interface{}

type P2PAdvertUpdateRespP2PAdvertUpdateRateType string

const P2PAdvertUpdateRespP2PAdvertUpdateRateTypeFixed P2PAdvertUpdateRespP2PAdvertUpdateRateType = "fixed"
const P2PAdvertUpdateRespP2PAdvertUpdateRateTypeFloat P2PAdvertUpdateRespP2PAdvertUpdateRateType = "float"

type P2PAdvertUpdateRespP2PAdvertUpdateType string

const P2PAdvertUpdateRespP2PAdvertUpdateTypeBuy P2PAdvertUpdateRespP2PAdvertUpdateType = "buy"
const P2PAdvertUpdateRespP2PAdvertUpdateTypeSell P2PAdvertUpdateRespP2PAdvertUpdateType = "sell"

type P2PAdvertUpdateRespP2PAdvertUpdateVisibilityStatusElem string

const P2PAdvertUpdateRespP2PAdvertUpdateVisibilityStatusElemAdvertInactive P2PAdvertUpdateRespP2PAdvertUpdateVisibilityStatusElem = "advert_inactive"
const P2PAdvertUpdateRespP2PAdvertUpdateVisibilityStatusElemAdvertMaxLimit P2PAdvertUpdateRespP2PAdvertUpdateVisibilityStatusElem = "advert_max_limit"
const P2PAdvertUpdateRespP2PAdvertUpdateVisibilityStatusElemAdvertMinLimit P2PAdvertUpdateRespP2PAdvertUpdateVisibilityStatusElem = "advert_min_limit"
const P2PAdvertUpdateRespP2PAdvertUpdateVisibilityStatusElemAdvertRemaining P2PAdvertUpdateRespP2PAdvertUpdateVisibilityStatusElem = "advert_remaining"
const P2PAdvertUpdateRespP2PAdvertUpdateVisibilityStatusElemAdvertiserAdsPaused P2PAdvertUpdateRespP2PAdvertUpdateVisibilityStatusElem = "advertiser_ads_paused"
const P2PAdvertUpdateRespP2PAdvertUpdateVisibilityStatusElemAdvertiserApproval P2PAdvertUpdateRespP2PAdvertUpdateVisibilityStatusElem = "advertiser_approval"
const P2PAdvertUpdateRespP2PAdvertUpdateVisibilityStatusElemAdvertiserBalance P2PAdvertUpdateRespP2PAdvertUpdateVisibilityStatusElem = "advertiser_balance"
const P2PAdvertUpdateRespP2PAdvertUpdateVisibilityStatusElemAdvertiserBlockTradeIneligible P2PAdvertUpdateRespP2PAdvertUpdateVisibilityStatusElem = "advertiser_block_trade_ineligible"
const P2PAdvertUpdateRespP2PAdvertUpdateVisibilityStatusElemAdvertiserDailyLimit P2PAdvertUpdateRespP2PAdvertUpdateVisibilityStatusElem = "advertiser_daily_limit"
const P2PAdvertUpdateRespP2PAdvertUpdateVisibilityStatusElemAdvertiserTempBan P2PAdvertUpdateRespP2PAdvertUpdateVisibilityStatusElem = "advertiser_temp_ban"

// Returns all P2P adverts created by the authorized client. Can only be used by a
// registered P2P advertiser.
type P2PAdvertiserAdverts struct {
	// [Optional] Used for paging. This value will also apply to subsription
	// responses.
	Limit int `json:"limit,omitempty"`

	// [Optional] Used for paging. This value will also apply to subsription
	// responses.
	Offset int `json:"offset,omitempty"`

	// Must be 1
	P2PAdvertiserAdverts P2PAdvertiserAdvertsP2PAdvertiserAdverts `json:"p2p_advertiser_adverts"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough P2PAdvertiserAdvertsPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type P2PAdvertiserAdvertsP2PAdvertiserAdverts int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type P2PAdvertiserAdvertsPassthrough map[string]interface{}

// All adverts belonging to the current advertiser.
type P2PAdvertiserAdvertsResp struct {
	// Echo of the request made.
	EchoReq P2PAdvertiserAdvertsRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType P2PAdvertiserAdvertsRespMsgType `json:"msg_type"`

	// List of the P2P advertiser adverts.
	P2PAdvertiserAdverts *P2PAdvertiserAdvertsRespP2PAdvertiserAdverts `json:"p2p_advertiser_adverts,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type P2PAdvertiserAdvertsRespEchoReq map[string]interface{}

type P2PAdvertiserAdvertsRespMsgType string

const P2PAdvertiserAdvertsRespMsgTypeP2PAdvertiserAdverts P2PAdvertiserAdvertsRespMsgType = "p2p_advertiser_adverts"

// List of the P2P advertiser adverts.
type P2PAdvertiserAdvertsRespP2PAdvertiserAdverts struct {
	// List of advertiser adverts.
	List []P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElem `json:"list"`
}

type P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElem struct {
	// Currency for this advert. This is the system currency to be transferred between
	// advertiser and client.
	AccountCurrency string `json:"account_currency"`

	// The number of active orders against this advert.
	ActiveOrders int `json:"active_orders"`

	// Details of the advertiser for this advert.
	AdvertiserDetails P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemAdvertiserDetails `json:"advertiser_details"`

	// The total amount specified in advert, in `account_currency`.
	Amount float64 `json:"amount"`

	// The total amount specified in advert, in `account_currency`, formatted to
	// appropriate decimal places.
	AmountDisplay string `json:"amount_display"`

	// Indicates if this is block trade advert or not.
	BlockTrade P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemBlockTrade `json:"block_trade"`

	// Advertiser contact information. Only applicable for 'sell adverts'.
	ContactInfo string `json:"contact_info"`

	// This is the type of transaction from the counterparty's perspective.
	CounterpartyType P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemCounterpartyType `json:"counterparty_type"`

	// The target country code of the advert.
	Country string `json:"country"`

	// The advert creation time in epoch.
	CreatedTime int `json:"created_time"`

	// Days until automatic inactivation of this ad, if no activity occurs.
	DaysUntilArchive *int `json:"days_until_archive,omitempty"`

	// General information about the advert.
	Description string `json:"description"`

	// Conversion rate from account currency to local currency, using current market
	// rate if applicable.
	EffectiveRate interface{} `json:"effective_rate"`

	// Conversion rate from account currency to local currency, using current market
	// rate if applicable, formatted to appropriate decimal places.
	EffectiveRateDisplay interface{} `json:"effective_rate_display"`

	// The unique identifier for this advert.
	Id string `json:"id"`

	// The activation status of the advert.
	IsActive P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemIsActive `json:"is_active"`

	// Indicates that this advert will appear on the main advert list.
	IsVisible P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemIsVisible `json:"is_visible"`

	// Local currency for this advert. This is the form of payment to be arranged
	// directly between advertiser and client.
	LocalCurrency string `json:"local_currency"`

	// Maximum order amount, in `account_currency`.
	MaxOrderAmount float64 `json:"max_order_amount"`

	// Maximum order amount, in `account_currency`, formatted to appropriate decimal
	// places.
	MaxOrderAmountDisplay string `json:"max_order_amount_display"`

	// Maximum order amount at this time, in `account_currency`.
	MaxOrderAmountLimit float64 `json:"max_order_amount_limit"`

	// Maximum order amount at this time, in `account_currency`, formatted to
	// appropriate decimal places.
	MaxOrderAmountLimitDisplay string `json:"max_order_amount_limit_display"`

	// Minimum order amount, in `account_currency`.
	MinOrderAmount float64 `json:"min_order_amount"`

	// Minimum order amount, in `account_currency`, formatted to appropriate decimal
	// places.
	MinOrderAmountDisplay string `json:"min_order_amount_display"`

	// Minimum order amount at this time, in `account_currency`.
	MinOrderAmountLimit float64 `json:"min_order_amount_limit"`

	// Minimum order amount at this time, in `account_currency`, formatted to
	// appropriate decimal places.
	MinOrderAmountLimitDisplay string `json:"min_order_amount_limit_display"`

	// Payment instructions. Only applicable for 'sell adverts'.
	PaymentInfo string `json:"payment_info"`

	// Payment method name (deprecated).
	PaymentMethod interface{} `json:"payment_method"`

	// Names of supported payment methods.
	PaymentMethodNames []string `json:"payment_method_names,omitempty"`

	// Cost of the advert in local currency.
	Price interface{} `json:"price"`

	// Cost of the advert in local currency, formatted to appropriate decimal places.
	PriceDisplay interface{} `json:"price_display"`

	// Conversion rate from advertiser's account currency to `local_currency`. An
	// absolute rate value (fixed), or percentage offset from current market rate
	// (floating).
	Rate float64 `json:"rate"`

	// Conversion rate formatted to appropriate decimal places.
	RateDisplay string `json:"rate_display"`

	// Type of rate, fixed or floating.
	RateType P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemRateType `json:"rate_type"`

	// Amount currently available for orders, in `account_currency`.
	RemainingAmount float64 `json:"remaining_amount"`

	// Amount currently available for orders, in `account_currency`, formatted to
	// appropriate decimal places.
	RemainingAmountDisplay string `json:"remaining_amount_display"`

	// Whether this is a buy or a sell.
	Type P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemType `json:"type"`

	// Reasons why an advert is not visible. Possible values:
	// - `advert_inactive`: the advert is set inactive.
	// - `advert_max_limit`: the minimum order amount exceeds the system maximum
	// order.
	// - `advert_min_limit`: the maximum order amount is too small to be shown on the
	// advert list.
	// - `advert_remaining`: the remaining amount of the advert is below the minimum
	// order.
	// - `advertiser_ads_paused`: the advertiser has paused all adverts.
	// - `advertiser_approval`: the advertiser's proof of identity is not verified.
	// - `advertiser_balance`: the advertiser's P2P balance is less than the minimum
	// order.
	// - `advertiser_block_trade_ineligible`: the advertiser is not currently eligible
	// for block trading.
	// - `advertiser_daily_limit`: the advertiser's remaining daily limit is less than
	// the minimum order.
	// - `advertiser_temp_ban`: the advertiser is temporarily banned from P2P.
	VisibilityStatus []P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemVisibilityStatusElem `json:"visibility_status,omitempty"`
}

// Details of the advertiser for this advert.
type P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemAdvertiserDetails struct {
	// The total number of orders completed in the past 30 days.
	CompletedOrdersCount int `json:"completed_orders_count"`

	// The advertiser's first name.
	FirstName *string `json:"first_name,omitempty"`

	// The advertiser's unique identifier.
	Id string `json:"id"`

	// Indicates if the advertiser is currently online.
	IsOnline P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemAdvertiserDetailsIsOnline `json:"is_online"`

	// The advertiser's last name.
	LastName *string `json:"last_name,omitempty"`

	// Epoch of the latest time the advertiser was online, up to 6 months.
	LastOnlineTime interface{} `json:"last_online_time"`

	// The advertiser's displayed name.
	Name string `json:"name"`

	// Average rating of the advertiser, range is 1-5.
	RatingAverage interface{} `json:"rating_average"`

	// Number of ratings given to the advertiser.
	RatingCount int `json:"rating_count"`

	// Percentage of users who have recommended the advertiser.
	RecommendedAverage interface{} `json:"recommended_average"`

	// Number of times the advertiser has been recommended.
	RecommendedCount interface{} `json:"recommended_count"`

	// The percentage of successfully completed orders made by or placed against the
	// advertiser within the past 30 days.
	TotalCompletionRate interface{} `json:"total_completion_rate"`
}

type P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemAdvertiserDetailsIsOnline int

type P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemBlockTrade int

type P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemCounterpartyType string

const P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemCounterpartyTypeBuy P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemCounterpartyType = "buy"
const P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemCounterpartyTypeSell P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemCounterpartyType = "sell"

type P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemIsActive int

type P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemIsVisible int

type P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemRateType string

const P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemRateTypeFixed P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemRateType = "fixed"
const P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemRateTypeFloat P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemRateType = "float"

type P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemType string

const P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemTypeBuy P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemType = "buy"
const P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemTypeSell P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemType = "sell"

type P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemVisibilityStatusElem string

const P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemVisibilityStatusElemAdvertInactive P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemVisibilityStatusElem = "advert_inactive"
const P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemVisibilityStatusElemAdvertMaxLimit P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemVisibilityStatusElem = "advert_max_limit"
const P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemVisibilityStatusElemAdvertMinLimit P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemVisibilityStatusElem = "advert_min_limit"
const P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemVisibilityStatusElemAdvertRemaining P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemVisibilityStatusElem = "advert_remaining"
const P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemVisibilityStatusElemAdvertiserAdsPaused P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemVisibilityStatusElem = "advertiser_ads_paused"
const P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemVisibilityStatusElemAdvertiserApproval P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemVisibilityStatusElem = "advertiser_approval"
const P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemVisibilityStatusElemAdvertiserBalance P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemVisibilityStatusElem = "advertiser_balance"
const P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemVisibilityStatusElemAdvertiserBlockTradeIneligible P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemVisibilityStatusElem = "advertiser_block_trade_ineligible"
const P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemVisibilityStatusElemAdvertiserDailyLimit P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemVisibilityStatusElem = "advertiser_daily_limit"
const P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemVisibilityStatusElemAdvertiserTempBan P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemVisibilityStatusElem = "advertiser_temp_ban"

// Registers the client as a P2P advertiser.
type P2PAdvertiserCreate struct {
	// [Optional] Advertiser's contact information, to be used as a default for new
	// sell adverts.
	ContactInfo *string `json:"contact_info,omitempty"`

	// [Optional] Default description that can be used every time an advert is
	// created.
	DefaultAdvertDescription *string `json:"default_advert_description,omitempty"`

	// The advertiser's displayed name.
	Name string `json:"name"`

	// Must be 1
	P2PAdvertiserCreate P2PAdvertiserCreateP2PAdvertiserCreate `json:"p2p_advertiser_create"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough P2PAdvertiserCreatePassthrough `json:"passthrough,omitempty"`

	// [Optional] Advertiser's payment information, to be used as a default for new
	// sell adverts.
	PaymentInfo *string `json:"payment_info,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// [Optional] If set to 1, will send updates whenever there is an update to
	// advertiser
	Subscribe *P2PAdvertiserCreateSubscribe `json:"subscribe,omitempty"`
}

type P2PAdvertiserCreateP2PAdvertiserCreate int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type P2PAdvertiserCreatePassthrough map[string]interface{}

// Returns information of the created advertiser.
type P2PAdvertiserCreateResp struct {
	// Echo of the request made.
	EchoReq P2PAdvertiserCreateRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType P2PAdvertiserCreateRespMsgType `json:"msg_type"`

	// P2P advertiser information.
	P2PAdvertiserCreate *P2PAdvertiserCreateRespP2PAdvertiserCreate `json:"p2p_advertiser_create,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// For subscription requests only.
	Subscription *P2PAdvertiserCreateRespSubscription `json:"subscription,omitempty"`
}

// Echo of the request made.
type P2PAdvertiserCreateRespEchoReq map[string]interface{}

type P2PAdvertiserCreateRespMsgType string

const P2PAdvertiserCreateRespMsgTypeP2PAdvertiserCreate P2PAdvertiserCreateRespMsgType = "p2p_advertiser_create"

// P2P advertiser information.
type P2PAdvertiserCreateRespP2PAdvertiserCreate struct {
	// Average difference of advert rate compared to the market rate over the past 30
	// days.
	AdvertRates interface{} `json:"advert_rates"`

	// Amount of funds available to sell on P2P. May be less than account balance
	// according to deposit methods used.
	BalanceAvailable float64 `json:"balance_available"`

	// Boolean value: 1 or 0, indicating whether the advertiser's identify has been
	// verified.
	BasicVerification P2PAdvertiserCreateRespP2PAdvertiserCreateBasicVerification `json:"basic_verification"`

	// The number of P2P users who have blocked this advertiser.
	BlockedByCount int `json:"blocked_by_count"`

	// The percentage of completed orders out of total orders as a buyer within the
	// past 30 days.
	BuyCompletionRate interface{} `json:"buy_completion_rate"`

	// Buy order volume in the past 30 days.
	BuyOrdersAmount string `json:"buy_orders_amount"`

	// The number of buy order completed within the past 30 days.
	BuyOrdersCount int `json:"buy_orders_count"`

	// The average time in seconds taken to make payment as a buyer within the past 30
	// days.
	BuyTimeAvg interface{} `json:"buy_time_avg"`

	// The average time in seconds taken to cancel orders as a buyer within the past
	// 30 days.
	CancelTimeAvg interface{} `json:"cancel_time_avg"`

	// The number of times the user may cancel orders before being temporarily
	// blocked.
	CancelsRemaining int `json:"cancels_remaining"`

	// The token to be used for authenticating the client for chat.
	ChatToken interface{} `json:"chat_token"`

	// The unique identifier for the chat user.
	ChatUserId interface{} `json:"chat_user_id"`

	// Advertiser's contact information.
	ContactInfo string `json:"contact_info"`

	// The epoch time that the client became an advertiser.
	CreatedTime int `json:"created_time"`

	// Total value of P2P buy transactions in the past 24 hours.
	DailyBuy *string `json:"daily_buy,omitempty"`

	// Maximum allowed value of P2P buy transactions in a 24 hour period.
	DailyBuyLimit *string `json:"daily_buy_limit,omitempty"`

	// Total value of P2P sell transactions in the past 24 hours.
	DailySell *string `json:"daily_sell,omitempty"`

	// Maximum allowed value of P2P sell transactions in a 24 hour period.
	DailySellLimit *string `json:"daily_sell_limit,omitempty"`

	// Default description that can be used every time an advert is created.
	DefaultAdvertDescription string `json:"default_advert_description"`

	// Boolean value: 1 or 0, indicating whether the advertiser's address has been
	// verified.
	FullVerification P2PAdvertiserCreateRespP2PAdvertiserCreateFullVerification `json:"full_verification"`

	// The advertiser's identification number.
	Id string `json:"id"`

	// The approval status of the advertiser.
	IsApproved P2PAdvertiserCreateRespP2PAdvertiserCreateIsApproved `json:"is_approved"`

	// Indicates if the advertiser's active adverts are listed. When `0`, adverts
	// won't be listed regardless if they are active or not.
	IsListed P2PAdvertiserCreateRespP2PAdvertiserCreateIsListed `json:"is_listed"`

	// Indicates if the advertiser is currently online.
	IsOnline P2PAdvertiserCreateRespP2PAdvertiserCreateIsOnline `json:"is_online"`

	// Epoch of the latest time the advertiser was online, up to 6 months.
	LastOnlineTime interface{} `json:"last_online_time"`

	// Maximum order amount for adverts.
	MaxOrderAmount *string `json:"max_order_amount,omitempty"`

	// Sell ads will be hidden when your available balance or remaining daily sell
	// limit falls beneath this value.
	MinBalance *string `json:"min_balance,omitempty"`

	// Minimum order amount for adverts.
	MinOrderAmount *string `json:"min_order_amount,omitempty"`

	// The advertiser's displayed name.
	Name string `json:"name"`

	// Number of different users the advertiser has traded with since registration.
	PartnerCount int `json:"partner_count"`

	// Advertiser's payment information.
	PaymentInfo string `json:"payment_info"`

	// Average rating of the advertiser, range is 1-5.
	RatingAverage interface{} `json:"rating_average"`

	// Number of ratings given to the advertiser.
	RatingCount int `json:"rating_count"`

	// Percentage of users who have recommended the advertiser.
	RecommendedAverage interface{} `json:"recommended_average"`

	// Number of times the advertiser has been recommended.
	RecommendedCount interface{} `json:"recommended_count"`

	// The average time in seconds taken to release funds as a seller within the past
	// 30 days.
	ReleaseTimeAvg interface{} `json:"release_time_avg"`

	// The percentage of completed orders out of total orders as a seller within the
	// past 30 days.
	SellCompletionRate interface{} `json:"sell_completion_rate"`

	// Sell order volume in the past 30 days.
	SellOrdersAmount string `json:"sell_orders_amount"`

	// The number of sell order orders completed within the past 30 days.
	SellOrdersCount int `json:"sell_orders_count"`

	// When `1`, the advertiser's real name will be displayed to other users on
	// adverts and orders.
	ShowName P2PAdvertiserCreateRespP2PAdvertiserCreateShowName `json:"show_name"`

	// The percentage of completed orders out of all orders within the past 30 days.
	TotalCompletionRate interface{} `json:"total_completion_rate"`

	// The total number of orders completed since advertiser registration.
	TotalOrdersCount int `json:"total_orders_count"`

	// Total order volume since advertiser registration.
	TotalTurnover string `json:"total_turnover"`

	// Remaining withdrawal_limit of a non-fully authenticated advertiser.
	WithdrawalLimit interface{} `json:"withdrawal_limit,omitempty"`
}

type P2PAdvertiserCreateRespP2PAdvertiserCreateBasicVerification int

type P2PAdvertiserCreateRespP2PAdvertiserCreateFullVerification int

type P2PAdvertiserCreateRespP2PAdvertiserCreateIsApproved int

type P2PAdvertiserCreateRespP2PAdvertiserCreateIsListed int

type P2PAdvertiserCreateRespP2PAdvertiserCreateIsOnline int

type P2PAdvertiserCreateRespP2PAdvertiserCreateShowName int

// For subscription requests only.
type P2PAdvertiserCreateRespSubscription struct {
	// A per-connection unique identifier. Can be passed to the `forget` API call to
	// unsubscribe.
	Id string `json:"id"`
}

type P2PAdvertiserCreateSubscribe int

// Retrieve information about a P2P advertiser.
type P2PAdvertiserInfo struct {
	// [Optional] The unique identifier for this advertiser. If not provided, returns
	// advertiser information about the current account.
	Id *string `json:"id,omitempty"`

	// Must be 1
	P2PAdvertiserInfo P2PAdvertiserInfoP2PAdvertiserInfo `json:"p2p_advertiser_info"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough P2PAdvertiserInfoPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// [Optional] If set to 1, will send updates whenever there is an update to
	// advertiser
	Subscribe *P2PAdvertiserInfoSubscribe `json:"subscribe,omitempty"`
}

type P2PAdvertiserInfoP2PAdvertiserInfo int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type P2PAdvertiserInfoPassthrough map[string]interface{}

// Returns information about the given advertiser ID.
type P2PAdvertiserInfoResp struct {
	// Echo of the request made.
	EchoReq P2PAdvertiserInfoRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType P2PAdvertiserInfoRespMsgType `json:"msg_type"`

	// P2P advertiser information.
	P2PAdvertiserInfo *P2PAdvertiserInfoRespP2PAdvertiserInfo `json:"p2p_advertiser_info,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// For subscription requests only.
	Subscription *P2PAdvertiserInfoRespSubscription `json:"subscription,omitempty"`
}

// Echo of the request made.
type P2PAdvertiserInfoRespEchoReq map[string]interface{}

type P2PAdvertiserInfoRespMsgType string

const P2PAdvertiserInfoRespMsgTypeP2PAdvertiserInfo P2PAdvertiserInfoRespMsgType = "p2p_advertiser_info"

// P2P advertiser information.
type P2PAdvertiserInfoRespP2PAdvertiserInfo struct {
	// Number of active fixed rate adverts belonging to the advertiser.
	ActiveFixedAds *int `json:"active_fixed_ads,omitempty"`

	// Number of active floating rate adverts belonging to the advertiser.
	ActiveFloatAds *int `json:"active_float_ads,omitempty"`

	// Average difference of advert rate compared to the market rate over the past 30
	// days.
	AdvertRates interface{} `json:"advert_rates"`

	// Amount of funds available to sell on P2P. May be less than account balance
	// according to deposit methods used.
	BalanceAvailable *float64 `json:"balance_available,omitempty"`

	// Boolean value: 1 or 0, indicating whether the advertiser's identify has been
	// verified.
	BasicVerification P2PAdvertiserInfoRespP2PAdvertiserInfoBasicVerification `json:"basic_verification"`

	// Block trading limits, if block trading is allowed.
	BlockTrade *P2PAdvertiserInfoRespP2PAdvertiserInfoBlockTrade `json:"block_trade,omitempty"`

	// The number of P2P users who have blocked this advertiser.
	BlockedByCount *int `json:"blocked_by_count,omitempty"`

	// If a temporary bar was placed, this is the epoch time at which it will end.
	BlockedUntil *int `json:"blocked_until,omitempty"`

	// The percentage of completed orders out of total orders as a buyer within the
	// past 30 days.
	BuyCompletionRate interface{} `json:"buy_completion_rate"`

	// Buy order volume in the past 30 days.
	BuyOrdersAmount string `json:"buy_orders_amount"`

	// The number of buy order completed within the past 30 days.
	BuyOrdersCount int `json:"buy_orders_count"`

	// The average time in seconds taken to make payment as a buyer within the past 30
	// days.
	BuyTimeAvg interface{} `json:"buy_time_avg"`

	// The average time in seconds taken to cancel orders as a buyer within the past
	// 30 days.
	CancelTimeAvg interface{} `json:"cancel_time_avg"`

	// The number of times the user may cancel orders before being temporarily
	// blocked.
	CancelsRemaining *int `json:"cancels_remaining,omitempty"`

	// The token to be used for authenticating the client for chat.
	ChatToken interface{} `json:"chat_token,omitempty"`

	// The unique identifier for the chat user.
	ChatUserId interface{} `json:"chat_user_id,omitempty"`

	// Advertiser's contact information.
	ContactInfo *string `json:"contact_info,omitempty"`

	// The epoch time that the client became an advertiser.
	CreatedTime int `json:"created_time"`

	// Total value of P2P buy transactions in the past 24 hours.
	DailyBuy *string `json:"daily_buy,omitempty"`

	// Maximum allowed value of P2P buy transactions in a 24 hour period.
	DailyBuyLimit *string `json:"daily_buy_limit,omitempty"`

	// Total value of P2P sell transactions in the past 24 hours.
	DailySell *string `json:"daily_sell,omitempty"`

	// Maximum allowed value of P2P sell transactions in a 24 hour period.
	DailySellLimit *string `json:"daily_sell_limit,omitempty"`

	// Default description that can be used every time an advert is created.
	DefaultAdvertDescription string `json:"default_advert_description"`

	// The advertiser's first name.
	FirstName *string `json:"first_name,omitempty"`

	// Boolean value: 1 or 0, indicating whether the advertiser's address has been
	// verified.
	FullVerification P2PAdvertiserInfoRespP2PAdvertiserInfoFullVerification `json:"full_verification"`

	// The advertiser's identification number.
	Id string `json:"id"`

	// The approval status of the advertiser.
	IsApproved P2PAdvertiserInfoRespP2PAdvertiserInfoIsApproved `json:"is_approved"`

	// Indicates that the advertiser is blocked by the current user.
	IsBlocked *P2PAdvertiserInfoRespP2PAdvertiserInfoIsBlocked `json:"is_blocked,omitempty"`

	// Indicates that the advertiser is a favourite of the current user
	IsFavourite *P2PAdvertiserInfoRespP2PAdvertiserInfoIsFavourite `json:"is_favourite,omitempty"`

	// Indicates if the advertiser's active adverts are listed. When `0`, adverts
	// won't be listed regardless if they are active or not.
	IsListed P2PAdvertiserInfoRespP2PAdvertiserInfoIsListed `json:"is_listed"`

	// Indicates if the advertiser is currently online.
	IsOnline P2PAdvertiserInfoRespP2PAdvertiserInfoIsOnline `json:"is_online"`

	// Indicates that the advertiser was recommended in the most recent review by the
	// current user.
	IsRecommended *P2PAdvertiserInfoRespP2PAdvertiserInfoIsRecommended `json:"is_recommended,omitempty"`

	// The advertiser's last name.
	LastName *string `json:"last_name,omitempty"`

	// Epoch of the latest time the advertiser was online, up to 6 months.
	LastOnlineTime interface{} `json:"last_online_time"`

	// Maximum order amount for adverts.
	MaxOrderAmount *string `json:"max_order_amount,omitempty"`

	// Sell ads will be hidden when your available balance or remaining daily sell
	// limit falls beneath this value.
	MinBalance *string `json:"min_balance,omitempty"`

	// Minimum order amount for adverts.
	MinOrderAmount *string `json:"min_order_amount,omitempty"`

	// The advertiser's displayed name.
	Name string `json:"name"`

	// Number of different users the advertiser has traded with since registration.
	PartnerCount int `json:"partner_count"`

	// Advertiser's payment information.
	PaymentInfo *string `json:"payment_info,omitempty"`

	// Average rating of the advertiser, range is 1-5.
	RatingAverage interface{} `json:"rating_average"`

	// Number of ratings given to the advertiser.
	RatingCount int `json:"rating_count"`

	// Percentage of users who have recommended the advertiser.
	RecommendedAverage interface{} `json:"recommended_average"`

	// Number of times the advertiser has been recommended.
	RecommendedCount interface{} `json:"recommended_count"`

	// The average time in seconds taken to release funds as a seller within the past
	// 30 days.
	ReleaseTimeAvg interface{} `json:"release_time_avg"`

	// The percentage of completed orders out of total orders as a seller within the
	// past 30 days.
	SellCompletionRate interface{} `json:"sell_completion_rate"`

	// Sell order volume in the past 30 days.
	SellOrdersAmount string `json:"sell_orders_amount"`

	// The number of sell order orders completed within the past 30 days.
	SellOrdersCount int `json:"sell_orders_count"`

	// When `1`, the advertiser's real name will be displayed on to other users on
	// adverts and orders.
	ShowName *P2PAdvertiserInfoRespP2PAdvertiserInfoShowName `json:"show_name,omitempty"`

	// The percentage of completed orders out of all orders within the past 30 days.
	TotalCompletionRate interface{} `json:"total_completion_rate"`

	// The total number of orders completed since advertiser registration.
	TotalOrdersCount int `json:"total_orders_count"`

	// Total order volume since advertiser registration.
	TotalTurnover string `json:"total_turnover"`

	// New daily limits available.
	UpgradableDailyLimits *P2PAdvertiserInfoRespP2PAdvertiserInfoUpgradableDailyLimits `json:"upgradable_daily_limits,omitempty"`

	// Remaining withdrawal_limit of a non-fully authenticated advertiser.
	WithdrawalLimit interface{} `json:"withdrawal_limit,omitempty"`
}

type P2PAdvertiserInfoRespP2PAdvertiserInfoBasicVerification int

// Block trading limits, if block trading is allowed.
type P2PAdvertiserInfoRespP2PAdvertiserInfoBlockTrade struct {
	// Maximum order amount for block trade adverts.
	MaxOrderAmount string `json:"max_order_amount"`

	// Minimum order amount for block trade adverts.
	MinOrderAmount string `json:"min_order_amount"`
}

type P2PAdvertiserInfoRespP2PAdvertiserInfoFullVerification int

type P2PAdvertiserInfoRespP2PAdvertiserInfoIsApproved int

type P2PAdvertiserInfoRespP2PAdvertiserInfoIsBlocked int

type P2PAdvertiserInfoRespP2PAdvertiserInfoIsFavourite int

type P2PAdvertiserInfoRespP2PAdvertiserInfoIsListed int

type P2PAdvertiserInfoRespP2PAdvertiserInfoIsOnline int

type P2PAdvertiserInfoRespP2PAdvertiserInfoIsRecommended struct {
	Value interface{}
}

type P2PAdvertiserInfoRespP2PAdvertiserInfoShowName int

// New daily limits available.
type P2PAdvertiserInfoRespP2PAdvertiserInfoUpgradableDailyLimits struct {
	// When `1`, upgrade will provide block trading.
	BlockTrade *P2PAdvertiserInfoRespP2PAdvertiserInfoUpgradableDailyLimitsBlockTrade `json:"block_trade,omitempty"`

	// Upgradable daily buy limit.
	MaxDailyBuy string `json:"max_daily_buy"`

	// Upgradable daily sell limit.
	MaxDailySell string `json:"max_daily_sell"`
}

type P2PAdvertiserInfoRespP2PAdvertiserInfoUpgradableDailyLimitsBlockTrade int

// For subscription requests only.
type P2PAdvertiserInfoRespSubscription struct {
	// A per-connection unique identifier. Can be passed to the `forget` API call to
	// unsubscribe.
	Id string `json:"id"`
}

type P2PAdvertiserInfoSubscribe int

// Retrieve advertisers has/had trade with the current advertiser.
type P2PAdvertiserList struct {
	// [Optional] Search for advertiser by name. Partial matches will be returned.
	AdvertiserName *string `json:"advertiser_name,omitempty"`

	// [Optional] Used to return only blocked or unblocked partners
	IsBlocked *P2PAdvertiserListIsBlocked `json:"is_blocked,omitempty"`

	// [Optional] Used for paging.
	Limit int `json:"limit,omitempty"`

	// [Optional] Used for paging.
	Offset int `json:"offset,omitempty"`

	// Must be 1
	P2PAdvertiserList P2PAdvertiserListP2PAdvertiserList `json:"p2p_advertiser_list"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough P2PAdvertiserListPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// [Optional] How the results are sorted.
	SortBy P2PAdvertiserListSortBy `json:"sort_by,omitempty"`

	// [Optional] Get all advertisers has/had trade.
	TradePartners *P2PAdvertiserListTradePartners `json:"trade_partners,omitempty"`
}

type P2PAdvertiserListIsBlocked int

type P2PAdvertiserListP2PAdvertiserList int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type P2PAdvertiserListPassthrough map[string]interface{}

// Retrieve advertisers has/had trade with the current advertiser.
type P2PAdvertiserListResp struct {
	// Echo of the request made.
	EchoReq P2PAdvertiserListRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType P2PAdvertiserListRespMsgType `json:"msg_type"`

	// P2P advertiser list.
	P2PAdvertiserList *P2PAdvertiserListRespP2PAdvertiserList `json:"p2p_advertiser_list,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type P2PAdvertiserListRespEchoReq map[string]interface{}

type P2PAdvertiserListRespMsgType string

const P2PAdvertiserListRespMsgTypeP2PAdvertiserList P2PAdvertiserListRespMsgType = "p2p_advertiser_list"

// P2P advertiser list.
type P2PAdvertiserListRespP2PAdvertiserList struct {
	// List of advertisers.
	List []P2PAdvertiserListRespP2PAdvertiserListListElem `json:"list"`
}

type P2PAdvertiserListRespP2PAdvertiserListListElem struct {
	// Average difference of advert rate compared to the market rate over the past 30
	// days.
	AdvertRates interface{} `json:"advert_rates"`

	// Boolean value: 1 or 0, indicating whether the advertiser's identify has been
	// verified.
	BasicVerification P2PAdvertiserListRespP2PAdvertiserListListElemBasicVerification `json:"basic_verification"`

	// The percentage of completed orders out of total orders as a buyer within the
	// past 30 days.
	BuyCompletionRate interface{} `json:"buy_completion_rate"`

	// Buy order volume in the past 30 days.
	BuyOrdersAmount string `json:"buy_orders_amount"`

	// The number of buy order completed within the past 30 days.
	BuyOrdersCount int `json:"buy_orders_count"`

	// The average time in seconds taken to make payment as a buyer within the past 30
	// days.
	BuyTimeAvg interface{} `json:"buy_time_avg"`

	// The average time in seconds taken to cancel orders as a buyer within the past
	// 30 days.
	CancelTimeAvg interface{} `json:"cancel_time_avg"`

	// The epoch time that the trade partner became an advertiser.
	CreatedTime int `json:"created_time"`

	// Default description that can be used every time an advert is created.
	DefaultAdvertDescription string `json:"default_advert_description"`

	// The advertiser's first name.
	FirstName *string `json:"first_name,omitempty"`

	// Boolean value: 1 or 0, indicating whether the advertiser's address has been
	// verified.
	FullVerification P2PAdvertiserListRespP2PAdvertiserListListElemFullVerification `json:"full_verification"`

	// The advertiser's identification number.
	Id string `json:"id"`

	// The approval status of the advertiser.
	IsApproved P2PAdvertiserListRespP2PAdvertiserListListElemIsApproved `json:"is_approved"`

	// Indicates that the advertiser is blocked by the current user.
	IsBlocked P2PAdvertiserListRespP2PAdvertiserListListElemIsBlocked `json:"is_blocked"`

	// Indicates if the trade partner is favourited by requester.
	IsFavourite *P2PAdvertiserListRespP2PAdvertiserListListElemIsFavourite `json:"is_favourite,omitempty"`

	// Indicates if the advertiser's active adverts are listed. When `0`, adverts
	// won't be listed regardless if they are active or not.
	IsListed P2PAdvertiserListRespP2PAdvertiserListListElemIsListed `json:"is_listed"`

	// Indicates if the advertiser is currently online.
	IsOnline P2PAdvertiserListRespP2PAdvertiserListListElemIsOnline `json:"is_online"`

	// Indicates if the trade partner is recommended by requester.
	IsRecommended *P2PAdvertiserListRespP2PAdvertiserListListElemIsRecommended `json:"is_recommended,omitempty"`

	// The advertiser's last name.
	LastName *string `json:"last_name,omitempty"`

	// Epoch of the latest time the advertiser was online, up to 6 months.
	LastOnlineTime interface{} `json:"last_online_time"`

	// The advertiser's displayed name.
	Name string `json:"name"`

	// Number of different users the advertiser has traded with since registration.
	PartnerCount int `json:"partner_count"`

	// Average rating of the advertiser, range is 1-5.
	RatingAverage interface{} `json:"rating_average"`

	// Number of ratings given to the advertiser.
	RatingCount int `json:"rating_count"`

	// Percentage of users who have recommended the advertiser.
	RecommendedAverage interface{} `json:"recommended_average"`

	// Number of times the advertiser has been recommended.
	RecommendedCount interface{} `json:"recommended_count"`

	// The average time in seconds taken to release funds as a seller within the past
	// 30 days.
	ReleaseTimeAvg interface{} `json:"release_time_avg"`

	// The percentage of completed orders out of total orders as a seller within the
	// past 30 days.
	SellCompletionRate interface{} `json:"sell_completion_rate"`

	// Sell order volume in the past 30 days.
	SellOrdersAmount string `json:"sell_orders_amount"`

	// The number of sell order orders completed within the past 30 days.
	SellOrdersCount int `json:"sell_orders_count"`

	// The percentage of completed orders out of all orders within the past 30 days.
	TotalCompletionRate interface{} `json:"total_completion_rate"`

	// The total number of orders completed since advertiser registration.
	TotalOrdersCount int `json:"total_orders_count"`

	// Total order volume since advertiser registration.
	TotalTurnover string `json:"total_turnover"`
}

type P2PAdvertiserListRespP2PAdvertiserListListElemBasicVerification int

type P2PAdvertiserListRespP2PAdvertiserListListElemFullVerification int

type P2PAdvertiserListRespP2PAdvertiserListListElemIsApproved int

type P2PAdvertiserListRespP2PAdvertiserListListElemIsBlocked int

type P2PAdvertiserListRespP2PAdvertiserListListElemIsFavourite int

type P2PAdvertiserListRespP2PAdvertiserListListElemIsListed int

type P2PAdvertiserListRespP2PAdvertiserListListElemIsOnline int

type P2PAdvertiserListRespP2PAdvertiserListListElemIsRecommended int

type P2PAdvertiserListSortBy string

const P2PAdvertiserListSortByCreatedTime P2PAdvertiserListSortBy = "created_time"
const P2PAdvertiserListSortByLastInteractionTime P2PAdvertiserListSortBy = "last_interaction_time"
const P2PAdvertiserListSortByName P2PAdvertiserListSortBy = "name"

type P2PAdvertiserListTradePartners int

// Manage or list P2P advertiser payment methods.
type P2PAdvertiserPaymentMethods struct {
	// Contains new payment method entries.
	Create []P2PAdvertiserPaymentMethodsCreateElem `json:"create,omitempty"`

	// Contains payment methods to delete.
	Delete []float64 `json:"delete,omitempty"`

	// Must be 1
	P2PAdvertiserPaymentMethods P2PAdvertiserPaymentMethodsP2PAdvertiserPaymentMethods `json:"p2p_advertiser_payment_methods"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough P2PAdvertiserPaymentMethodsPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// Contains payment methods to update.
	Update P2PAdvertiserPaymentMethodsUpdate `json:"update,omitempty"`
}

type P2PAdvertiserPaymentMethodsCreateElem struct {
	// Payment method identifer.
	Method string `json:"method"`
}

type P2PAdvertiserPaymentMethodsP2PAdvertiserPaymentMethods int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type P2PAdvertiserPaymentMethodsPassthrough map[string]interface{}

// List P2P advertiser payment methods.
type P2PAdvertiserPaymentMethodsResp struct {
	// Echo of the request made.
	EchoReq P2PAdvertiserPaymentMethodsRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType P2PAdvertiserPaymentMethodsRespMsgType `json:"msg_type"`

	// List of current methods.
	P2PAdvertiserPaymentMethods P2PAdvertiserPaymentMethodsRespP2PAdvertiserPaymentMethods `json:"p2p_advertiser_payment_methods,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type P2PAdvertiserPaymentMethodsRespEchoReq map[string]interface{}

type P2PAdvertiserPaymentMethodsRespMsgType string

const P2PAdvertiserPaymentMethodsRespMsgTypeP2PAdvertiserPaymentMethods P2PAdvertiserPaymentMethodsRespMsgType = "p2p_advertiser_payment_methods"

// List of current methods.
type P2PAdvertiserPaymentMethodsRespP2PAdvertiserPaymentMethods map[string]interface{}

// Contains payment methods to update.
type P2PAdvertiserPaymentMethodsUpdate map[string]interface{}

// Updates and returns favourite and blocked advertisers of the current user.
type P2PAdvertiserRelations struct {
	// IDs of advertisers to block.
	AddBlocked []float64 `json:"add_blocked,omitempty"`

	// IDs of advertisers to add as favourites.
	AddFavourites []float64 `json:"add_favourites,omitempty"`

	// Must be 1
	P2PAdvertiserRelations P2PAdvertiserRelationsP2PAdvertiserRelations `json:"p2p_advertiser_relations"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough P2PAdvertiserRelationsPassthrough `json:"passthrough,omitempty"`

	// IDs of advertisers to remove from blocked.
	RemoveBlocked []float64 `json:"remove_blocked,omitempty"`

	// IDs of advertisers to remove from favourites.
	RemoveFavourites []float64 `json:"remove_favourites,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type P2PAdvertiserRelationsP2PAdvertiserRelations int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type P2PAdvertiserRelationsPassthrough map[string]interface{}

// Returns information about favourite and blocked advertisers.
type P2PAdvertiserRelationsResp struct {
	// Echo of the request made.
	EchoReq P2PAdvertiserRelationsRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType P2PAdvertiserRelationsRespMsgType `json:"msg_type"`

	// P2P advertiser relations information.
	P2PAdvertiserRelations *P2PAdvertiserRelationsRespP2PAdvertiserRelations `json:"p2p_advertiser_relations,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type P2PAdvertiserRelationsRespEchoReq map[string]interface{}

type P2PAdvertiserRelationsRespMsgType string

const P2PAdvertiserRelationsRespMsgTypeP2PAdvertiserRelations P2PAdvertiserRelationsRespMsgType = "p2p_advertiser_relations"

// P2P advertiser relations information.
type P2PAdvertiserRelationsRespP2PAdvertiserRelations struct {
	// List of advertisers blocked by the current user.
	BlockedAdvertisers []P2PAdvertiserRelationsRespP2PAdvertiserRelationsBlockedAdvertisersElem `json:"blocked_advertisers"`

	// Favourite advertisers of the current user.
	FavouriteAdvertisers []P2PAdvertiserRelationsRespP2PAdvertiserRelationsFavouriteAdvertisersElem `json:"favourite_advertisers"`
}

// Advertiser details.
type P2PAdvertiserRelationsRespP2PAdvertiserRelationsBlockedAdvertisersElem struct {
	// The epoch time that the advertiser was blocked.
	CreatedTime *int `json:"created_time,omitempty"`

	// Advertiser unique identifer.
	Id *string `json:"id,omitempty"`

	// Advertiser displayed name.
	Name *string `json:"name,omitempty"`
}

// Advertiser details.
type P2PAdvertiserRelationsRespP2PAdvertiserRelationsFavouriteAdvertisersElem struct {
	// The epoch time that the advertiser was set as favourite.
	CreatedTime *int `json:"created_time,omitempty"`

	// Advertiser unique identifer.
	Id *string `json:"id,omitempty"`

	// Advertiser displayed name.
	Name *string `json:"name,omitempty"`
}

// Update the information of the P2P advertiser for the current account. Can only
// be used by an approved P2P advertiser.
type P2PAdvertiserUpdate struct {
	// [Optional] Advertiser's contact information, to be used as a default for new
	// sell adverts.
	ContactInfo *string `json:"contact_info,omitempty"`

	// [Optional] Default description that can be used every time an advert is
	// created.
	DefaultAdvertDescription *string `json:"default_advert_description,omitempty"`

	// [Optional] Used to set if the advertiser's adverts could be listed. When `0`,
	// adverts won't be listed regardless of they are active or not. This doesn't
	// change the `is_active` of each individual advert.
	IsListed *P2PAdvertiserUpdateIsListed `json:"is_listed,omitempty"`

	// Must be 1
	P2PAdvertiserUpdate P2PAdvertiserUpdateP2PAdvertiserUpdate `json:"p2p_advertiser_update"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough P2PAdvertiserUpdatePassthrough `json:"passthrough,omitempty"`

	// [Optional] Advertiser's payment information, to be used as a default for new
	// sell adverts.
	PaymentInfo *string `json:"payment_info,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// [Optional] When `1`, the advertiser's real name will be displayed on to other
	// users on adverts and orders.
	ShowName *P2PAdvertiserUpdateShowName `json:"show_name,omitempty"`

	// [Optional] Used to upgrade daily limits of eligible advertiser.
	UpgradeLimits *P2PAdvertiserUpdateUpgradeLimits `json:"upgrade_limits,omitempty"`
}

type P2PAdvertiserUpdateIsListed int

type P2PAdvertiserUpdateP2PAdvertiserUpdate int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type P2PAdvertiserUpdatePassthrough map[string]interface{}

// Returns latest information of the advertiser.
type P2PAdvertiserUpdateResp struct {
	// Echo of the request made.
	EchoReq P2PAdvertiserUpdateRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType P2PAdvertiserUpdateRespMsgType `json:"msg_type"`

	// P2P advertiser information.
	P2PAdvertiserUpdate *P2PAdvertiserUpdateRespP2PAdvertiserUpdate `json:"p2p_advertiser_update,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type P2PAdvertiserUpdateRespEchoReq map[string]interface{}

type P2PAdvertiserUpdateRespMsgType string

const P2PAdvertiserUpdateRespMsgTypeP2PAdvertiserUpdate P2PAdvertiserUpdateRespMsgType = "p2p_advertiser_update"

// P2P advertiser information.
type P2PAdvertiserUpdateRespP2PAdvertiserUpdate struct {
	// Number of active fixed rate adverts belonging to the advertiser.
	ActiveFixedAds *int `json:"active_fixed_ads,omitempty"`

	// Number of active floating rate adverts belonging to the advertiser.
	ActiveFloatAds *int `json:"active_float_ads,omitempty"`

	// Average difference of advert rate compared to the market rate over the past 30
	// days.
	AdvertRates interface{} `json:"advert_rates"`

	// Amount of funds available to sell on P2P. May be less than account balance
	// according to deposit methods used.
	BalanceAvailable float64 `json:"balance_available"`

	// Boolean value: 1 or 0, indicating whether the advertiser's identify has been
	// verified.
	BasicVerification P2PAdvertiserUpdateRespP2PAdvertiserUpdateBasicVerification `json:"basic_verification"`

	// Block trading limits, if block trading is allowed.
	BlockTrade *P2PAdvertiserUpdateRespP2PAdvertiserUpdateBlockTrade `json:"block_trade,omitempty"`

	// The number of P2P users who have blocked this advertiser.
	BlockedByCount int `json:"blocked_by_count"`

	// If a temporary bar was placed, this is the epoch time at which it will end.
	BlockedUntil *int `json:"blocked_until,omitempty"`

	// The percentage of completed orders out of total orders as a buyer within the
	// past 30 days.
	BuyCompletionRate interface{} `json:"buy_completion_rate"`

	// Buy order volume in the past 30 days.
	BuyOrdersAmount string `json:"buy_orders_amount"`

	// The number of buy order completed within the past 30 days.
	BuyOrdersCount int `json:"buy_orders_count"`

	// The average time in seconds taken to make payment as a buyer within the past 30
	// days.
	BuyTimeAvg interface{} `json:"buy_time_avg"`

	// The average time in seconds taken to cancel orders as a buyer within the past
	// 30 days.
	CancelTimeAvg interface{} `json:"cancel_time_avg"`

	// The number of times the user may cancel orders before being temporarily
	// blocked.
	CancelsRemaining int `json:"cancels_remaining"`

	// The token to be used for authenticating the client for chat.
	ChatToken interface{} `json:"chat_token"`

	// The unique identifier for the chat user.
	ChatUserId interface{} `json:"chat_user_id"`

	// Advertiser's contact information.
	ContactInfo string `json:"contact_info"`

	// The epoch time that the client became an advertiser.
	CreatedTime int `json:"created_time"`

	// Total value of P2P buy transactions in the past 24 hours.
	DailyBuy *string `json:"daily_buy,omitempty"`

	// Maximum allowed value of P2P buy transactions in a 24 hour period.
	DailyBuyLimit *string `json:"daily_buy_limit,omitempty"`

	// Total value of P2P sell transactions in the past 24 hours.
	DailySell *string `json:"daily_sell,omitempty"`

	// Maximum allowed value of P2P sell transactions in a 24 hour period.
	DailySellLimit *string `json:"daily_sell_limit,omitempty"`

	// Default description that can be used every time an advert is created.
	DefaultAdvertDescription string `json:"default_advert_description"`

	// The advertiser's first name.
	FirstName *string `json:"first_name,omitempty"`

	// Boolean value: 1 or 0, indicating whether the advertiser's address has been
	// verified.
	FullVerification P2PAdvertiserUpdateRespP2PAdvertiserUpdateFullVerification `json:"full_verification"`

	// The advertiser's identification number.
	Id string `json:"id"`

	// The approval status of the advertiser.
	IsApproved P2PAdvertiserUpdateRespP2PAdvertiserUpdateIsApproved `json:"is_approved"`

	// Indicates if the advertiser's active adverts are listed. When `0`, adverts
	// won't be listed regardless if they are active or not.
	IsListed P2PAdvertiserUpdateRespP2PAdvertiserUpdateIsListed `json:"is_listed"`

	// Indicates if the advertiser is currently online.
	IsOnline P2PAdvertiserUpdateRespP2PAdvertiserUpdateIsOnline `json:"is_online"`

	// The advertiser's last name.
	LastName *string `json:"last_name,omitempty"`

	// Epoch of the latest time the advertiser was online, up to 6 months.
	LastOnlineTime interface{} `json:"last_online_time"`

	// Maximum order amount for adverts.
	MaxOrderAmount *string `json:"max_order_amount,omitempty"`

	// Sell ads will be hidden when your available balance or remaining daily sell
	// limit falls beneath this value.
	MinBalance *string `json:"min_balance,omitempty"`

	// Minimum order amount for adverts.
	MinOrderAmount *string `json:"min_order_amount,omitempty"`

	// The advertiser's displayed name.
	Name string `json:"name"`

	// Number of different users the advertiser has traded with since registration.
	PartnerCount int `json:"partner_count"`

	// Advertiser's payment information.
	PaymentInfo string `json:"payment_info"`

	// Average rating of the advertiser, range is 1-5.
	RatingAverage interface{} `json:"rating_average"`

	// Number of ratings given to the advertiser.
	RatingCount int `json:"rating_count"`

	// Percentage of users who have recommended the advertiser.
	RecommendedAverage interface{} `json:"recommended_average"`

	// Number of times the advertiser has been recommended.
	RecommendedCount interface{} `json:"recommended_count"`

	// The average time in seconds taken to release funds as a seller within the past
	// 30 days.
	ReleaseTimeAvg interface{} `json:"release_time_avg"`

	// The percentage of completed orders out of total orders as a seller within the
	// past 30 days.
	SellCompletionRate interface{} `json:"sell_completion_rate"`

	// Sell order volume in the past 30 days.
	SellOrdersAmount string `json:"sell_orders_amount"`

	// The number of sell order orders completed within the past 30 days.
	SellOrdersCount int `json:"sell_orders_count"`

	// When `1`, the advertiser's real name will be displayed on to other users on
	// adverts and orders.
	ShowName P2PAdvertiserUpdateRespP2PAdvertiserUpdateShowName `json:"show_name"`

	// The percentage of completed orders out of all orders within the past 30 days.
	TotalCompletionRate interface{} `json:"total_completion_rate"`

	// The total number of orders completed since advertiser registration.
	TotalOrdersCount int `json:"total_orders_count"`

	// Total order volume since advertiser registration.
	TotalTurnover string `json:"total_turnover"`

	// New daily limits available.
	UpgradableDailyLimits *P2PAdvertiserUpdateRespP2PAdvertiserUpdateUpgradableDailyLimits `json:"upgradable_daily_limits,omitempty"`

	// Remaining withdrawal_limit of a non-fully authenticated advertiser.
	WithdrawalLimit interface{} `json:"withdrawal_limit,omitempty"`
}

type P2PAdvertiserUpdateRespP2PAdvertiserUpdateBasicVerification int

// Block trading limits, if block trading is allowed.
type P2PAdvertiserUpdateRespP2PAdvertiserUpdateBlockTrade struct {
	// Maximum order amount for block trade adverts.
	MaxOrderAmount string `json:"max_order_amount"`

	// Minimum order amount for block trade adverts.
	MinOrderAmount string `json:"min_order_amount"`
}

type P2PAdvertiserUpdateRespP2PAdvertiserUpdateFullVerification int

type P2PAdvertiserUpdateRespP2PAdvertiserUpdateIsApproved int

type P2PAdvertiserUpdateRespP2PAdvertiserUpdateIsListed int

type P2PAdvertiserUpdateRespP2PAdvertiserUpdateIsOnline int

type P2PAdvertiserUpdateRespP2PAdvertiserUpdateShowName int

// New daily limits available.
type P2PAdvertiserUpdateRespP2PAdvertiserUpdateUpgradableDailyLimits struct {
	// When `1`, upgrade will provide block trading.
	BlockTrade *P2PAdvertiserUpdateRespP2PAdvertiserUpdateUpgradableDailyLimitsBlockTrade `json:"block_trade,omitempty"`

	// Upgradable daily buy limit.
	MaxDailyBuy string `json:"max_daily_buy"`

	// Upgradable daily sell limit.
	MaxDailySell string `json:"max_daily_sell"`
}

type P2PAdvertiserUpdateRespP2PAdvertiserUpdateUpgradableDailyLimitsBlockTrade int

type P2PAdvertiserUpdateShowName int

type P2PAdvertiserUpdateUpgradeLimits int

// Creates a P2P chat for the specified order.
type P2PChatCreate struct {
	// The unique identifier for the order to create the chat for.
	OrderId string `json:"order_id"`

	// Must be 1
	P2PChatCreate P2PChatCreateP2PChatCreate `json:"p2p_chat_create"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough P2PChatCreatePassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type P2PChatCreateP2PChatCreate int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type P2PChatCreatePassthrough map[string]interface{}

// Information of the created P2P chat.
type P2PChatCreateResp struct {
	// Echo of the request made.
	EchoReq P2PChatCreateRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType P2PChatCreateRespMsgType `json:"msg_type"`

	// Information of the P2P chat.
	P2PChatCreate *P2PChatCreateRespP2PChatCreate `json:"p2p_chat_create,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type P2PChatCreateRespEchoReq map[string]interface{}

type P2PChatCreateRespMsgType string

const P2PChatCreateRespMsgTypeP2PChatCreate P2PChatCreateRespMsgType = "p2p_chat_create"

// Information of the P2P chat.
type P2PChatCreateRespP2PChatCreate struct {
	// The URL to be used to initialise the chat for the requested order.
	ChannelUrl string `json:"channel_url"`

	// The unique identifier for the order that the chat belongs to.
	OrderId string `json:"order_id"`
}

// Cancel a P2P order.
type P2POrderCancel struct {
	// The unique identifier for this order.
	Id string `json:"id"`

	// Must be 1
	P2POrderCancel P2POrderCancelP2POrderCancel `json:"p2p_order_cancel"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough P2POrderCancelPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type P2POrderCancelP2POrderCancel int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type P2POrderCancelPassthrough map[string]interface{}

// Result of the P2P order cancellation.
type P2POrderCancelResp struct {
	// Echo of the request made.
	EchoReq P2POrderCancelRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType P2POrderCancelRespMsgType `json:"msg_type"`

	// Cancellation details
	P2POrderCancel *P2POrderCancelRespP2POrderCancel `json:"p2p_order_cancel,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type P2POrderCancelRespEchoReq map[string]interface{}

type P2POrderCancelRespMsgType string

const P2POrderCancelRespMsgTypeP2POrderCancel P2POrderCancelRespMsgType = "p2p_order_cancel"

// Cancellation details
type P2POrderCancelRespP2POrderCancel struct {
	// The unique identifier for the order.
	Id string `json:"id"`

	// The new status of the order.
	Status P2POrderCancelRespP2POrderCancelStatus `json:"status"`
}

type P2POrderCancelRespP2POrderCancelStatus string

const P2POrderCancelRespP2POrderCancelStatusCancelled P2POrderCancelRespP2POrderCancelStatus = "cancelled"

// Confirm a P2P order.
type P2POrderConfirm struct {
	// [Optional] If set to `1`, only validation is performed.
	DryRun P2POrderConfirmDryRun `json:"dry_run,omitempty"`

	// The unique identifier for this order.
	Id string `json:"id"`

	// Must be 1
	P2POrderConfirm P2POrderConfirmP2POrderConfirm `json:"p2p_order_confirm"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough P2POrderConfirmPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// [Optional] Verification code received from email.
	VerificationCode *string `json:"verification_code,omitempty"`
}

type P2POrderConfirmDryRun int

type P2POrderConfirmP2POrderConfirm int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type P2POrderConfirmPassthrough map[string]interface{}

// Result of the P2P order confirmation.
type P2POrderConfirmResp struct {
	// Echo of the request made.
	EchoReq P2POrderConfirmRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType P2POrderConfirmRespMsgType `json:"msg_type"`

	// Confirmation details
	P2POrderConfirm *P2POrderConfirmRespP2POrderConfirm `json:"p2p_order_confirm,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type P2POrderConfirmRespEchoReq map[string]interface{}

type P2POrderConfirmRespMsgType string

const P2POrderConfirmRespMsgTypeP2POrderConfirm P2POrderConfirmRespMsgType = "p2p_order_confirm"

// Confirmation details
type P2POrderConfirmRespP2POrderConfirm struct {
	// The `dry_run` was successful.
	DryRun *P2POrderConfirmRespP2POrderConfirmDryRun `json:"dry_run,omitempty"`

	// The unique identifier for the order.
	Id string `json:"id"`

	// The new status of the order.
	Status *P2POrderConfirmRespP2POrderConfirmStatus `json:"status,omitempty"`
}

type P2POrderConfirmRespP2POrderConfirmDryRun int

type P2POrderConfirmRespP2POrderConfirmStatus string

const P2POrderConfirmRespP2POrderConfirmStatusBuyerConfirmed P2POrderConfirmRespP2POrderConfirmStatus = "buyer-confirmed"
const P2POrderConfirmRespP2POrderConfirmStatusCompleted P2POrderConfirmRespP2POrderConfirmStatus = "completed"

// Creates a P2P order for the specified advert.
type P2POrderCreate struct {
	// The unique identifier for the advert to create an order against.
	AdvertId string `json:"advert_id"`

	// The amount of currency to be bought or sold.
	Amount float64 `json:"amount"`

	// [Optional] Seller contact information. Only applicable for 'sell orders'.
	ContactInfo *string `json:"contact_info,omitempty"`

	// Must be 1
	P2POrderCreate P2POrderCreateP2POrderCreate `json:"p2p_order_create"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough P2POrderCreatePassthrough `json:"passthrough,omitempty"`

	// [Optional] Payment instructions, only applicable for sell orders.
	PaymentInfo *string `json:"payment_info,omitempty"`

	// IDs of payment methods, only applicable for sell orders.
	PaymentMethodIds []int `json:"payment_method_ids,omitempty"`

	// [Optional] Conversion rate from account currency to local currency, only
	// applicable for floating rate adverts.
	Rate *float64 `json:"rate,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// [Optional] If set to 1, will send updates whenever there is an update to the
	// order.
	Subscribe *P2POrderCreateSubscribe `json:"subscribe,omitempty"`
}

type P2POrderCreateP2POrderCreate int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type P2POrderCreatePassthrough map[string]interface{}

// The information about the created P2P order.
type P2POrderCreateResp struct {
	// Echo of the request made.
	EchoReq P2POrderCreateRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType P2POrderCreateRespMsgType `json:"msg_type"`

	// Information of the creates P2P order.
	P2POrderCreate *P2POrderCreateRespP2POrderCreate `json:"p2p_order_create,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// For subscription requests only.
	Subscription *P2POrderCreateRespSubscription `json:"subscription,omitempty"`
}

// Echo of the request made.
type P2POrderCreateRespEchoReq map[string]interface{}

type P2POrderCreateRespMsgType string

const P2POrderCreateRespMsgTypeP2POrderCreate P2POrderCreateRespMsgType = "p2p_order_create"

// Information of the creates P2P order.
type P2POrderCreateRespP2POrderCreate struct {
	// The currency of order.
	AccountCurrency string `json:"account_currency"`

	// Details of the advert for this order.
	AdvertDetails P2POrderCreateRespP2POrderCreateAdvertDetails `json:"advert_details"`

	// Details of the advertiser for this order.
	AdvertiserDetails P2POrderCreateRespP2POrderCreateAdvertiserDetails `json:"advertiser_details"`

	// The amount of the order.
	Amount float64 `json:"amount"`

	// The amount of the order, formatted to appropriate decimal places.
	AmountDisplay string `json:"amount_display"`

	// The URL to be used to initialise the chat for this order.
	ChatChannelUrl string `json:"chat_channel_url"`

	// Details of the client who created the order.
	ClientDetails P2POrderCreateRespP2POrderCreateClientDetails `json:"client_details"`

	// Seller contact information.
	ContactInfo string `json:"contact_info"`

	// The epoch time of the order creation.
	CreatedTime int `json:"created_time"`

	// Details of the order dispute.
	DisputeDetails P2POrderCreateRespP2POrderCreateDisputeDetails `json:"dispute_details"`

	// The epoch time in which the order will be expired.
	ExpiryTime int `json:"expiry_time"`

	// The unique identifier for this order.
	Id string `json:"id"`

	// `1` if the order is created for the advert of the current client, otherwise
	// `0`.
	IsIncoming P2POrderCreateRespP2POrderCreateIsIncoming `json:"is_incoming"`

	// `1` if a review can be given, otherwise `0`.
	IsReviewable P2POrderCreateRespP2POrderCreateIsReviewable `json:"is_reviewable"`

	// `1` if the latest order changes have been seen by the current client, otherwise
	// `0`.
	IsSeen P2POrderCreateRespP2POrderCreateIsSeen `json:"is_seen"`

	// Local currency for this order.
	LocalCurrency string `json:"local_currency"`

	// Payment instructions.
	PaymentInfo string `json:"payment_info"`

	// Supported payment methods. Comma separated list.
	PaymentMethod interface{} `json:"payment_method,omitempty"`

	// Details of available payment methods.
	PaymentMethodDetails P2POrderCreateRespP2POrderCreatePaymentMethodDetails `json:"payment_method_details,omitempty"`

	// Cost in local currency.
	Price float64 `json:"price"`

	// Cost in local currency, formatted to appropriate decimal places.
	PriceDisplay string `json:"price_display"`

	// Conversion rate of the order.
	Rate float64 `json:"rate"`

	// Conversion rate of the order, formatted to appropriate decimal places.
	RateDisplay string `json:"rate_display"`

	// The status of the created order.
	Status P2POrderCreateRespP2POrderCreateStatus `json:"status"`

	// Type of the order.
	Type P2POrderCreateRespP2POrderCreateType `json:"type"`
}

// Details of the advert for this order.
type P2POrderCreateRespP2POrderCreateAdvertDetails struct {
	// Indicates if this is block trade advert or not.
	BlockTrade P2POrderCreateRespP2POrderCreateAdvertDetailsBlockTrade `json:"block_trade"`

	// General information about the advert.
	Description string `json:"description"`

	// The unique identifier for the advert.
	Id string `json:"id"`

	// The payment method.
	PaymentMethod interface{} `json:"payment_method"`

	// Type of the advert.
	Type P2POrderCreateRespP2POrderCreateAdvertDetailsType `json:"type"`
}

type P2POrderCreateRespP2POrderCreateAdvertDetailsBlockTrade int

type P2POrderCreateRespP2POrderCreateAdvertDetailsType string

const P2POrderCreateRespP2POrderCreateAdvertDetailsTypeBuy P2POrderCreateRespP2POrderCreateAdvertDetailsType = "buy"
const P2POrderCreateRespP2POrderCreateAdvertDetailsTypeSell P2POrderCreateRespP2POrderCreateAdvertDetailsType = "sell"

// Details of the advertiser for this order.
type P2POrderCreateRespP2POrderCreateAdvertiserDetails struct {
	// The advertiser's first name.
	FirstName *string `json:"first_name,omitempty"`

	// The advertiser's unique identifier.
	Id string `json:"id"`

	// Indicates if the advertiser is currently online.
	IsOnline P2POrderCreateRespP2POrderCreateAdvertiserDetailsIsOnline `json:"is_online"`

	// The advertiser's last name.
	LastName *string `json:"last_name,omitempty"`

	// Epoch of the latest time the advertiser was online, up to 6 months.
	LastOnlineTime interface{} `json:"last_online_time"`

	// The advertiser's account identifier.
	Loginid string `json:"loginid"`

	// The advertiser's displayed name.
	Name string `json:"name"`
}

type P2POrderCreateRespP2POrderCreateAdvertiserDetailsIsOnline int

// Details of the client who created the order.
type P2POrderCreateRespP2POrderCreateClientDetails struct {
	// The client's first name.
	FirstName *string `json:"first_name,omitempty"`

	// The client's unique P2P identifier.
	Id string `json:"id"`

	// Indicates if the advertiser is currently online.
	IsOnline P2POrderCreateRespP2POrderCreateClientDetailsIsOnline `json:"is_online"`

	// The client's last name.
	LastName *string `json:"last_name,omitempty"`

	// Epoch of the latest time the advertiser was online, up to 6 months.
	LastOnlineTime interface{} `json:"last_online_time"`

	// The client's account identifier.
	Loginid string `json:"loginid"`

	// The client's displayed name.
	Name string `json:"name"`
}

type P2POrderCreateRespP2POrderCreateClientDetailsIsOnline int

// Details of the order dispute.
type P2POrderCreateRespP2POrderCreateDisputeDetails struct {
	// The dispute reason
	DisputeReason interface{} `json:"dispute_reason"`

	// The loginid of the client who's raising the dispute
	DisputerLoginid interface{} `json:"disputer_loginid"`
}

type P2POrderCreateRespP2POrderCreateIsIncoming int

type P2POrderCreateRespP2POrderCreateIsReviewable int

type P2POrderCreateRespP2POrderCreateIsSeen int

// Details of available payment methods.
type P2POrderCreateRespP2POrderCreatePaymentMethodDetails map[string]interface{}

type P2POrderCreateRespP2POrderCreateStatus string

const P2POrderCreateRespP2POrderCreateStatusPending P2POrderCreateRespP2POrderCreateStatus = "pending"

type P2POrderCreateRespP2POrderCreateType string

const P2POrderCreateRespP2POrderCreateTypeBuy P2POrderCreateRespP2POrderCreateType = "buy"
const P2POrderCreateRespP2POrderCreateTypeSell P2POrderCreateRespP2POrderCreateType = "sell"

// For subscription requests only.
type P2POrderCreateRespSubscription struct {
	// A per-connection unique identifier. Can be passed to the `forget` API call to
	// unsubscribe.
	Id string `json:"id"`
}

type P2POrderCreateSubscribe int

// Dispute a P2P order.
type P2POrderDispute struct {
	// The predefined dispute reason
	DisputeReason P2POrderDisputeDisputeReason `json:"dispute_reason"`

	// The unique identifier for this order.
	Id string `json:"id"`

	// Must be 1
	P2POrderDispute P2POrderDisputeP2POrderDispute `json:"p2p_order_dispute"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough P2POrderDisputePassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type P2POrderDisputeDisputeReason string

const P2POrderDisputeDisputeReasonBuyerNotPaid P2POrderDisputeDisputeReason = "buyer_not_paid"
const P2POrderDisputeDisputeReasonBuyerOverpaid P2POrderDisputeDisputeReason = "buyer_overpaid"
const P2POrderDisputeDisputeReasonBuyerThirdPartyPaymentMethod P2POrderDisputeDisputeReason = "buyer_third_party_payment_method"
const P2POrderDisputeDisputeReasonBuyerUnderpaid P2POrderDisputeDisputeReason = "buyer_underpaid"
const P2POrderDisputeDisputeReasonSellerNotReleased P2POrderDisputeDisputeReason = "seller_not_released"

type P2POrderDisputeP2POrderDispute int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type P2POrderDisputePassthrough map[string]interface{}

// Result of the P2P order disputing.
type P2POrderDisputeResp struct {
	// Echo of the request made.
	EchoReq P2POrderDisputeRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType P2POrderDisputeRespMsgType `json:"msg_type"`

	// Details of the disputed order.
	P2POrderDispute *P2POrderDisputeRespP2POrderDispute `json:"p2p_order_dispute,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type P2POrderDisputeRespEchoReq map[string]interface{}

type P2POrderDisputeRespMsgType string

const P2POrderDisputeRespMsgTypeP2POrderDispute P2POrderDisputeRespMsgType = "p2p_order_dispute"

// Details of the disputed order.
type P2POrderDisputeRespP2POrderDispute struct {
	// The currency of order.
	AccountCurrency string `json:"account_currency"`

	// Details of the advert for this order.
	AdvertDetails P2POrderDisputeRespP2POrderDisputeAdvertDetails `json:"advert_details"`

	// Details of the advertiser for this order.
	AdvertiserDetails P2POrderDisputeRespP2POrderDisputeAdvertiserDetails `json:"advertiser_details"`

	// The amount of the order.
	Amount float64 `json:"amount"`

	// The amount of the order, formatted to appropriate decimal places.
	AmountDisplay string `json:"amount_display"`

	// The URL to be used to initialise the chat for this order.
	ChatChannelUrl string `json:"chat_channel_url"`

	// Details of the client who created the order.
	ClientDetails P2POrderDisputeRespP2POrderDisputeClientDetails `json:"client_details"`

	// Seller contact information.
	ContactInfo string `json:"contact_info"`

	// The epoch time of the order creation.
	CreatedTime int `json:"created_time"`

	// Details of the order dispute.
	DisputeDetails P2POrderDisputeRespP2POrderDisputeDisputeDetails `json:"dispute_details"`

	// The epoch time in which the order will be expired.
	ExpiryTime int `json:"expiry_time"`

	// The unique identifier for this order.
	Id string `json:"id"`

	// `1` if the order is created for the advert of the current client, otherwise
	// `0`.
	IsIncoming P2POrderDisputeRespP2POrderDisputeIsIncoming `json:"is_incoming"`

	// `1` if a review can be given, otherwise `0`.
	IsReviewable P2POrderDisputeRespP2POrderDisputeIsReviewable `json:"is_reviewable"`

	// `1` if the latest order changes have been seen by the current client, otherwise
	// `0`.
	IsSeen P2POrderDisputeRespP2POrderDisputeIsSeen `json:"is_seen"`

	// Local currency for this order.
	LocalCurrency string `json:"local_currency"`

	// Payment instructions.
	PaymentInfo string `json:"payment_info"`

	// Cost in local currency.
	Price float64 `json:"price"`

	// Cost in local currency, formatted to appropriate decimal places.
	PriceDisplay string `json:"price_display"`

	// Conversion rate of the order.
	Rate float64 `json:"rate"`

	// Conversion rate of the order, formatted to appropriate decimal places.
	RateDisplay string `json:"rate_display"`

	// Current order status.
	Status P2POrderDisputeRespP2POrderDisputeStatus `json:"status"`

	// Whether this is a buy or a sell.
	Type P2POrderDisputeRespP2POrderDisputeType `json:"type"`

	// If blocked for too many failed verification attempts, the epoch time that the
	// block will end.
	VerificationLockoutUntil *int `json:"verification_lockout_until,omitempty"`

	// If a verification request has already been made, the epoch time that another
	// verification request can be made.
	VerificationNextRequest *int `json:"verification_next_request,omitempty"`

	// Indicates that the seller in the process of confirming the order.
	VerificationPending *P2POrderDisputeRespP2POrderDisputeVerificationPending `json:"verification_pending,omitempty"`

	// Epoch time that the current verification token will expire.
	VerificationTokenExpiry *int `json:"verification_token_expiry,omitempty"`
}

// Details of the advert for this order.
type P2POrderDisputeRespP2POrderDisputeAdvertDetails struct {
	// Indicates if this is block trade advert or not.
	BlockTrade P2POrderDisputeRespP2POrderDisputeAdvertDetailsBlockTrade `json:"block_trade"`

	// General information about the advert.
	Description string `json:"description"`

	// The unique identifier for the advert.
	Id string `json:"id"`

	// The payment method.
	PaymentMethod interface{} `json:"payment_method"`

	// Type of the advert.
	Type P2POrderDisputeRespP2POrderDisputeAdvertDetailsType `json:"type"`
}

type P2POrderDisputeRespP2POrderDisputeAdvertDetailsBlockTrade int

type P2POrderDisputeRespP2POrderDisputeAdvertDetailsType string

const P2POrderDisputeRespP2POrderDisputeAdvertDetailsTypeBuy P2POrderDisputeRespP2POrderDisputeAdvertDetailsType = "buy"
const P2POrderDisputeRespP2POrderDisputeAdvertDetailsTypeSell P2POrderDisputeRespP2POrderDisputeAdvertDetailsType = "sell"

// Details of the advertiser for this order.
type P2POrderDisputeRespP2POrderDisputeAdvertiserDetails struct {
	// The client's first name.
	FirstName *string `json:"first_name,omitempty"`

	// The advertiser's unique identifier.
	Id string `json:"id"`

	// Indicates if the advertiser is currently online.
	IsOnline P2POrderDisputeRespP2POrderDisputeAdvertiserDetailsIsOnline `json:"is_online"`

	// The advertiser's last name.
	LastName *string `json:"last_name,omitempty"`

	// Epoch of the latest time the advertiser was online, up to 6 months.
	LastOnlineTime interface{} `json:"last_online_time"`

	// The advertiser's account identifier.
	Loginid string `json:"loginid"`

	// The advertiser's displayed name.
	Name string `json:"name"`
}

type P2POrderDisputeRespP2POrderDisputeAdvertiserDetailsIsOnline int

// Details of the client who created the order.
type P2POrderDisputeRespP2POrderDisputeClientDetails struct {
	// The client's first name.
	FirstName *string `json:"first_name,omitempty"`

	// The client's unique P2P identifier.
	Id string `json:"id"`

	// Indicates if the advertiser is currently online.
	IsOnline P2POrderDisputeRespP2POrderDisputeClientDetailsIsOnline `json:"is_online"`

	// The client's last name.
	LastName *string `json:"last_name,omitempty"`

	// Epoch of the latest time the advertiser was online, up to 6 months.
	LastOnlineTime interface{} `json:"last_online_time"`

	// The client's account identifier.
	Loginid string `json:"loginid"`

	// The client's displayed name.
	Name string `json:"name"`
}

type P2POrderDisputeRespP2POrderDisputeClientDetailsIsOnline int

// Details of the order dispute.
type P2POrderDisputeRespP2POrderDisputeDisputeDetails struct {
	// The dispute reason
	DisputeReason string `json:"dispute_reason"`

	// The loginid of the client who's raising the dispute
	DisputerLoginid string `json:"disputer_loginid"`
}

type P2POrderDisputeRespP2POrderDisputeIsIncoming int

type P2POrderDisputeRespP2POrderDisputeIsReviewable int

type P2POrderDisputeRespP2POrderDisputeIsSeen int

type P2POrderDisputeRespP2POrderDisputeStatus string

const P2POrderDisputeRespP2POrderDisputeStatusBlocked P2POrderDisputeRespP2POrderDisputeStatus = "blocked"
const P2POrderDisputeRespP2POrderDisputeStatusBuyerConfirmed P2POrderDisputeRespP2POrderDisputeStatus = "buyer-confirmed"
const P2POrderDisputeRespP2POrderDisputeStatusCancelled P2POrderDisputeRespP2POrderDisputeStatus = "cancelled"
const P2POrderDisputeRespP2POrderDisputeStatusCompleted P2POrderDisputeRespP2POrderDisputeStatus = "completed"
const P2POrderDisputeRespP2POrderDisputeStatusDisputeCompleted P2POrderDisputeRespP2POrderDisputeStatus = "dispute-completed"
const P2POrderDisputeRespP2POrderDisputeStatusDisputeRefunded P2POrderDisputeRespP2POrderDisputeStatus = "dispute-refunded"
const P2POrderDisputeRespP2POrderDisputeStatusDisputed P2POrderDisputeRespP2POrderDisputeStatus = "disputed"
const P2POrderDisputeRespP2POrderDisputeStatusPending P2POrderDisputeRespP2POrderDisputeStatus = "pending"
const P2POrderDisputeRespP2POrderDisputeStatusRefunded P2POrderDisputeRespP2POrderDisputeStatus = "refunded"
const P2POrderDisputeRespP2POrderDisputeStatusTimedOut P2POrderDisputeRespP2POrderDisputeStatus = "timed-out"

type P2POrderDisputeRespP2POrderDisputeType string

const P2POrderDisputeRespP2POrderDisputeTypeBuy P2POrderDisputeRespP2POrderDisputeType = "buy"
const P2POrderDisputeRespP2POrderDisputeTypeSell P2POrderDisputeRespP2POrderDisputeType = "sell"

type P2POrderDisputeRespP2POrderDisputeVerificationPending int

// Retrieves the information about a P2P order.
type P2POrderInfo struct {
	// The unique identifier for the order.
	Id string `json:"id"`

	// Must be 1
	P2POrderInfo P2POrderInfoP2POrderInfo `json:"p2p_order_info"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough P2POrderInfoPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// [Optional] If set to 1, will send updates whenever there is an update to order
	Subscribe *P2POrderInfoSubscribe `json:"subscribe,omitempty"`
}

type P2POrderInfoP2POrderInfo int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type P2POrderInfoPassthrough map[string]interface{}

// Information of the P2P order.
type P2POrderInfoResp struct {
	// Echo of the request made.
	EchoReq P2POrderInfoRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType P2POrderInfoRespMsgType `json:"msg_type"`

	// The information of P2P order.
	P2POrderInfo *P2POrderInfoRespP2POrderInfo `json:"p2p_order_info,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// For subscription requests only.
	Subscription *P2POrderInfoRespSubscription `json:"subscription,omitempty"`
}

// Echo of the request made.
type P2POrderInfoRespEchoReq map[string]interface{}

type P2POrderInfoRespMsgType string

const P2POrderInfoRespMsgTypeP2POrderInfo P2POrderInfoRespMsgType = "p2p_order_info"

// The information of P2P order.
type P2POrderInfoRespP2POrderInfo struct {
	// The currency of order.
	AccountCurrency string `json:"account_currency"`

	// Details of the advert for this order.
	AdvertDetails P2POrderInfoRespP2POrderInfoAdvertDetails `json:"advert_details"`

	// Details of the advertiser for this order.
	AdvertiserDetails P2POrderInfoRespP2POrderInfoAdvertiserDetails `json:"advertiser_details"`

	// The amount of the order.
	Amount float64 `json:"amount"`

	// The amount of the order, formatted to appropriate decimal places.
	AmountDisplay string `json:"amount_display"`

	// The URL to be used to initialise the chat for this order.
	ChatChannelUrl string `json:"chat_channel_url"`

	// Details of the client who created the order.
	ClientDetails P2POrderInfoRespP2POrderInfoClientDetails `json:"client_details"`

	// The epoch time of the order completion.
	CompletionTime *int `json:"completion_time,omitempty"`

	// Seller contact information.
	ContactInfo string `json:"contact_info"`

	// The epoch time of the order creation.
	CreatedTime int `json:"created_time"`

	// Details of the order dispute.
	DisputeDetails P2POrderInfoRespP2POrderInfoDisputeDetails `json:"dispute_details"`

	// The epoch time in which the order will be expired.
	ExpiryTime int `json:"expiry_time"`

	// The unique identifier for this order.
	Id string `json:"id"`

	// `1` if the order is created for the advert of the current client, otherwise
	// `0`.
	IsIncoming P2POrderInfoRespP2POrderInfoIsIncoming `json:"is_incoming"`

	// `1` if a review can be given, otherwise `0`.
	IsReviewable P2POrderInfoRespP2POrderInfoIsReviewable `json:"is_reviewable"`

	// `1` if the latest order changes have been seen by the current client, otherwise
	// `0`.
	IsSeen *P2POrderInfoRespP2POrderInfoIsSeen `json:"is_seen,omitempty"`

	// Local currency for this order.
	LocalCurrency string `json:"local_currency"`

	// Payment instructions.
	PaymentInfo string `json:"payment_info"`

	// Supported payment methods. Comma separated list.
	PaymentMethod interface{} `json:"payment_method,omitempty"`

	// Details of available payment methods.
	PaymentMethodDetails P2POrderInfoRespP2POrderInfoPaymentMethodDetails `json:"payment_method_details,omitempty"`

	// Names of supported payment methods.
	PaymentMethodNames []string `json:"payment_method_names,omitempty"`

	// Cost in local currency.
	Price float64 `json:"price"`

	// Cost in local currency, formatted to appropriate decimal places.
	PriceDisplay string `json:"price_display"`

	// Conversion rate of the order.
	Rate float64 `json:"rate"`

	// Conversion rate of the order, formatted to appropriate decimal places.
	RateDisplay string `json:"rate_display"`

	// Details of the review you gave for this order, if any.
	ReviewDetails *P2POrderInfoRespP2POrderInfoReviewDetails `json:"review_details,omitempty"`

	// Current order status.
	Status P2POrderInfoRespP2POrderInfoStatus `json:"status"`

	// Whether this is a buy or a sell.
	Type P2POrderInfoRespP2POrderInfoType `json:"type"`

	// If blocked for too many failed verification attempts, the epoch time that the
	// block will end.
	VerificationLockoutUntil *int `json:"verification_lockout_until,omitempty"`

	// If a verification request has already been made, the epoch time that another
	// verification request can be made.
	VerificationNextRequest *int `json:"verification_next_request,omitempty"`

	// Indicates that the seller in the process of confirming the order.
	VerificationPending *P2POrderInfoRespP2POrderInfoVerificationPending `json:"verification_pending,omitempty"`

	// Epoch time that the current verification token will expire.
	VerificationTokenExpiry *int `json:"verification_token_expiry,omitempty"`
}

// Details of the advert for this order.
type P2POrderInfoRespP2POrderInfoAdvertDetails struct {
	// Indicates if this is block trade advert or not.
	BlockTrade P2POrderInfoRespP2POrderInfoAdvertDetailsBlockTrade `json:"block_trade"`

	// General information about the advert.
	Description string `json:"description"`

	// The unique identifier for the advert.
	Id string `json:"id"`

	// The payment method.
	PaymentMethod interface{} `json:"payment_method"`

	// Type of the advert.
	Type P2POrderInfoRespP2POrderInfoAdvertDetailsType `json:"type"`
}

type P2POrderInfoRespP2POrderInfoAdvertDetailsBlockTrade int

type P2POrderInfoRespP2POrderInfoAdvertDetailsType string

const P2POrderInfoRespP2POrderInfoAdvertDetailsTypeBuy P2POrderInfoRespP2POrderInfoAdvertDetailsType = "buy"
const P2POrderInfoRespP2POrderInfoAdvertDetailsTypeSell P2POrderInfoRespP2POrderInfoAdvertDetailsType = "sell"

// Details of the advertiser for this order.
type P2POrderInfoRespP2POrderInfoAdvertiserDetails struct {
	// The advertiser's first name.
	FirstName *string `json:"first_name,omitempty"`

	// The advertiser's unique identifier.
	Id string `json:"id"`

	// Indicates if the advertiser is currently online.
	IsOnline P2POrderInfoRespP2POrderInfoAdvertiserDetailsIsOnline `json:"is_online"`

	// Indicates that the advertiser was recommended in the most recent review by the
	// current user.
	IsRecommended *P2POrderInfoRespP2POrderInfoAdvertiserDetailsIsRecommended `json:"is_recommended,omitempty"`

	// The advertiser's last name.
	LastName *string `json:"last_name,omitempty"`

	// Epoch of the latest time the advertiser was online, up to 6 months.
	LastOnlineTime interface{} `json:"last_online_time"`

	// The advertiser's account identifier.
	Loginid string `json:"loginid"`

	// The advertiser's displayed name.
	Name string `json:"name"`
}

type P2POrderInfoRespP2POrderInfoAdvertiserDetailsIsOnline int

type P2POrderInfoRespP2POrderInfoAdvertiserDetailsIsRecommended struct {
	Value interface{}
}

// Details of the client who created the order.
type P2POrderInfoRespP2POrderInfoClientDetails struct {
	// The client's first name.
	FirstName *string `json:"first_name,omitempty"`

	// The client's unique P2P identifier.
	Id string `json:"id"`

	// Indicates if the advertiser is currently online.
	IsOnline *P2POrderInfoRespP2POrderInfoClientDetailsIsOnline `json:"is_online,omitempty"`

	// Indicates that the client was recommended in the most recent review by the
	// current user.
	IsRecommended *P2POrderInfoRespP2POrderInfoClientDetailsIsRecommended `json:"is_recommended,omitempty"`

	// The client's last name.
	LastName *string `json:"last_name,omitempty"`

	// Epoch of the latest time the advertiser was online, up to 6 months.
	LastOnlineTime interface{} `json:"last_online_time,omitempty"`

	// The client's account identifier.
	Loginid string `json:"loginid"`

	// The client's displayed name.
	Name string `json:"name"`
}

type P2POrderInfoRespP2POrderInfoClientDetailsIsOnline int

type P2POrderInfoRespP2POrderInfoClientDetailsIsRecommended struct {
	Value interface{}
}

// Details of the order dispute.
type P2POrderInfoRespP2POrderInfoDisputeDetails struct {
	// The dispute reason
	DisputeReason interface{} `json:"dispute_reason"`

	// The loginid of the client who's raising the dispute
	DisputerLoginid interface{} `json:"disputer_loginid"`
}

type P2POrderInfoRespP2POrderInfoIsIncoming int

type P2POrderInfoRespP2POrderInfoIsReviewable int

type P2POrderInfoRespP2POrderInfoIsSeen int

// Details of available payment methods.
type P2POrderInfoRespP2POrderInfoPaymentMethodDetails map[string]interface{}

// Details of the review you gave for this order, if any.
type P2POrderInfoRespP2POrderInfoReviewDetails struct {
	// The epoch time of the review.
	CreatedTime int `json:"created_time"`

	// Rating for the transaction, 1 to 5.
	Rating int `json:"rating"`

	// `1` if the advertiser is recommended, `0` if not recommended.
	Recommended P2POrderInfoRespP2POrderInfoReviewDetailsRecommended `json:"recommended"`
}

type P2POrderInfoRespP2POrderInfoReviewDetailsRecommended struct {
	Value interface{}
}

type P2POrderInfoRespP2POrderInfoStatus string

const P2POrderInfoRespP2POrderInfoStatusBlocked P2POrderInfoRespP2POrderInfoStatus = "blocked"
const P2POrderInfoRespP2POrderInfoStatusBuyerConfirmed P2POrderInfoRespP2POrderInfoStatus = "buyer-confirmed"
const P2POrderInfoRespP2POrderInfoStatusCancelled P2POrderInfoRespP2POrderInfoStatus = "cancelled"
const P2POrderInfoRespP2POrderInfoStatusCompleted P2POrderInfoRespP2POrderInfoStatus = "completed"
const P2POrderInfoRespP2POrderInfoStatusDisputeCompleted P2POrderInfoRespP2POrderInfoStatus = "dispute-completed"
const P2POrderInfoRespP2POrderInfoStatusDisputeRefunded P2POrderInfoRespP2POrderInfoStatus = "dispute-refunded"
const P2POrderInfoRespP2POrderInfoStatusDisputed P2POrderInfoRespP2POrderInfoStatus = "disputed"
const P2POrderInfoRespP2POrderInfoStatusPending P2POrderInfoRespP2POrderInfoStatus = "pending"
const P2POrderInfoRespP2POrderInfoStatusRefunded P2POrderInfoRespP2POrderInfoStatus = "refunded"
const P2POrderInfoRespP2POrderInfoStatusTimedOut P2POrderInfoRespP2POrderInfoStatus = "timed-out"

type P2POrderInfoRespP2POrderInfoType string

const P2POrderInfoRespP2POrderInfoTypeBuy P2POrderInfoRespP2POrderInfoType = "buy"
const P2POrderInfoRespP2POrderInfoTypeSell P2POrderInfoRespP2POrderInfoType = "sell"

type P2POrderInfoRespP2POrderInfoVerificationPending int

// For subscription requests only.
type P2POrderInfoRespSubscription struct {
	// A per-connection unique identifier. Can be passed to the `forget` API call to
	// unsubscribe.
	Id string `json:"id"`
}

type P2POrderInfoSubscribe int

// List active orders.
type P2POrderList struct {
	// [Optional] Should be 1 to list active, 0 to list inactive (historical).
	Active *P2POrderListActive `json:"active,omitempty"`

	// [Optional] If present, lists orders applying to a specific advert.
	AdvertId *string `json:"advert_id,omitempty"`

	// [Optional] Used for paging.
	Limit int `json:"limit,omitempty"`

	// [Optional] Used for paging.
	Offset int `json:"offset,omitempty"`

	// Must be 1
	P2POrderList P2POrderListP2POrderList `json:"p2p_order_list"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough P2POrderListPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// [Optional] If set to 1, will send updates whenever there is a change to any
	// order belonging to you.
	Subscribe *P2POrderListSubscribe `json:"subscribe,omitempty"`
}

type P2POrderListActive float64

type P2POrderListP2POrderList int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type P2POrderListPassthrough map[string]interface{}

// All orders matching the requested criteria.
type P2POrderListResp struct {
	// Echo of the request made.
	EchoReq P2POrderListRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType P2POrderListRespMsgType `json:"msg_type"`

	// List of P2P orders.
	P2POrderList *P2POrderListRespP2POrderList `json:"p2p_order_list,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// For subscription requests only.
	Subscription *P2POrderListRespSubscription `json:"subscription,omitempty"`
}

// Echo of the request made.
type P2POrderListRespEchoReq map[string]interface{}

type P2POrderListRespMsgType string

const P2POrderListRespMsgTypeP2POrderList P2POrderListRespMsgType = "p2p_order_list"

// List of P2P orders.
type P2POrderListRespP2POrderList struct {
	// List of orders.
	List []P2POrderListRespP2POrderListListElem `json:"list"`
}

type P2POrderListRespP2POrderListListElem struct {
	// The currency to be bought or sold.
	AccountCurrency string `json:"account_currency"`

	// Details of the advert for this order.
	AdvertDetails P2POrderListRespP2POrderListListElemAdvertDetails `json:"advert_details"`

	// Details of the advertiser for this order.
	AdvertiserDetails P2POrderListRespP2POrderListListElemAdvertiserDetails `json:"advertiser_details"`

	// The amount of the order.
	Amount float64 `json:"amount"`

	// The amount of the order, formatted to appropriate decimal places.
	AmountDisplay string `json:"amount_display"`

	// The URL to be used to initialise the chat for this order.
	ChatChannelUrl string `json:"chat_channel_url"`

	// Details of the client who created the order.
	ClientDetails *P2POrderListRespP2POrderListListElemClientDetails `json:"client_details,omitempty"`

	// The epoch time of the order completion.
	CompletionTime *int `json:"completion_time,omitempty"`

	// Seller contact information.
	ContactInfo string `json:"contact_info"`

	// The epoch time of the order creation.
	CreatedTime int `json:"created_time"`

	// Details of the order dispute.
	DisputeDetails P2POrderListRespP2POrderListListElemDisputeDetails `json:"dispute_details"`

	// The epoch time in which the order will be expired.
	ExpiryTime int `json:"expiry_time"`

	// The unique identifier for this order.
	Id string `json:"id"`

	// `1` if the order is created for the advert of the current client, otherwise
	// `0`.
	IsIncoming P2POrderListRespP2POrderListListElemIsIncoming `json:"is_incoming"`

	// `1` if a review can be given, otherwise `0`.
	IsReviewable P2POrderListRespP2POrderListListElemIsReviewable `json:"is_reviewable"`

	// `1` if the latest order changes have been seen by the current client, otherwise
	// `0`.
	IsSeen *P2POrderListRespP2POrderListListElemIsSeen `json:"is_seen,omitempty"`

	// Local currency for this order.
	LocalCurrency string `json:"local_currency"`

	// Payment instructions.
	PaymentInfo string `json:"payment_info"`

	// Supported payment methods. Comma separated list of identifiers.
	PaymentMethod interface{} `json:"payment_method,omitempty"`

	// Names of supported payment methods.
	PaymentMethodNames []string `json:"payment_method_names,omitempty"`

	// Cost in local currency.
	Price float64 `json:"price"`

	// Cost in local currency, formatted to appropriate decimal places.
	PriceDisplay string `json:"price_display"`

	// Conversion rate of the order.
	Rate float64 `json:"rate"`

	// Conversion rate of the order, formatted to appropriate decimal places.
	RateDisplay string `json:"rate_display"`

	// Details of the review you gave for this order, if any.
	ReviewDetails *P2POrderListRespP2POrderListListElemReviewDetails `json:"review_details,omitempty"`

	// Current order status.
	Status P2POrderListRespP2POrderListListElemStatus `json:"status"`

	// Whether this is a buy or a sell.
	Type P2POrderListRespP2POrderListListElemType `json:"type"`

	// If blocked for too many failed verification attempts, the epoch time that the
	// block will end.
	VerificationLockoutUntil *int `json:"verification_lockout_until,omitempty"`

	// If a verification request has already been made, the epoch time that another
	// verification request can be made.
	VerificationNextRequest *int `json:"verification_next_request,omitempty"`

	// Indicates that the seller in the process of confirming the order.
	VerificationPending *P2POrderListRespP2POrderListListElemVerificationPending `json:"verification_pending,omitempty"`

	// Epoch time that the current verification token will expire.
	VerificationTokenExpiry *int `json:"verification_token_expiry,omitempty"`
}

// Details of the advert for this order.
type P2POrderListRespP2POrderListListElemAdvertDetails struct {
	// Indicates if this is block trade advert or not.
	BlockTrade P2POrderListRespP2POrderListListElemAdvertDetailsBlockTrade `json:"block_trade"`

	// General information about the advert.
	Description string `json:"description"`

	// The unique identifier for the advert.
	Id string `json:"id"`

	// The payment method.
	PaymentMethod interface{} `json:"payment_method"`

	// Type of the advert.
	Type P2POrderListRespP2POrderListListElemAdvertDetailsType `json:"type"`
}

type P2POrderListRespP2POrderListListElemAdvertDetailsBlockTrade int

type P2POrderListRespP2POrderListListElemAdvertDetailsType string

const P2POrderListRespP2POrderListListElemAdvertDetailsTypeBuy P2POrderListRespP2POrderListListElemAdvertDetailsType = "buy"
const P2POrderListRespP2POrderListListElemAdvertDetailsTypeSell P2POrderListRespP2POrderListListElemAdvertDetailsType = "sell"

// Details of the advertiser for this order.
type P2POrderListRespP2POrderListListElemAdvertiserDetails struct {
	// The advertiser's first name.
	FirstName *string `json:"first_name,omitempty"`

	// The advertiser's unique identifier.
	Id string `json:"id"`

	// Indicates if the advertiser is currently online.
	IsOnline P2POrderListRespP2POrderListListElemAdvertiserDetailsIsOnline `json:"is_online"`

	// Indicates that the advertiser was recommended in the most recent review by the
	// current user.
	IsRecommended *P2POrderListRespP2POrderListListElemAdvertiserDetailsIsRecommended `json:"is_recommended,omitempty"`

	// The advertiser's last name.
	LastName *string `json:"last_name,omitempty"`

	// Epoch of the latest time the advertiser was online, up to 6 months.
	LastOnlineTime interface{} `json:"last_online_time"`

	// The advertiser's account identifier.
	Loginid string `json:"loginid"`

	// The advertiser's displayed name.
	Name string `json:"name"`
}

type P2POrderListRespP2POrderListListElemAdvertiserDetailsIsOnline int

type P2POrderListRespP2POrderListListElemAdvertiserDetailsIsRecommended struct {
	Value interface{}
}

// Details of the client who created the order.
type P2POrderListRespP2POrderListListElemClientDetails struct {
	// The client's first name.
	FirstName *string `json:"first_name,omitempty"`

	// The client's unique P2P identifier.
	Id string `json:"id"`

	// Indicates if the advertiser is currently online.
	IsOnline P2POrderListRespP2POrderListListElemClientDetailsIsOnline `json:"is_online"`

	// Indicates that the client was recommended in the most recent review by the
	// current user.
	IsRecommended *P2POrderListRespP2POrderListListElemClientDetailsIsRecommended `json:"is_recommended,omitempty"`

	// The client's last name.
	LastName *string `json:"last_name,omitempty"`

	// Epoch of the latest time the advertiser was online, up to 6 months.
	LastOnlineTime interface{} `json:"last_online_time"`

	// The client's account identifier.
	Loginid string `json:"loginid"`

	// The client's displayed name.
	Name string `json:"name"`
}

type P2POrderListRespP2POrderListListElemClientDetailsIsOnline int

type P2POrderListRespP2POrderListListElemClientDetailsIsRecommended struct {
	Value interface{}
}

// Details of the order dispute.
type P2POrderListRespP2POrderListListElemDisputeDetails struct {
	// The dispute reason
	DisputeReason interface{} `json:"dispute_reason"`

	// The loginid of the client who's raising the dispute
	DisputerLoginid interface{} `json:"disputer_loginid"`
}

type P2POrderListRespP2POrderListListElemIsIncoming int

type P2POrderListRespP2POrderListListElemIsReviewable int

type P2POrderListRespP2POrderListListElemIsSeen int

// Details of the review you gave for this order, if any.
type P2POrderListRespP2POrderListListElemReviewDetails struct {
	// The epoch time of the review.
	CreatedTime int `json:"created_time"`

	// Rating for the transaction, 1 to 5.
	Rating int `json:"rating"`

	// `1` if the advertiser is recommended, `0` if not recommended.
	Recommended P2POrderListRespP2POrderListListElemReviewDetailsRecommended `json:"recommended"`
}

type P2POrderListRespP2POrderListListElemReviewDetailsRecommended struct {
	Value interface{}
}

type P2POrderListRespP2POrderListListElemStatus string

const P2POrderListRespP2POrderListListElemStatusBlocked P2POrderListRespP2POrderListListElemStatus = "blocked"
const P2POrderListRespP2POrderListListElemStatusBuyerConfirmed P2POrderListRespP2POrderListListElemStatus = "buyer-confirmed"
const P2POrderListRespP2POrderListListElemStatusCancelled P2POrderListRespP2POrderListListElemStatus = "cancelled"
const P2POrderListRespP2POrderListListElemStatusCompleted P2POrderListRespP2POrderListListElemStatus = "completed"
const P2POrderListRespP2POrderListListElemStatusDisputeCompleted P2POrderListRespP2POrderListListElemStatus = "dispute-completed"
const P2POrderListRespP2POrderListListElemStatusDisputeRefunded P2POrderListRespP2POrderListListElemStatus = "dispute-refunded"
const P2POrderListRespP2POrderListListElemStatusDisputed P2POrderListRespP2POrderListListElemStatus = "disputed"
const P2POrderListRespP2POrderListListElemStatusPending P2POrderListRespP2POrderListListElemStatus = "pending"
const P2POrderListRespP2POrderListListElemStatusRefunded P2POrderListRespP2POrderListListElemStatus = "refunded"
const P2POrderListRespP2POrderListListElemStatusTimedOut P2POrderListRespP2POrderListListElemStatus = "timed-out"

type P2POrderListRespP2POrderListListElemType string

const P2POrderListRespP2POrderListListElemTypeBuy P2POrderListRespP2POrderListListElemType = "buy"
const P2POrderListRespP2POrderListListElemTypeSell P2POrderListRespP2POrderListListElemType = "sell"

type P2POrderListRespP2POrderListListElemVerificationPending int

// For subscription requests only.
type P2POrderListRespSubscription struct {
	// A per-connection unique identifier. Can be passed to the `forget` API call to
	// unsubscribe.
	Id string `json:"id"`
}

type P2POrderListSubscribe int

// Creates a review for the specified order.
type P2POrderReview struct {
	// The order identification number.
	OrderId string `json:"order_id"`

	// Must be 1
	P2POrderReview P2POrderReviewP2POrderReview `json:"p2p_order_review"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough P2POrderReviewPassthrough `json:"passthrough,omitempty"`

	// Rating for the transaction, 1 to 5.
	Rating int `json:"rating"`

	// [Optional] `1` if the counterparty is recommendable to others, otherwise `0`.
	Recommended *P2POrderReviewRecommended `json:"recommended,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type P2POrderReviewP2POrderReview int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type P2POrderReviewPassthrough map[string]interface{}

type P2POrderReviewRecommended struct {
	Value interface{}
}

// Response for creating a P2P order review.
type P2POrderReviewResp struct {
	// Echo of the request made.
	EchoReq P2POrderReviewRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType P2POrderReviewRespMsgType `json:"msg_type"`

	// Details of the created order review.
	P2POrderReview *P2POrderReviewRespP2POrderReview `json:"p2p_order_review,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type P2POrderReviewRespEchoReq map[string]interface{}

type P2POrderReviewRespMsgType string

const P2POrderReviewRespMsgTypeP2POrderReview P2POrderReviewRespMsgType = "p2p_order_review"

// Details of the created order review.
type P2POrderReviewRespP2POrderReview struct {
	// The reviewed advertiser's identification number.
	AdvertiserId string `json:"advertiser_id"`

	// The epoch time of the review.
	CreatedTime int `json:"created_time"`

	// The order identification number.
	OrderId string `json:"order_id"`

	// Rating for the transaction, 1 to 5.
	Rating int `json:"rating"`

	// `1` if the advertiser is recommended, `0` if not recommended.
	Recommended P2POrderReviewRespP2POrderReviewRecommended `json:"recommended"`
}

type P2POrderReviewRespP2POrderReviewRecommended struct {
	Value interface{}
}

// List all P2P payment methods.
type P2PPaymentMethods struct {
	// Must be 1
	P2PPaymentMethods P2PPaymentMethodsP2PPaymentMethods `json:"p2p_payment_methods"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough P2PPaymentMethodsPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type P2PPaymentMethodsP2PPaymentMethods int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type P2PPaymentMethodsPassthrough map[string]interface{}

// List all P2P payment methods.
type P2PPaymentMethodsResp struct {
	// Echo of the request made.
	EchoReq P2PPaymentMethodsRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType P2PPaymentMethodsRespMsgType `json:"msg_type"`

	// Payment methods keyed by identifier.
	P2PPaymentMethods P2PPaymentMethodsRespP2PPaymentMethods `json:"p2p_payment_methods,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type P2PPaymentMethodsRespEchoReq map[string]interface{}

type P2PPaymentMethodsRespMsgType string

const P2PPaymentMethodsRespMsgTypeP2PPaymentMethods P2PPaymentMethodsRespMsgType = "p2p_payment_methods"

// Payment methods keyed by identifier.
type P2PPaymentMethodsRespP2PPaymentMethods map[string]interface{}

// Keeps the connection alive and updates the P2P advertiser's online status. The
// advertiser will be considered offline 60 seconds after a call is made.
type P2PPing struct {
	// Must be `1`
	P2PPing P2PPingP2PPing `json:"p2p_ping"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough P2PPingPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type P2PPingP2PPing int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type P2PPingPassthrough map[string]interface{}

// The response of P2P ping request.
type P2PPingResp struct {
	// Echo of the request made.
	EchoReq P2PPingRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType P2PPingRespMsgType `json:"msg_type"`

	// Will return 'pong'
	P2PPing *P2PPingRespP2PPing `json:"p2p_ping,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type P2PPingRespEchoReq map[string]interface{}

type P2PPingRespMsgType string

const P2PPingRespMsgTypeP2PPing P2PPingRespMsgType = "p2p_ping"

type P2PPingRespP2PPing string

const P2PPingRespP2PPingPong P2PPingRespP2PPing = "pong"

// Will return a list payment methods available for the given country. If the
// request is authenticated the client's residence country will be used.
type PaymentMethods struct {
	// [Optional] 2-letter country code (ISO standard).
	Country *string `json:"country,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough PaymentMethodsPassthrough `json:"passthrough,omitempty"`

	// Must be `1`
	PaymentMethods PaymentMethodsPaymentMethods `json:"payment_methods"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type PaymentMethodsPassthrough map[string]interface{}

type PaymentMethodsPaymentMethods int

// List of available payment methods for a given country.
type PaymentMethodsResp struct {
	// Echo of the request made.
	EchoReq PaymentMethodsRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType PaymentMethodsRespMsgType `json:"msg_type"`

	// Available payment methods for a given country. Note: if a user is logged in,
	// the residence country will be considered.
	PaymentMethods []PaymentMethodsRespPaymentMethodsElem `json:"payment_methods,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type PaymentMethodsRespEchoReq map[string]interface{}

type PaymentMethodsRespMsgType string

const PaymentMethodsRespMsgTypePaymentMethods PaymentMethodsRespMsgType = "payment_methods"

// A payment method suported for the given country
type PaymentMethodsRespPaymentMethodsElem struct {
	// The min and max values for deposits.
	DepositLimits PaymentMethodsRespPaymentMethodsElemDepositLimits `json:"deposit_limits"`

	// How much time it takes for a deposit to be processed.
	DepositTime string `json:"deposit_time"`

	// Short description explaining the payment method.
	Description string `json:"description"`

	// Common name for the payment method.
	DisplayName string `json:"display_name"`

	// Unique identifier for the payment method.
	Id string `json:"id"`

	// Payment processor for this payment method.
	PaymentProcessor string `json:"payment_processor"`

	// A list of predefined amounts for withdraw or deposit.
	PredefinedAmounts []int `json:"predefined_amounts"`

	// Sign up link for this payment method.
	SignupLink string `json:"signup_link"`

	// Currencies supported for this payment method.
	SupportedCurrencies []string `json:"supported_currencies"`

	// Type of Payment Method.
	Type string `json:"type"`

	// A printable description for type of payment method.
	TypeDisplayName string `json:"type_display_name"`

	// Withdrawal limits per currency.
	WithdrawLimits PaymentMethodsRespPaymentMethodsElemWithdrawLimits `json:"withdraw_limits"`

	// How much time takes a withdrawal to be processed.
	WithdrawalTime string `json:"withdrawal_time"`
}

// The min and max values for deposits.
type PaymentMethodsRespPaymentMethodsElemDepositLimits map[string]interface{}

// Withdrawal limits per currency.
type PaymentMethodsRespPaymentMethodsElemWithdrawLimits map[string]interface{}

// Saves client's payment agent details.
type PaymentagentCreate struct {
	// [Optional] Client's My Affiliate id, if exists.
	AffiliateId *string `json:"affiliate_id,omitempty"`

	// Indicates client's agreement with the Code of Conduct.
	CodeOfConductApproval PaymentagentCreateCodeOfConductApproval `json:"code_of_conduct_approval"`

	// Commission  (%) the agent wants to take on deposits
	CommissionDeposit float64 `json:"commission_deposit"`

	// Commission  (%) the agent wants to take on withdrawals
	CommissionWithdrawal float64 `json:"commission_withdrawal"`

	// Payment agent's email address.
	Email string `json:"email"`

	// [Optional] Information about payment agent and their proposed service.
	Information string `json:"information"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough PaymentagentCreatePassthrough `json:"passthrough,omitempty"`

	// The name with which the payment agent is going to be identified.
	PaymentAgentName string `json:"payment_agent_name"`

	// Must be 1
	PaymentagentCreate PaymentagentCreatePaymentagentCreate `json:"paymentagent_create"`

	// Payment agent's phone number(s) with country code.
	PhoneNumbers []PaymentagentCreatePhoneNumbersElem `json:"phone_numbers,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// A list of supported payment methods.
	SupportedPaymentMethods []PaymentagentCreateSupportedPaymentMethodsElem `json:"supported_payment_methods"`

	// The URL(s) of payment agent's website(s).
	Urls []PaymentagentCreateUrlsElem `json:"urls"`
}

type PaymentagentCreateCodeOfConductApproval int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type PaymentagentCreatePassthrough map[string]interface{}

type PaymentagentCreatePaymentagentCreate int

type PaymentagentCreatePhoneNumbersElem struct {
	// A phone number
	PhoneNumber string `json:"phone_number"`
}

// Sets client's payment agent details.
type PaymentagentCreateResp struct {
	// Echo of the request made.
	EchoReq PaymentagentCreateRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType PaymentagentCreateRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type PaymentagentCreateRespEchoReq map[string]interface{}

type PaymentagentCreateRespMsgType string

const PaymentagentCreateRespMsgTypePaymentagentCreate PaymentagentCreateRespMsgType = "paymentagent_create"

type PaymentagentCreateSupportedPaymentMethodsElem struct {
	// A payment method's name
	PaymentMethod string `json:"payment_method"`
}

type PaymentagentCreateUrlsElem struct {
	// A webpage or website's URL.
	Url string `json:"url"`
}

// Gets client's payment agent details.
type PaymentagentDetails struct {
	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough PaymentagentDetailsPassthrough `json:"passthrough,omitempty"`

	// Must be 1
	PaymentagentDetails PaymentagentDetailsPaymentagentDetails `json:"paymentagent_details"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type PaymentagentDetailsPassthrough map[string]interface{}

type PaymentagentDetailsPaymentagentDetails int

// Gets client's payment agent details.
type PaymentagentDetailsResp struct {
	// Echo of the request made.
	EchoReq PaymentagentDetailsRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType PaymentagentDetailsRespMsgType `json:"msg_type"`

	// Used to pass data through the websocket, which may be retrieved via the
	// `echo_req` output field.
	Passthrough PaymentagentDetailsRespPassthrough `json:"passthrough,omitempty"`

	// The payment agent details.
	PaymentagentDetails *PaymentagentDetailsRespPaymentagentDetails `json:"paymentagent_details,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type PaymentagentDetailsRespEchoReq map[string]interface{}

type PaymentagentDetailsRespMsgType string

const PaymentagentDetailsRespMsgTypePaymentagentDetails PaymentagentDetailsRespMsgType = "paymentagent_details"

// Used to pass data through the websocket, which may be retrieved via the
// `echo_req` output field.
type PaymentagentDetailsRespPassthrough map[string]interface{}

// The payment agent details.
type PaymentagentDetailsRespPaymentagentDetails struct {
	// Client's My Affiliate id, if exists.
	AffiliateId interface{} `json:"affiliate_id,omitempty"`

	// If 1, the client may apply using paymentagent_create.
	CanApply PaymentagentDetailsRespPaymentagentDetailsCanApply `json:"can_apply"`

	// Indicates client's agreement with the Code of Conduct document.
	CodeOfConductApproval *PaymentagentDetailsRespPaymentagentDetailsCodeOfConductApproval `json:"code_of_conduct_approval,omitempty"`

	// Commission (%) the agent want to take on deposits
	CommissionDeposit *float64 `json:"commission_deposit,omitempty"`

	// Commission (%) the agent want to take on withdrawals
	CommissionWithdrawal *float64 `json:"commission_withdrawal,omitempty"`

	// Currency supported by the payment agent. It's usually the same as agent's Deriv
	// account currency.
	CurrencyCode *string `json:"currency_code,omitempty"`

	// Contains a list of error codes that would prevent a successful payment agent
	// application.
	EligibiltyValidation []string `json:"eligibilty_validation,omitempty"`

	// Payment agent's email address.
	Email *string `json:"email,omitempty"`

	// Information about payment agent and their proposed service.
	Information *string `json:"information,omitempty"`

	// Maximum amount allowed for withdrawals
	MaxWithdrawal *float64 `json:"max_withdrawal,omitempty"`

	// Minimum amount allowed for withdrawals
	MinWithdrawal *float64 `json:"min_withdrawal,omitempty"`

	// Indicates if the payment agent was recently approved with no transactions yet.
	NewlyAuthorized *PaymentagentDetailsRespPaymentagentDetailsNewlyAuthorized `json:"newly_authorized,omitempty"`

	// The name with which the payment agent is going to be identified.
	PaymentAgentName *string `json:"payment_agent_name,omitempty"`

	// Payment agent's phone number(s) with country code.
	PhoneNumbers []PaymentagentDetailsRespPaymentagentDetailsPhoneNumbersElem `json:"phone_numbers,omitempty"`

	// Indicates the status of the Payment Agent.
	Status interface{} `json:"status,omitempty"`

	// A list of supported payment methods.
	SupportedPaymentMethods []PaymentagentDetailsRespPaymentagentDetailsSupportedPaymentMethodsElem `json:"supported_payment_methods,omitempty"`

	// Client's target country.
	TargetCountry *string `json:"target_country,omitempty"`

	// The URL(s) of payment agent's website(s).
	Urls []PaymentagentDetailsRespPaymentagentDetailsUrlsElem `json:"urls,omitempty"`
}

type PaymentagentDetailsRespPaymentagentDetailsCanApply int

type PaymentagentDetailsRespPaymentagentDetailsCodeOfConductApproval int

type PaymentagentDetailsRespPaymentagentDetailsNewlyAuthorized int

type PaymentagentDetailsRespPaymentagentDetailsPhoneNumbersElem struct {
	// A phone number.
	PhoneNumber *string `json:"phone_number,omitempty"`
}

type PaymentagentDetailsRespPaymentagentDetailsSupportedPaymentMethodsElem struct {
	// A payment method's name
	PaymentMethod *string `json:"payment_method,omitempty"`
}

type PaymentagentDetailsRespPaymentagentDetailsUrlsElem struct {
	// A website url.
	Url *string `json:"url,omitempty"`
}

// Will return a list of Payment Agents for a given country for a given currency.
// Payment agents allow users to deposit and withdraw funds using local payment
// methods that might not be available via the main website's cashier system.
type PaymentagentList struct {
	// [Optional] If specified, only payment agents that supports that currency will
	// be returned (obtained from `payout_currencies` call).
	Currency *string `json:"currency,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough PaymentagentListPassthrough `json:"passthrough,omitempty"`

	// Client's 2-letter country code (obtained from `residence_list` call).
	PaymentagentList string `json:"paymentagent_list"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type PaymentagentListPassthrough map[string]interface{}

// A message with Payment Agent List
type PaymentagentListResp struct {
	// Echo of the request made.
	EchoReq PaymentagentListRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType PaymentagentListRespMsgType `json:"msg_type"`

	// Payment Agent List
	PaymentagentList *PaymentagentListRespPaymentagentList `json:"paymentagent_list,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type PaymentagentListRespEchoReq map[string]interface{}

type PaymentagentListRespMsgType string

const PaymentagentListRespMsgTypePaymentagentList PaymentagentListRespMsgType = "paymentagent_list"

// Payment Agent List
type PaymentagentListRespPaymentagentList struct {
	// The list of countries in which payment agent is available.
	AvailableCountries [][]interface{} `json:"available_countries,omitempty"`

	// List of payment agents available in the requested country.
	List []PaymentagentListRespPaymentagentListListElem `json:"list"`
}

type PaymentagentListRespPaymentagentListListElem struct {
	// Currencies that are accepted by this payment agent.
	Currencies string `json:"currencies"`

	// Commission amount applied on deposits made through this payment agent.
	DepositCommission string `json:"deposit_commission"`

	// Payment agent's email address.
	Email string `json:"email"`

	// More descriptions about this payment agent.
	FurtherInformation string `json:"further_information"`

	// Maximum withdrawal allowed for transactions through this payment agent.
	MaxWithdrawal interface{} `json:"max_withdrawal"`

	// Minimum withdrawal allowed for transactions through this payment agent.
	MinWithdrawal interface{} `json:"min_withdrawal"`

	// Payment agent's name.
	Name string `json:"name"`

	// Payment agent's loginid.
	PaymentagentLoginid string `json:"paymentagent_loginid"`

	// Payment agent's phone number(s) with country code.
	PhoneNumbers []PaymentagentListRespPaymentagentListListElemPhoneNumbersElem `json:"phone_numbers"`

	// A summary about payment agent.
	Summary string `json:"summary"`

	// A list of supported payment methods.
	SupportedPaymentMethods []PaymentagentListRespPaymentagentListListElemSupportedPaymentMethodsElem `json:"supported_payment_methods"`

	// The URL(s) of payment agent's website(s).
	Urls []PaymentagentListRespPaymentagentListListElemUrlsElem `json:"urls"`

	// Commission amount applied on withdrawals made through this payment agent.
	WithdrawalCommission string `json:"withdrawal_commission"`
}

type PaymentagentListRespPaymentagentListListElemPhoneNumbersElem struct {
	// A phone number
	PhoneNumber *string `json:"phone_number,omitempty"`
}

type PaymentagentListRespPaymentagentListListElemSupportedPaymentMethodsElem struct {
	// A payment method's name
	PaymentMethod *string `json:"payment_method,omitempty"`
}

type PaymentagentListRespPaymentagentListListElemUrlsElem struct {
	// A webpage or website's URL.
	Url *string `json:"url,omitempty"`
}

// Payment Agent Transfer - this call is available only to accounts that are
// approved Payment Agents.
type PaymentagentTransfer struct {
	// The amount to transfer.
	Amount float64 `json:"amount"`

	// Currency code.
	Currency string `json:"currency"`

	// [Optional] Remarks about the transfer.
	Description *string `json:"description,omitempty"`

	// [Optional] If set to `1`, just do validation.
	DryRun *PaymentagentTransferDryRun `json:"dry_run,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough PaymentagentTransferPassthrough `json:"passthrough,omitempty"`

	// Must be `1`
	PaymentagentTransfer PaymentagentTransferPaymentagentTransfer `json:"paymentagent_transfer"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// The loginid of the recipient account.
	TransferTo string `json:"transfer_to"`
}

type PaymentagentTransferDryRun int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type PaymentagentTransferPassthrough map[string]interface{}

type PaymentagentTransferPaymentagentTransfer int

// The result of transfer request made.
type PaymentagentTransferResp struct {
	// The `transfer_to` client full name
	ClientToFullName *string `json:"client_to_full_name,omitempty"`

	// The `transfer_to` client loginid
	ClientToLoginid *string `json:"client_to_loginid,omitempty"`

	// Echo of the request made.
	EchoReq PaymentagentTransferRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType PaymentagentTransferRespMsgType `json:"msg_type"`

	// If set to `1`, transfer success. If set to `2`, dry-run success.
	PaymentagentTransfer *PaymentagentTransferRespPaymentagentTransfer `json:"paymentagent_transfer,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// Reference ID of transfer performed
	TransactionId *int `json:"transaction_id,omitempty"`
}

// Echo of the request made.
type PaymentagentTransferRespEchoReq map[string]interface{}

type PaymentagentTransferRespMsgType string

const PaymentagentTransferRespMsgTypePaymentagentTransfer PaymentagentTransferRespMsgType = "paymentagent_transfer"

type PaymentagentTransferRespPaymentagentTransfer int

// Initiate a withdrawal to an approved Payment Agent.
type PaymentagentWithdraw struct {
	// The amount to withdraw to the payment agent.
	Amount float64 `json:"amount"`

	// The currency code.
	Currency string `json:"currency"`

	// [Optional] Remarks about the withdraw. Only letters, numbers, space, period,
	// comma, - ' are allowed.
	Description *string `json:"description,omitempty"`

	// [Optional] If set to 1, just do validation.
	DryRun *PaymentagentWithdrawDryRun `json:"dry_run,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough PaymentagentWithdrawPassthrough `json:"passthrough,omitempty"`

	// The payment agent loginid received from the `paymentagent_list` call.
	PaymentagentLoginid string `json:"paymentagent_loginid"`

	// Must be `1`
	PaymentagentWithdraw PaymentagentWithdrawPaymentagentWithdraw `json:"paymentagent_withdraw"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// Email verification code (received from a `verify_email` call, which must be
	// done first)
	VerificationCode string `json:"verification_code"`
}

type PaymentagentWithdrawDryRun int

// Provide justification to perform withdrawal using a Payment Agent.
type PaymentagentWithdrawJustification struct {
	// Reasons for needing to withdraw using a Payment Agent.
	Message *string `json:"message,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough PaymentagentWithdrawJustificationPassthrough `json:"passthrough,omitempty"`

	// Must be `1`
	PaymentagentWithdrawJustification PaymentagentWithdrawJustificationPaymentagentWithdrawJustification `json:"paymentagent_withdraw_justification"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type PaymentagentWithdrawJustificationPassthrough map[string]interface{}

type PaymentagentWithdrawJustificationPaymentagentWithdrawJustification int

// The result of payment agent withdrawal justification request made.
type PaymentagentWithdrawJustificationResp struct {
	// Echo of the request made.
	EchoReq PaymentagentWithdrawJustificationRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType PaymentagentWithdrawJustificationRespMsgType `json:"msg_type"`

	// 1 on success
	PaymentagentWithdrawJustification *int `json:"paymentagent_withdraw_justification,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type PaymentagentWithdrawJustificationRespEchoReq map[string]interface{}

type PaymentagentWithdrawJustificationRespMsgType string

const PaymentagentWithdrawJustificationRespMsgTypePaymentagentWithdrawJustification PaymentagentWithdrawJustificationRespMsgType = "paymentagent_withdraw_justification"

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type PaymentagentWithdrawPassthrough map[string]interface{}

type PaymentagentWithdrawPaymentagentWithdraw int

// The result of payment agent withdrawal request made.
type PaymentagentWithdrawResp struct {
	// Echo of the request made.
	EchoReq PaymentagentWithdrawRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType PaymentagentWithdrawRespMsgType `json:"msg_type"`

	// Payment agent name.
	PaymentagentName *string `json:"paymentagent_name,omitempty"`

	// If set to `1`, withdrawal success. If set to `2`, dry-run success.
	PaymentagentWithdraw *PaymentagentWithdrawRespPaymentagentWithdraw `json:"paymentagent_withdraw,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// Reference ID of withdrawal performed.
	TransactionId *int `json:"transaction_id,omitempty"`
}

// Echo of the request made.
type PaymentagentWithdrawRespEchoReq map[string]interface{}

type PaymentagentWithdrawRespMsgType string

const PaymentagentWithdrawRespMsgTypePaymentagentWithdraw PaymentagentWithdrawRespMsgType = "paymentagent_withdraw"

type PaymentagentWithdrawRespPaymentagentWithdraw int

// Retrieve a list of available option payout currencies. If a user is logged in,
// only the currencies available for the account will be returned.
type PayoutCurrencies struct {
	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough PayoutCurrenciesPassthrough `json:"passthrough,omitempty"`

	// Must be `1`
	PayoutCurrencies PayoutCurrenciesPayoutCurrencies `json:"payout_currencies"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type PayoutCurrenciesPassthrough map[string]interface{}

type PayoutCurrenciesPayoutCurrencies int

// List of available payout currencies.
type PayoutCurrenciesResp struct {
	// Echo of the request made.
	EchoReq PayoutCurrenciesRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType PayoutCurrenciesRespMsgType `json:"msg_type"`

	// Available payout currencies. Note: if a user is logged in, only the currency
	// available for the account will be returned.
	PayoutCurrencies []string `json:"payout_currencies,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type PayoutCurrenciesRespEchoReq map[string]interface{}

type PayoutCurrenciesRespMsgType string

const PayoutCurrenciesRespMsgTypePayoutCurrencies PayoutCurrenciesRespMsgType = "payout_currencies"

// To send the ping request to the server. Mostly used to test the connection or to
// keep it alive.
type Ping struct {
	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough PingPassthrough `json:"passthrough,omitempty"`

	// Must be `1`
	Ping PingPing `json:"ping"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type PingPassthrough map[string]interface{}

type PingPing int

// The response of ping request.
type PingResp struct {
	// Echo of the request made.
	EchoReq PingRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType PingRespMsgType `json:"msg_type"`

	// Will return 'pong'
	Ping *PingRespPing `json:"ping,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type PingRespEchoReq map[string]interface{}

type PingRespMsgType string

const PingRespMsgTypePing PingRespMsgType = "ping"

type PingRespPing string

const PingRespPingPong PingRespPing = "pong"

// Receive information about my current portfolio of outstanding options
type Portfolio struct {
	// Return only contracts of the specified types
	ContractType []PortfolioContractTypeElem `json:"contract_type,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough PortfolioPassthrough `json:"passthrough,omitempty"`

	// Must be `1`
	Portfolio PortfolioPortfolio `json:"portfolio"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

type PortfolioContractTypeElem string

const PortfolioContractTypeElemASIAND PortfolioContractTypeElem = "ASIAND"
const PortfolioContractTypeElemASIANU PortfolioContractTypeElem = "ASIANU"
const PortfolioContractTypeElemCALL PortfolioContractTypeElem = "CALL"
const PortfolioContractTypeElemCALLE PortfolioContractTypeElem = "CALLE"
const PortfolioContractTypeElemCALLSPREAD PortfolioContractTypeElem = "CALLSPREAD"
const PortfolioContractTypeElemDIGITDIFF PortfolioContractTypeElem = "DIGITDIFF"
const PortfolioContractTypeElemDIGITEVEN PortfolioContractTypeElem = "DIGITEVEN"
const PortfolioContractTypeElemDIGITMATCH PortfolioContractTypeElem = "DIGITMATCH"
const PortfolioContractTypeElemDIGITODD PortfolioContractTypeElem = "DIGITODD"
const PortfolioContractTypeElemDIGITOVER PortfolioContractTypeElem = "DIGITOVER"
const PortfolioContractTypeElemDIGITUNDER PortfolioContractTypeElem = "DIGITUNDER"
const PortfolioContractTypeElemEXPIRYMISS PortfolioContractTypeElem = "EXPIRYMISS"
const PortfolioContractTypeElemEXPIRYMISSE PortfolioContractTypeElem = "EXPIRYMISSE"
const PortfolioContractTypeElemEXPIRYRANGE PortfolioContractTypeElem = "EXPIRYRANGE"
const PortfolioContractTypeElemEXPIRYRANGEE PortfolioContractTypeElem = "EXPIRYRANGEE"
const PortfolioContractTypeElemLBFLOATCALL PortfolioContractTypeElem = "LBFLOATCALL"
const PortfolioContractTypeElemLBFLOATPUT PortfolioContractTypeElem = "LBFLOATPUT"
const PortfolioContractTypeElemLBHIGHLOW PortfolioContractTypeElem = "LBHIGHLOW"
const PortfolioContractTypeElemMULTDOWN PortfolioContractTypeElem = "MULTDOWN"
const PortfolioContractTypeElemMULTUP PortfolioContractTypeElem = "MULTUP"
const PortfolioContractTypeElemNOTOUCH PortfolioContractTypeElem = "NOTOUCH"
const PortfolioContractTypeElemONETOUCH PortfolioContractTypeElem = "ONETOUCH"
const PortfolioContractTypeElemPUT PortfolioContractTypeElem = "PUT"
const PortfolioContractTypeElemPUTE PortfolioContractTypeElem = "PUTE"
const PortfolioContractTypeElemPUTSPREAD PortfolioContractTypeElem = "PUTSPREAD"
const PortfolioContractTypeElemRANGE PortfolioContractTypeElem = "RANGE"
const PortfolioContractTypeElemRESETCALL PortfolioContractTypeElem = "RESETCALL"
const PortfolioContractTypeElemRESETPUT PortfolioContractTypeElem = "RESETPUT"
const PortfolioContractTypeElemRUNHIGH PortfolioContractTypeElem = "RUNHIGH"
const PortfolioContractTypeElemRUNLOW PortfolioContractTypeElem = "RUNLOW"
const PortfolioContractTypeElemTICKHIGH PortfolioContractTypeElem = "TICKHIGH"
const PortfolioContractTypeElemTICKLOW PortfolioContractTypeElem = "TICKLOW"
const PortfolioContractTypeElemTURBOSLONG PortfolioContractTypeElem = "TURBOSLONG"
const PortfolioContractTypeElemTURBOSSHORT PortfolioContractTypeElem = "TURBOSSHORT"
const PortfolioContractTypeElemUPORDOWN PortfolioContractTypeElem = "UPORDOWN"
const PortfolioContractTypeElemVANILLALONGCALL PortfolioContractTypeElem = "VANILLALONGCALL"
const PortfolioContractTypeElemVANILLALONGPUT PortfolioContractTypeElem = "VANILLALONGPUT"

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type PortfolioPassthrough map[string]interface{}

type PortfolioPortfolio int

// Receive a list of outstanding options in the user's portfolio
type PortfolioResp struct {
	// Echo of the request made.
	EchoReq PortfolioRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType PortfolioRespMsgType `json:"msg_type"`

	// Current account's open positions.
	Portfolio *PortfolioRespPortfolio `json:"portfolio,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type PortfolioRespEchoReq map[string]interface{}

type PortfolioRespMsgType string

const PortfolioRespMsgTypePortfolio PortfolioRespMsgType = "portfolio"

// Current account's open positions.
type PortfolioRespPortfolio struct {
	// List of open positions.
	Contracts []PortfolioRespPortfolioContractsElem `json:"contracts"`
}

// The details of each open position.
type PortfolioRespPortfolioContractsElem struct {
	// ID of the application where this contract was purchased.
	AppId interface{} `json:"app_id,omitempty"`

	// Buy price
	BuyPrice *float64 `json:"buy_price,omitempty"`

	// Internal contract identifier number (to be used in a `proposal_open_contract`
	// API call).
	ContractId *int `json:"contract_id,omitempty"`

	// Contract type
	ContractType *string `json:"contract_type,omitempty"`

	// Contract currency
	Currency *string `json:"currency,omitempty"`

	// Epoch of start date
	DateStart *int `json:"date_start,omitempty"`

	// Epoch of expiry time
	ExpiryTime *int `json:"expiry_time,omitempty"`

	// Contract description
	Longcode *string `json:"longcode,omitempty"`

	// Payout price
	Payout *float64 `json:"payout,omitempty"`

	// Epoch of purchase time
	PurchaseTime *int `json:"purchase_time,omitempty"`

	// Contract short code description
	Shortcode *string `json:"shortcode,omitempty"`

	// Symbol code
	Symbol *string `json:"symbol,omitempty"`

	// It is the transaction ID. Every contract (buy or sell) and every payment has a
	// unique ID.
	TransactionId *int `json:"transaction_id,omitempty"`
}

// Retrieve a summary of account Profit Table, according to given search criteria
type ProfitTable struct {
	// Return only contracts of the specified types
	ContractType []ProfitTableContractTypeElem `json:"contract_type,omitempty"`

	// [Optional] Start date (epoch or YYYY-MM-DD)
	DateFrom *string `json:"date_from,omitempty"`

	// [Optional] End date (epoch or YYYY-MM-DD)
	DateTo *string `json:"date_to,omitempty"`

	// [Optional] If set to 1, will return full contracts description.
	Description *ProfitTableDescription `json:"description,omitempty"`

	// [Optional] Apply upper limit to count of transactions received.
	Limit float64 `json:"limit,omitempty"`

	// [Optional] Number of transactions to skip.
	Offset *int `json:"offset,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough ProfitTablePassthrough `json:"passthrough,omitempty"`

	// Must be `1`
	ProfitTable ProfitTableProfitTable `json:"profit_table"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// [Optional] Sort direction.
	Sort ProfitTableSort `json:"sort,omitempty"`
}

type ProfitTableContractTypeElem string

const ProfitTableContractTypeElemACCU ProfitTableContractTypeElem = "ACCU"
const ProfitTableContractTypeElemASIAND ProfitTableContractTypeElem = "ASIAND"
const ProfitTableContractTypeElemASIANU ProfitTableContractTypeElem = "ASIANU"
const ProfitTableContractTypeElemCALL ProfitTableContractTypeElem = "CALL"
const ProfitTableContractTypeElemCALLE ProfitTableContractTypeElem = "CALLE"
const ProfitTableContractTypeElemCALLSPREAD ProfitTableContractTypeElem = "CALLSPREAD"
const ProfitTableContractTypeElemDIGITDIFF ProfitTableContractTypeElem = "DIGITDIFF"
const ProfitTableContractTypeElemDIGITEVEN ProfitTableContractTypeElem = "DIGITEVEN"
const ProfitTableContractTypeElemDIGITMATCH ProfitTableContractTypeElem = "DIGITMATCH"
const ProfitTableContractTypeElemDIGITODD ProfitTableContractTypeElem = "DIGITODD"
const ProfitTableContractTypeElemDIGITOVER ProfitTableContractTypeElem = "DIGITOVER"
const ProfitTableContractTypeElemDIGITUNDER ProfitTableContractTypeElem = "DIGITUNDER"
const ProfitTableContractTypeElemEXPIRYMISS ProfitTableContractTypeElem = "EXPIRYMISS"
const ProfitTableContractTypeElemEXPIRYMISSE ProfitTableContractTypeElem = "EXPIRYMISSE"
const ProfitTableContractTypeElemEXPIRYRANGE ProfitTableContractTypeElem = "EXPIRYRANGE"
const ProfitTableContractTypeElemEXPIRYRANGEE ProfitTableContractTypeElem = "EXPIRYRANGEE"
const ProfitTableContractTypeElemLBFLOATCALL ProfitTableContractTypeElem = "LBFLOATCALL"
const ProfitTableContractTypeElemLBFLOATPUT ProfitTableContractTypeElem = "LBFLOATPUT"
const ProfitTableContractTypeElemLBHIGHLOW ProfitTableContractTypeElem = "LBHIGHLOW"
const ProfitTableContractTypeElemMULTDOWN ProfitTableContractTypeElem = "MULTDOWN"
const ProfitTableContractTypeElemMULTUP ProfitTableContractTypeElem = "MULTUP"
const ProfitTableContractTypeElemNOTOUCH ProfitTableContractTypeElem = "NOTOUCH"
const ProfitTableContractTypeElemONETOUCH ProfitTableContractTypeElem = "ONETOUCH"
const ProfitTableContractTypeElemPUT ProfitTableContractTypeElem = "PUT"
const ProfitTableContractTypeElemPUTE ProfitTableContractTypeElem = "PUTE"
const ProfitTableContractTypeElemPUTSPREAD ProfitTableContractTypeElem = "PUTSPREAD"
const ProfitTableContractTypeElemRANGE ProfitTableContractTypeElem = "RANGE"
const ProfitTableContractTypeElemRESETCALL ProfitTableContractTypeElem = "RESETCALL"
const ProfitTableContractTypeElemRESETPUT ProfitTableContractTypeElem = "RESETPUT"
const ProfitTableContractTypeElemRUNHIGH ProfitTableContractTypeElem = "RUNHIGH"
const ProfitTableContractTypeElemRUNLOW ProfitTableContractTypeElem = "RUNLOW"
const ProfitTableContractTypeElemTICKHIGH ProfitTableContractTypeElem = "TICKHIGH"
const ProfitTableContractTypeElemTICKLOW ProfitTableContractTypeElem = "TICKLOW"
const ProfitTableContractTypeElemTURBOSLONG ProfitTableContractTypeElem = "TURBOSLONG"
const ProfitTableContractTypeElemTURBOSSHORT ProfitTableContractTypeElem = "TURBOSSHORT"
const ProfitTableContractTypeElemUPORDOWN ProfitTableContractTypeElem = "UPORDOWN"
const ProfitTableContractTypeElemVANILLALONGCALL ProfitTableContractTypeElem = "VANILLALONGCALL"
const ProfitTableContractTypeElemVANILLALONGPUT ProfitTableContractTypeElem = "VANILLALONGPUT"

type ProfitTableDescription int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type ProfitTablePassthrough map[string]interface{}

type ProfitTableProfitTable int

// A summary of account profit table is received
type ProfitTableResp struct {
	// Echo of the request made.
	EchoReq ProfitTableRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType ProfitTableRespMsgType `json:"msg_type"`

	// Account Profit Table.
	ProfitTable *ProfitTableRespProfitTable `json:"profit_table,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type ProfitTableRespEchoReq map[string]interface{}

type ProfitTableRespMsgType string

const ProfitTableRespMsgTypeProfitTable ProfitTableRespMsgType = "profit_table"

// Account Profit Table.
type ProfitTableRespProfitTable struct {
	// Number of transactions returned in this call
	Count *float64 `json:"count,omitempty"`

	// Array of returned transactions
	Transactions []ProfitTableRespProfitTableTransactionsElem `json:"transactions,omitempty"`
}

type ProfitTableRespProfitTableTransactionsElem struct {
	// ID of the application where this contract was purchased.
	AppId interface{} `json:"app_id,omitempty"`

	// The buy price
	BuyPrice *float64 `json:"buy_price,omitempty"`

	// The unique contract identifier.
	ContractId interface{} `json:"contract_id,omitempty"`

	// The duration type of the contract.
	DurationType interface{} `json:"duration_type,omitempty"`

	// The description of contract purchased if description is set to 1
	Longcode *string `json:"longcode,omitempty"`

	// Payout price
	Payout *float64 `json:"payout,omitempty"`

	// Epoch purchase time of the transaction
	PurchaseTime *int `json:"purchase_time,omitempty"`

	// The price the contract sold for.
	SellPrice *float64 `json:"sell_price,omitempty"`

	// Epoch sell time of the transaction
	SellTime interface{} `json:"sell_time,omitempty"`

	// Compact description of the contract purchased if description is set to 1
	Shortcode *string `json:"shortcode,omitempty"`

	// The transaction Identifier. Every contract (buy or sell) and every payment has
	// a unique transaction identifier.
	TransactionId *int `json:"transaction_id,omitempty"`
}

type ProfitTableSort string

const ProfitTableSortASC ProfitTableSort = "ASC"
const ProfitTableSortDESC ProfitTableSort = "DESC"

// Gets latest price for a specific contract.
type Proposal struct {
	// [Optional] Proposed contract payout or stake, or multiplier (for lookbacks).
	Amount *float64 `json:"amount,omitempty"`

	// [Optional] Barrier for the contract (or last digit prediction for digit
	// contracts). Contracts less than 24 hours in duration would need a relative
	// barrier (barriers which need +/-), where entry spot would be adjusted
	// accordingly with that amount to define a barrier, except for Synthetic Indices
	// as they support both relative and absolute barriers. Not needed for lookbacks.
	Barrier *string `json:"barrier,omitempty"`

	// [Optional] Low barrier for the contract (for contracts with two barriers).
	// Contracts less than 24 hours in duration would need a relative barrier
	// (barriers which need +/-), where entry spot would be adjusted accordingly with
	// that amount to define a barrier, except for Synthetic Indices as they support
	// both relative and absolute barriers. Not needed for lookbacks.
	Barrier2 *string `json:"barrier2,omitempty"`

	// [Optional] Barrier range for callputspread.
	BarrierRange *ProposalBarrierRange `json:"barrier_range,omitempty"`

	// [Optional] Indicates type of the `amount`.
	Basis *ProposalBasis `json:"basis,omitempty"`

	// Cancellation duration option (only for `MULTUP` and `MULTDOWN` contracts).
	Cancellation *string `json:"cancellation,omitempty"`

	// The proposed contract type
	ContractType ProposalContractType `json:"contract_type"`

	// This can only be the account-holder's currency (obtained from
	// `payout_currencies` call).
	Currency string `json:"currency"`

	// [Optional] Epoch value of the expiry time of the contract. Either date_expiry
	// or duration is required.
	DateExpiry *int `json:"date_expiry,omitempty"`

	// [Optional] Indicates epoch value of the starting time of the contract. If left
	// empty, the start time of the contract is now.
	DateStart *int `json:"date_start,omitempty"`

	// [Optional] Duration quantity. Either date_expiry or duration is required.
	Duration *int `json:"duration,omitempty"`

	// [Optional] Duration unit - `s`: seconds, `m`: minutes, `h`: hours, `d`: days,
	// `t`: ticks.
	DurationUnit ProposalDurationUnit `json:"duration_unit,omitempty"`

	// [Optional] Growth rate of an accumulator contract.
	GrowthRate *float64 `json:"growth_rate,omitempty"`

	// Add an order to close the contract once the order condition is met (only for
	// `MULTUP` and `MULTDOWN` and 'ACCU' contracts). Supported orders: `take_profit`,
	// `stop_loss`.
	LimitOrder *ProposalLimitOrder `json:"limit_order,omitempty"`

	// [Optional] The multiplier for non-binary options. E.g. lookbacks.
	Multiplier *float64 `json:"multiplier,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough ProposalPassthrough `json:"passthrough,omitempty"`

	// [Optional] The product type.
	ProductType ProposalProductType `json:"product_type,omitempty"`

	// Must be `1`
	Proposal ProposalProposal `json:"proposal"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// [Optional] The tick that is predicted to have the highest/lowest value - for
	// `TICKHIGH` and `TICKLOW` contracts.
	SelectedTick *int `json:"selected_tick,omitempty"`

	// [Optional] 1 - to initiate a realtime stream of prices. Note that tick trades
	// (without a user-defined barrier), digit trades and less than 24 hours
	// at-the-money contracts for the following underlying symbols are not streamed:
	// `R_10`, `R_25`, `R_50`, `R_75`, `R_100`, `RDBULL`, `RDBEAR` (this is because
	// their price is constant).
	Subscribe *ProposalSubscribe `json:"subscribe,omitempty"`

	// The short symbol name (obtained from `active_symbols` call).
	Symbol string `json:"symbol"`

	// [Optional] Required only for multi-barrier trading. Defines the epoch value of
	// the trading period start time.
	TradingPeriodStart *int `json:"trading_period_start,omitempty"`
}

type ProposalBarrierRange string

const ProposalBarrierRangeMiddle ProposalBarrierRange = "middle"
const ProposalBarrierRangeTight ProposalBarrierRange = "tight"
const ProposalBarrierRangeWide ProposalBarrierRange = "wide"

type ProposalBasis string

const ProposalBasisPayout ProposalBasis = "payout"
const ProposalBasisStake ProposalBasis = "stake"

type ProposalContractType string

const ProposalContractTypeACCU ProposalContractType = "ACCU"
const ProposalContractTypeASIAND ProposalContractType = "ASIAND"
const ProposalContractTypeASIANU ProposalContractType = "ASIANU"
const ProposalContractTypeCALL ProposalContractType = "CALL"
const ProposalContractTypeCALLE ProposalContractType = "CALLE"
const ProposalContractTypeCALLSPREAD ProposalContractType = "CALLSPREAD"
const ProposalContractTypeDIGITDIFF ProposalContractType = "DIGITDIFF"
const ProposalContractTypeDIGITEVEN ProposalContractType = "DIGITEVEN"
const ProposalContractTypeDIGITMATCH ProposalContractType = "DIGITMATCH"
const ProposalContractTypeDIGITODD ProposalContractType = "DIGITODD"
const ProposalContractTypeDIGITOVER ProposalContractType = "DIGITOVER"
const ProposalContractTypeDIGITUNDER ProposalContractType = "DIGITUNDER"
const ProposalContractTypeEXPIRYMISS ProposalContractType = "EXPIRYMISS"
const ProposalContractTypeEXPIRYMISSE ProposalContractType = "EXPIRYMISSE"
const ProposalContractTypeEXPIRYRANGE ProposalContractType = "EXPIRYRANGE"
const ProposalContractTypeEXPIRYRANGEE ProposalContractType = "EXPIRYRANGEE"
const ProposalContractTypeLBFLOATCALL ProposalContractType = "LBFLOATCALL"
const ProposalContractTypeLBFLOATPUT ProposalContractType = "LBFLOATPUT"
const ProposalContractTypeLBHIGHLOW ProposalContractType = "LBHIGHLOW"
const ProposalContractTypeMULTDOWN ProposalContractType = "MULTDOWN"
const ProposalContractTypeMULTUP ProposalContractType = "MULTUP"
const ProposalContractTypeNOTOUCH ProposalContractType = "NOTOUCH"
const ProposalContractTypeONETOUCH ProposalContractType = "ONETOUCH"
const ProposalContractTypePUT ProposalContractType = "PUT"
const ProposalContractTypePUTE ProposalContractType = "PUTE"
const ProposalContractTypePUTSPREAD ProposalContractType = "PUTSPREAD"
const ProposalContractTypeRANGE ProposalContractType = "RANGE"
const ProposalContractTypeRESETCALL ProposalContractType = "RESETCALL"
const ProposalContractTypeRESETPUT ProposalContractType = "RESETPUT"
const ProposalContractTypeRUNHIGH ProposalContractType = "RUNHIGH"
const ProposalContractTypeRUNLOW ProposalContractType = "RUNLOW"
const ProposalContractTypeTICKHIGH ProposalContractType = "TICKHIGH"
const ProposalContractTypeTICKLOW ProposalContractType = "TICKLOW"
const ProposalContractTypeTURBOSLONG ProposalContractType = "TURBOSLONG"
const ProposalContractTypeTURBOSSHORT ProposalContractType = "TURBOSSHORT"
const ProposalContractTypeUPORDOWN ProposalContractType = "UPORDOWN"
const ProposalContractTypeVANILLALONGCALL ProposalContractType = "VANILLALONGCALL"
const ProposalContractTypeVANILLALONGPUT ProposalContractType = "VANILLALONGPUT"

type ProposalDurationUnit string

const ProposalDurationUnitD ProposalDurationUnit = "d"
const ProposalDurationUnitH ProposalDurationUnit = "h"
const ProposalDurationUnitM ProposalDurationUnit = "m"
const ProposalDurationUnitS ProposalDurationUnit = "s"
const ProposalDurationUnitT ProposalDurationUnit = "t"

// Add an order to close the contract once the order condition is met (only for
// `MULTUP` and `MULTDOWN` and 'ACCU' contracts). Supported orders: `take_profit`,
// `stop_loss`.
type ProposalLimitOrder struct {
	// Contract will be automatically closed when the value of the contract reaches a
	// specific loss.
	StopLoss *float64 `json:"stop_loss,omitempty"`

	// Contract will be automatically closed when the value of the contract reaches a
	// specific profit.
	TakeProfit *float64 `json:"take_profit,omitempty"`
}

// Get latest price (and other information) for a contract in the user's portfolio
type ProposalOpenContract struct {
	// [Optional] Contract ID received from a `portfolio` request. If not set, you
	// will receive stream of all open contracts.
	ContractId *int `json:"contract_id,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough ProposalOpenContractPassthrough `json:"passthrough,omitempty"`

	// Must be `1`
	ProposalOpenContract ProposalOpenContractProposalOpenContract `json:"proposal_open_contract"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// [Optional] `1` to stream.
	Subscribe *ProposalOpenContractSubscribe `json:"subscribe,omitempty"`
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type ProposalOpenContractPassthrough map[string]interface{}

type ProposalOpenContractProposalOpenContract int

// Latest price and other details for an open contract in the user's portfolio
type ProposalOpenContractResp struct {
	// Echo of the request made.
	EchoReq ProposalOpenContractRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType *ProposalOpenContractRespMsgType `json:"msg_type,omitempty"`

	// Latest price and other details for an open contract
	ProposalOpenContract *ProposalOpenContractRespProposalOpenContract `json:"proposal_open_contract,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// For subscription requests only.
	Subscription *ProposalOpenContractRespSubscription `json:"subscription,omitempty"`
}

// Echo of the request made.
type ProposalOpenContractRespEchoReq map[string]interface{}

type ProposalOpenContractRespMsgType string

const ProposalOpenContractRespMsgTypeProposalOpenContract ProposalOpenContractRespMsgType = "proposal_open_contract"

// Latest price and other details for an open contract
type ProposalOpenContractRespProposalOpenContract struct {
	// Account Id
	AccountId *float64 `json:"account_id,omitempty"`

	// Tick details around contract start and end time.
	AuditDetails interface{} `json:"audit_details,omitempty"`

	// Barrier of the contract (if any).
	Barrier interface{} `json:"barrier,omitempty"`

	// The number of barriers a contract has.
	BarrierCount *float64 `json:"barrier_count,omitempty"`

	// [Only for accumulator] Absolute difference between high/low barrier and spot
	BarrierSpotDistance *string `json:"barrier_spot_distance,omitempty"`

	// Price at which the contract could be sold back to the company.
	BidPrice *float64 `json:"bid_price,omitempty"`

	// Price at which contract was purchased
	BuyPrice *float64 `json:"buy_price,omitempty"`

	// Contains information about contract cancellation option.
	Cancellation *ProposalOpenContractRespProposalOpenContractCancellation `json:"cancellation,omitempty"`

	// Commission in payout currency amount.
	Commision interface{} `json:"commision,omitempty"`

	// Commission in payout currency amount.
	Commission interface{} `json:"commission,omitempty"`

	// The internal contract identifier
	ContractId *int `json:"contract_id,omitempty"`

	// Contract type.
	ContractType *string `json:"contract_type,omitempty"`

	// The currency code of the contract.
	Currency *string `json:"currency,omitempty"`

	// Spot value if we have license to stream this symbol.
	CurrentSpot *float64 `json:"current_spot,omitempty"`

	// Spot value with the correct precision if we have license to stream this symbol.
	CurrentSpotDisplayValue *string `json:"current_spot_display_value,omitempty"`

	// [Applicable for accumulator] High barrier based on current spot.
	CurrentSpotHighBarrier *string `json:"current_spot_high_barrier,omitempty"`

	// [Applicable for accumulator] Low barrier based on current spot.
	CurrentSpotLowBarrier *string `json:"current_spot_low_barrier,omitempty"`

	// The corresponding time of the current spot.
	CurrentSpotTime *int `json:"current_spot_time,omitempty"`

	// Expiry date (epoch) of the Contract. Please note that it is not applicable for
	// tick trade contracts.
	DateExpiry *int `json:"date_expiry,omitempty"`

	// Settlement date (epoch) of the contract.
	DateSettlement *int `json:"date_settlement,omitempty"`

	// Start date (epoch) of the contract.
	DateStart *int `json:"date_start,omitempty"`

	// Display name of underlying
	DisplayName *string `json:"display_name,omitempty"`

	// [Only for vanilla or turbos options] The implied number of contracts
	DisplayNumberOfContracts *string `json:"display_number_of_contracts,omitempty"`

	// The `bid_price` with the correct precision
	DisplayValue *string `json:"display_value,omitempty"`

	// Same as `entry_tick`. For backwards compatibility.
	EntrySpot interface{} `json:"entry_spot,omitempty"`

	// Same as `entry_tick_display_value`. For backwards compatibility.
	EntrySpotDisplayValue interface{} `json:"entry_spot_display_value,omitempty"`

	// This is the entry spot of the contract. For contracts starting immediately it
	// is the next tick after the start time. For forward-starting contracts it is the
	// spot at the start time.
	EntryTick *float64 `json:"entry_tick,omitempty"`

	// This is the entry spot with the correct precision of the contract. For
	// contracts starting immediately it is the next tick after the start time. For
	// forward-starting contracts it is the spot at the start time.
	EntryTickDisplayValue *string `json:"entry_tick_display_value,omitempty"`

	// This is the epoch time of the entry tick.
	EntryTickTime *int `json:"entry_tick_time,omitempty"`

	// Exit tick can refer to the latest tick at the end time, the tick that fulfils
	// the contract's winning or losing condition for path dependent contracts
	// (Touch/No Touch and Stays Between/Goes Outside) or the tick at which the
	// contract is sold before expiry.
	ExitTick *float64 `json:"exit_tick,omitempty"`

	// Exit tick can refer to the latest tick at the end time, the tick that fulfils
	// the contract's winning or losing condition for path dependent contracts
	// (Touch/No Touch and Stays Between/Goes Outside) or the tick at which the
	// contract is sold before expiry.
	ExitTickDisplayValue *string `json:"exit_tick_display_value,omitempty"`

	// This is the epoch time of the exit tick. Note that since certain instruments
	// don't tick every second, the exit tick time may be a few seconds before the end
	// time.
	ExitTickTime *int `json:"exit_tick_time,omitempty"`

	// This is the expiry time.
	ExpiryTime *int `json:"expiry_time,omitempty"`

	// [Only for accumulator] Growth rate of an accumulator contract.
	GrowthRate *float64 `json:"growth_rate,omitempty"`

	// High barrier of the contract (if any).
	HighBarrier *string `json:"high_barrier,omitempty"`

	// A per-connection unique identifier. Can be passed to the `forget` API call to
	// unsubscribe.
	Id *string `json:"id,omitempty"`

	// Whether the contract is expired or not.
	IsExpired *ProposalOpenContractRespProposalOpenContractIsExpired `json:"is_expired,omitempty"`

	// Whether the contract is forward-starting or not.
	IsForwardStarting *ProposalOpenContractRespProposalOpenContractIsForwardStarting `json:"is_forward_starting,omitempty"`

	// Whether the contract is an intraday contract.
	IsIntraday *ProposalOpenContractRespProposalOpenContractIsIntraday `json:"is_intraday,omitempty"`

	// Whether the contract expiry price will depend on the path of the market (e.g.
	// One Touch contract).
	IsPathDependent *ProposalOpenContractRespProposalOpenContractIsPathDependent `json:"is_path_dependent,omitempty"`

	// Whether the contract is settleable or not.
	IsSettleable *ProposalOpenContractRespProposalOpenContractIsSettleable `json:"is_settleable,omitempty"`

	// Whether the contract is sold or not.
	IsSold *ProposalOpenContractRespProposalOpenContractIsSold `json:"is_sold,omitempty"`

	// Whether the contract can be cancelled.
	IsValidToCancel *ProposalOpenContractRespProposalOpenContractIsValidToCancel `json:"is_valid_to_cancel,omitempty"`

	// Whether the contract can be sold back to the company.
	IsValidToSell *ProposalOpenContractRespProposalOpenContractIsValidToSell `json:"is_valid_to_sell,omitempty"`

	// Orders are applicable to `MULTUP` and `MULTDOWN` contracts only.
	LimitOrder *ProposalOpenContractRespProposalOpenContractLimitOrder `json:"limit_order,omitempty"`

	// Text description of the contract purchased, Example: Win payout if Volatility
	// 100 Index is strictly higher than entry spot at 10 minutes after contract start
	// time.
	Longcode *string `json:"longcode,omitempty"`

	// Low barrier of the contract (if any).
	LowBarrier *string `json:"low_barrier,omitempty"`

	// [Only for lookback trades] Multiplier applies when calculating the final payoff
	// for each type of lookback. e.g. (Exit spot - Lowest historical price) *
	// multiplier = Payout
	Multiplier *float64 `json:"multiplier,omitempty"`

	// [Only for vanilla or turbos options] The implied number of contracts
	NumberOfContracts *float64 `json:"number_of_contracts,omitempty"`

	// Payout value of the contract.
	Payout *float64 `json:"payout,omitempty"`

	// The latest bid price minus buy price.
	Profit *float64 `json:"profit,omitempty"`

	// Profit in percentage.
	ProfitPercentage *float64 `json:"profit_percentage,omitempty"`

	// Epoch of purchase time, will be same as `date_start` for all contracts except
	// forward starting contracts.
	PurchaseTime *int `json:"purchase_time,omitempty"`

	// [Only for reset trades] The epoch time of a barrier reset.
	ResetTime *int `json:"reset_time,omitempty"`

	// Price at which contract was sold, only available when contract has been sold.
	SellPrice *float64 `json:"sell_price,omitempty"`

	// Latest spot value at the sell time. (only present for contracts already sold).
	// Will no longer be supported in the next API release.
	SellSpot *float64 `json:"sell_spot,omitempty"`

	// Latest spot value with the correct precision at the sell time. (only present
	// for contracts already sold). Will no longer be supported in the next API
	// release.
	SellSpotDisplayValue *string `json:"sell_spot_display_value,omitempty"`

	// Epoch time of the sell spot. Note that since certain underlyings don't tick
	// every second, the sell spot time may be a few seconds before the sell time.
	// (only present for contracts already sold). Will no longer be supported in the
	// next API release.
	SellSpotTime *int `json:"sell_spot_time,omitempty"`

	// Epoch time of when the contract was sold (only present for contracts already
	// sold)
	SellTime interface{} `json:"sell_time,omitempty"`

	// Coded description of the contract purchased.
	Shortcode *string `json:"shortcode,omitempty"`

	// Contract status. Will be `sold` if the contract was sold back before expiry,
	// `won` if won and `lost` if lost at expiry. Otherwise will be `open`
	Status *ProposalOpenContractRespProposalOpenContractStatus `json:"status,omitempty"`

	// Only for tick trades, number of ticks
	TickCount *int `json:"tick_count,omitempty"`

	// [Only for accumulator] Number of ticks passed since entry_tick
	TickPassed *int `json:"tick_passed,omitempty"`

	// Tick stream from entry to end time.
	TickStream []ProposalOpenContractRespProposalOpenContractTickStreamElem `json:"tick_stream,omitempty"`

	// Every contract has buy and sell transaction ids, i.e. when you purchase a
	// contract we associate it with buy transaction id, and if contract is already
	// sold we associate that with sell transaction id.
	TransactionIds *ProposalOpenContractRespProposalOpenContractTransactionIds `json:"transaction_ids,omitempty"`

	// The underlying symbol code.
	Underlying *string `json:"underlying,omitempty"`

	// Error message if validation fails
	ValidationError *string `json:"validation_error,omitempty"`

	// Error code if validation fails
	ValidationErrorCode *string `json:"validation_error_code,omitempty"`
}

// Contains information about contract cancellation option.
type ProposalOpenContractRespProposalOpenContractCancellation struct {
	// Ask price of contract cancellation option.
	AskPrice *float64 `json:"ask_price,omitempty"`

	// Expiry time in epoch for contract cancellation option.
	DateExpiry *int `json:"date_expiry,omitempty"`
}

type ProposalOpenContractRespProposalOpenContractIsExpired int

type ProposalOpenContractRespProposalOpenContractIsForwardStarting int

type ProposalOpenContractRespProposalOpenContractIsIntraday int

type ProposalOpenContractRespProposalOpenContractIsPathDependent int

type ProposalOpenContractRespProposalOpenContractIsSettleable int

type ProposalOpenContractRespProposalOpenContractIsSold int

type ProposalOpenContractRespProposalOpenContractIsValidToCancel int

type ProposalOpenContractRespProposalOpenContractIsValidToSell int

// Orders are applicable to `MULTUP` and `MULTDOWN` contracts only.
type ProposalOpenContractRespProposalOpenContractLimitOrder struct {
	// Contains information where the contract will be closed automatically at the
	// loss specified by the user.
	StopLoss *ProposalOpenContractRespProposalOpenContractLimitOrderStopLoss `json:"stop_loss,omitempty"`

	// Contains information where the contract will be closed automatically when the
	// value of the contract is close to zero. This is set by the us.
	StopOut *ProposalOpenContractRespProposalOpenContractLimitOrderStopOut `json:"stop_out,omitempty"`

	// Contain information where the contract will be closed automatically at the
	// profit specified by the user.
	TakeProfit *ProposalOpenContractRespProposalOpenContractLimitOrderTakeProfit `json:"take_profit,omitempty"`
}

// Contains information where the contract will be closed automatically at the loss
// specified by the user.
type ProposalOpenContractRespProposalOpenContractLimitOrderStopLoss struct {
	// Localized display name
	DisplayName *string `json:"display_name,omitempty"`

	// Stop loss amount
	OrderAmount interface{} `json:"order_amount,omitempty"`

	// Stop loss order epoch
	OrderDate *int `json:"order_date,omitempty"`

	// Pip-sized barrier value
	Value interface{} `json:"value,omitempty"`
}

// Contains information where the contract will be closed automatically when the
// value of the contract is close to zero. This is set by the us.
type ProposalOpenContractRespProposalOpenContractLimitOrderStopOut struct {
	// Localized display name
	DisplayName *string `json:"display_name,omitempty"`

	// Stop out amount
	OrderAmount *float64 `json:"order_amount,omitempty"`

	// Stop out order epoch
	OrderDate *int `json:"order_date,omitempty"`

	// Pip-sized barrier value
	Value *string `json:"value,omitempty"`
}

// Contain information where the contract will be closed automatically at the
// profit specified by the user.
type ProposalOpenContractRespProposalOpenContractLimitOrderTakeProfit struct {
	// Localized display name
	DisplayName *string `json:"display_name,omitempty"`

	// Take profit amount
	OrderAmount interface{} `json:"order_amount,omitempty"`

	// Take profit order epoch
	OrderDate *int `json:"order_date,omitempty"`

	// Pip-sized barrier value
	Value interface{} `json:"value,omitempty"`
}

type ProposalOpenContractRespProposalOpenContractStatus struct {
	Value interface{}
}

type ProposalOpenContractRespProposalOpenContractTickStreamElem struct {
	// Epoch time of a tick or the contract start or end time.
	Epoch *int `json:"epoch,omitempty"`

	// The spot value at the given epoch.
	Tick interface{} `json:"tick,omitempty"`

	// The spot value with the correct precision at the given epoch.
	TickDisplayValue interface{} `json:"tick_display_value,omitempty"`
}

// Every contract has buy and sell transaction ids, i.e. when you purchase a
// contract we associate it with buy transaction id, and if contract is already
// sold we associate that with sell transaction id.
type ProposalOpenContractRespProposalOpenContractTransactionIds struct {
	// Buy transaction ID for that contract
	Buy *int `json:"buy,omitempty"`

	// Sell transaction ID for that contract, only present when contract is already
	// sold.
	Sell *int `json:"sell,omitempty"`
}

// For subscription requests only.
type ProposalOpenContractRespSubscription struct {
	// A per-connection unique identifier. Can be passed to the `forget` API call to
	// unsubscribe.
	Id string `json:"id"`
}

type ProposalOpenContractSubscribe int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type ProposalPassthrough map[string]interface{}

type ProposalProductType string

const ProposalProductTypeBasic ProposalProductType = "basic"

type ProposalProposal int

// Latest price and other details for a given contract
type ProposalResp struct {
	// Echo of the request made.
	EchoReq ProposalRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType ProposalRespMsgType `json:"msg_type"`

	// Latest price and other details for a given contract
	Proposal *ProposalRespProposal `json:"proposal,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// For subscription requests only.
	Subscription *ProposalRespSubscription `json:"subscription,omitempty"`
}

// Echo of the request made.
type ProposalRespEchoReq map[string]interface{}

type ProposalRespMsgType string

const ProposalRespMsgTypeProposal ProposalRespMsgType = "proposal"

// Latest price and other details for a given contract
type ProposalRespProposal struct {
	// The ask price.
	AskPrice float64 `json:"ask_price"`

	// [Only for vanilla options] The choices of predefined strike price for client to
	// choose
	BarrierChoices []interface{} `json:"barrier_choices,omitempty"`

	// Contains information about contract cancellation option.
	Cancellation *ProposalRespProposalCancellation `json:"cancellation,omitempty"`

	// Commission changed in percentage (%).
	Commission interface{} `json:"commission,omitempty"`

	// Contains contract information.
	ContractDetails *ProposalRespProposalContractDetails `json:"contract_details,omitempty"`

	// The end date of the contract.
	DateExpiry *int `json:"date_expiry,omitempty"`

	// The start date of the contract.
	DateStart int `json:"date_start"`

	// [Only for vanilla or turbos options] The implied number of contracts
	DisplayNumberOfContracts *string `json:"display_number_of_contracts,omitempty"`

	// Same as `ask_price`.
	DisplayValue string `json:"display_value"`

	// A per-connection unique identifier. Can be passed to the `forget` API call to
	// unsubscribe.
	Id string `json:"id"`

	// Contains limit order information. (Only applicable for contract with limit
	// order).
	LimitOrder *ProposalRespProposalLimitOrder `json:"limit_order,omitempty"`

	// Example: Win payout if Random 100 Index is strictly higher than entry spot at
	// 15 minutes after contract start time.
	Longcode string `json:"longcode"`

	// [Only for vanilla or turbos options] Maximum stakes allowed
	MaxStake *float64 `json:"max_stake,omitempty"`

	// [Only for vanilla or turbos options] Minimum stakes allowed
	MinStake *float64 `json:"min_stake,omitempty"`

	// [Only for lookback trades] Multiplier applies when calculating the final payoff
	// for each type of lookback. e.g. (Exit spot - Lowest historical price) *
	// multiplier = Payout
	Multiplier *float64 `json:"multiplier,omitempty"`

	// [Only for vanilla or turbos options] The implied number of contracts
	NumberOfContracts *float64 `json:"number_of_contracts,omitempty"`

	// The payout amount of the contract.
	Payout float64 `json:"payout"`

	// Spot value (if there are no Exchange data-feed licensing restrictions for the
	// underlying symbol).
	Spot float64 `json:"spot"`

	// The corresponding time of the spot value.
	SpotTime int `json:"spot_time"`
}

// Contains information about contract cancellation option.
type ProposalRespProposalCancellation struct {
	// Ask price of contract cancellation option.
	AskPrice *float64 `json:"ask_price,omitempty"`

	// Expiry time in epoch for contract cancellation option.
	DateExpiry *int `json:"date_expiry,omitempty"`
}

// Contains contract information.
type ProposalRespProposalContractDetails struct {
	// Barrier of the contract.
	Barrier *string `json:"barrier,omitempty"`

	// Absolute difference between high/low barrier and spot
	BarrierSpotDistance *string `json:"barrier_spot_distance,omitempty"`

	// High barrier calculated based on current spot
	HighBarrier *string `json:"high_barrier,omitempty"`

	// Epoch of last tick considered for stat chart
	LastTickEpoch *int `json:"last_tick_epoch,omitempty"`

	// Low barrier calculated based on current spot
	LowBarrier *string `json:"low_barrier,omitempty"`

	// Maximum payout that user can get out of a contract, contract will close
	// automatically if payout reaches this number
	MaximumPayout *float64 `json:"maximum_payout,omitempty"`

	// Maximum duration that a contract can last, contract will close automatically
	// after this number of ticks
	MaximumTicks *int `json:"maximum_ticks,omitempty"`

	// Tick size barrier for Accumulator contracts
	TickSizeBarrier *float64 `json:"tick_size_barrier,omitempty"`

	// An array of numbers  to build a stat chart - each number represents the
	// duration that spot stayed between barries
	TicksStayedIn []int `json:"ticks_stayed_in,omitempty"`
}

// Contains limit order information. (Only applicable for contract with limit
// order).
type ProposalRespProposalLimitOrder struct {
	// Contains information where the contract will be closed automatically at the
	// loss specified by the user.
	StopLoss *ProposalRespProposalLimitOrderStopLoss `json:"stop_loss,omitempty"`

	// Contains information where the contract will be closed automatically when the
	// value of the contract is close to zero. This is set by the us.
	StopOut *ProposalRespProposalLimitOrderStopOut `json:"stop_out,omitempty"`

	// Contains information where the contract will be closed automatically at the
	// profit specified by the user.
	TakeProfit *ProposalRespProposalLimitOrderTakeProfit `json:"take_profit,omitempty"`
}

// Contains information where the contract will be closed automatically at the loss
// specified by the user.
type ProposalRespProposalLimitOrderStopLoss struct {
	// Localized display name
	DisplayName *string `json:"display_name,omitempty"`

	// Stop loss amount
	OrderAmount interface{} `json:"order_amount,omitempty"`

	// Stop loss order epoch
	OrderDate *int `json:"order_date,omitempty"`

	// Pip-sized barrier value
	Value interface{} `json:"value,omitempty"`
}

// Contains information where the contract will be closed automatically when the
// value of the contract is close to zero. This is set by the us.
type ProposalRespProposalLimitOrderStopOut struct {
	// Localized display name
	DisplayName *string `json:"display_name,omitempty"`

	// Stop out amount
	OrderAmount *float64 `json:"order_amount,omitempty"`

	// Stop out order epoch
	OrderDate *int `json:"order_date,omitempty"`

	// Pip-sized barrier value
	Value *string `json:"value,omitempty"`
}

// Contains information where the contract will be closed automatically at the
// profit specified by the user.
type ProposalRespProposalLimitOrderTakeProfit struct {
	// Localized display name
	DisplayName *string `json:"display_name,omitempty"`

	// Take profit amount
	OrderAmount interface{} `json:"order_amount,omitempty"`

	// Take profit order epoch
	OrderDate *int `json:"order_date,omitempty"`

	// Pip-sized barrier value
	Value interface{} `json:"value,omitempty"`
}

// For subscription requests only.
type ProposalRespSubscription struct {
	// A per-connection unique identifier. Can be passed to the `forget` API call to
	// unsubscribe.
	Id string `json:"id"`
}

type ProposalSubscribe int

// Retrieve summary of client's trades and account for the Reality Check facility.
// A 'reality check' means a display of time elapsed since the session began, and
// associated client profit/loss. The Reality Check facility is a regulatory
// requirement for certain landing companies.
type RealityCheck struct {
	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough RealityCheckPassthrough `json:"passthrough,omitempty"`

	// Must be `1`
	RealityCheck RealityCheckRealityCheck `json:"reality_check"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type RealityCheckPassthrough map[string]interface{}

type RealityCheckRealityCheck int

// This gives summary of client's trades and account for reality check
type RealityCheckResp struct {
	// Echo of the request made.
	EchoReq RealityCheckRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType RealityCheckRespMsgType `json:"msg_type"`

	// Reality check summary of trades.
	RealityCheck *RealityCheckRespRealityCheck `json:"reality_check,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type RealityCheckRespEchoReq map[string]interface{}

type RealityCheckRespMsgType string

const RealityCheckRespMsgTypeRealityCheck RealityCheckRespMsgType = "reality_check"

// Reality check summary of trades.
type RealityCheckRespRealityCheck struct {
	// Total amount of contract purchased.
	BuyAmount *float64 `json:"buy_amount,omitempty"`

	// Total count of contract purchased.
	BuyCount *int `json:"buy_count,omitempty"`

	// Currency of client account i.e currency for trading
	Currency *string `json:"currency,omitempty"`

	// Client loginid.
	Loginid *string `json:"loginid,omitempty"`

	// Total count of contracts that are not yet expired.
	OpenContractCount *int `json:"open_contract_count,omitempty"`

	// Indicative profit of contract as per current market price.
	PotentialProfit *float64 `json:"potential_profit,omitempty"`

	// Total amount of contracts sold.
	SellAmount *float64 `json:"sell_amount,omitempty"`

	// Total count of contract sold.
	SellCount *int `json:"sell_count,omitempty"`

	// Reality check summary start time epoch
	StartTime *int `json:"start_time,omitempty"`
}

// This call returns a list of countries and 2-letter country codes, suitable for
// populating the account opening form.
type ResidenceList struct {
	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough ResidenceListPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// Must be `1`
	ResidenceList ResidenceListResidenceList `json:"residence_list"`
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type ResidenceListPassthrough map[string]interface{}

type ResidenceListResidenceList int

// A message with Residence List
type ResidenceListResp struct {
	// Echo of the request made.
	EchoReq ResidenceListRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType ResidenceListRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// List of countries for account opening
	ResidenceList []ResidenceListRespResidenceListElem `json:"residence_list,omitempty"`
}

// Echo of the request made.
type ResidenceListRespEchoReq map[string]interface{}

type ResidenceListRespMsgType string

const ResidenceListRespMsgTypeResidenceList ResidenceListRespMsgType = "residence_list"

type ResidenceListRespResidenceListElem struct {
	// Disabled.
	Disabled *string `json:"disabled,omitempty"`

	// Information about identity options available
	Identity *ResidenceListRespResidenceListElemIdentity `json:"identity,omitempty"`

	// IDD code of country
	PhoneIdd interface{} `json:"phone_idd,omitempty"`

	// Selected.
	Selected *string `json:"selected,omitempty"`

	// Country full name
	Text *string `json:"text,omitempty"`

	// Country tax identifier format
	TinFormat []string `json:"tin_format,omitempty"`

	// 2-letter country code
	Value *string `json:"value,omitempty"`
}

// Information about identity options available
type ResidenceListRespResidenceListElemIdentity struct {
	// Identity services configuration
	Services *ResidenceListRespResidenceListElemIdentityServices `json:"services,omitempty"`
}

// Identity services configuration
type ResidenceListRespResidenceListElemIdentityServices struct {
	// IDV configuration
	Idv *ResidenceListRespResidenceListElemIdentityServicesIdv `json:"idv,omitempty"`

	// Onfido configuration
	Onfido *ResidenceListRespResidenceListElemIdentityServicesOnfido `json:"onfido,omitempty"`
}

// IDV configuration
type ResidenceListRespResidenceListElemIdentityServicesIdv struct {
	// Documents supported by the IDV service in this country
	DocumentsSupported ResidenceListRespResidenceListElemIdentityServicesIdvDocumentsSupported `json:"documents_supported,omitempty"`

	// Flag which indicates whether this country has IDV visual samples
	HasVisualSample *ResidenceListRespResidenceListElemIdentityServicesIdvHasVisualSample `json:"has_visual_sample,omitempty"`

	// Flag which indicates whether IDV is available in this country
	IsCountrySupported *ResidenceListRespResidenceListElemIdentityServicesIdvIsCountrySupported `json:"is_country_supported,omitempty"`
}

// Documents supported by the IDV service in this country
type ResidenceListRespResidenceListElemIdentityServicesIdvDocumentsSupported map[string]interface{}

type ResidenceListRespResidenceListElemIdentityServicesIdvHasVisualSample int

type ResidenceListRespResidenceListElemIdentityServicesIdvIsCountrySupported int

// Onfido configuration
type ResidenceListRespResidenceListElemIdentityServicesOnfido struct {
	// Documents supported by the IDV service in this country
	DocumentsSupported ResidenceListRespResidenceListElemIdentityServicesOnfidoDocumentsSupported `json:"documents_supported,omitempty"`

	// Flag which indicates whether Onfido is available in this country
	IsCountrySupported *ResidenceListRespResidenceListElemIdentityServicesOnfidoIsCountrySupported `json:"is_country_supported,omitempty"`
}

// Documents supported by the IDV service in this country
type ResidenceListRespResidenceListElemIdentityServicesOnfidoDocumentsSupported map[string]interface{}

type ResidenceListRespResidenceListElemIdentityServicesOnfidoIsCountrySupported int

// Used for revoking access of particular app.
type RevokeOauthApp struct {
	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough RevokeOauthAppPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// The application ID to revoke.
	RevokeOauthApp int `json:"revoke_oauth_app"`
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type RevokeOauthAppPassthrough map[string]interface{}

// A message with revoking a used application
type RevokeOauthAppResp struct {
	// Echo of the request made.
	EchoReq RevokeOauthAppRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType RevokeOauthAppRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// `1` on success
	RevokeOauthApp *int `json:"revoke_oauth_app,omitempty"`
}

// Echo of the request made.
type RevokeOauthAppRespEchoReq map[string]interface{}

type RevokeOauthAppRespMsgType string

const RevokeOauthAppRespMsgTypeRevokeOauthApp RevokeOauthAppRespMsgType = "revoke_oauth_app"

// Sell a Contract as identified from a previous `portfolio` call.
type Sell struct {
	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough SellPassthrough `json:"passthrough,omitempty"`

	// Minimum price at which to sell the contract, or `0` for 'sell at market'.
	Price float64 `json:"price"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// Pass contract_id received from the `portfolio` call.
	Sell int `json:"sell"`
}

// Sell contracts for multiple accounts simultaneously. Uses the shortcode response
// from `buy_contract_for_multiple_accounts` to identify the contract, and
// authorisation tokens to select which accounts to sell those contracts on. Note
// that only the accounts identified by the tokens will be affected. This will not
// sell the contract on the currently-authorised account unless you include the
// token for the current account.
type SellContractForMultipleAccounts struct {
	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough SellContractForMultipleAccountsPassthrough `json:"passthrough,omitempty"`

	// Minimum price at which to sell the contract, or `0` for 'sell at market'.
	Price float64 `json:"price"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// Must be `1`
	SellContractForMultipleAccounts SellContractForMultipleAccountsSellContractForMultipleAccounts `json:"sell_contract_for_multiple_accounts"`

	// An internal ID used to identify the contract which was originally bought. This
	// is returned from the `buy` and `buy_contract_for_multiple_accounts` calls.
	Shortcode string `json:"shortcode"`

	// Authorisation tokens which select the accounts to sell use for the affected
	// accounts.
	Tokens []string `json:"tokens"`
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type SellContractForMultipleAccountsPassthrough map[string]interface{}

// Confirmation of the sale status for the selected contracts and accounts.
type SellContractForMultipleAccountsResp struct {
	// Echo of the request made.
	EchoReq SellContractForMultipleAccountsRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType SellContractForMultipleAccountsRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// Status information for each affected account.
	SellContractForMultipleAccounts *SellContractForMultipleAccountsRespSellContractForMultipleAccounts `json:"sell_contract_for_multiple_accounts,omitempty"`
}

// Echo of the request made.
type SellContractForMultipleAccountsRespEchoReq map[string]interface{}

type SellContractForMultipleAccountsRespMsgType string

const SellContractForMultipleAccountsRespMsgTypeSellContractForMultipleAccounts SellContractForMultipleAccountsRespMsgType = "sell_contract_for_multiple_accounts"

// Status information for each affected account.
type SellContractForMultipleAccountsRespSellContractForMultipleAccounts struct {
	// The result of sell for multiple accounts request.
	Result []interface{} `json:"result,omitempty"`
}

type SellContractForMultipleAccountsSellContractForMultipleAccounts int

// This call will try to sell any expired contracts and return the number of sold
// contracts.
type SellExpired struct {
	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough SellExpiredPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// Must be `1`
	SellExpired SellExpiredSellExpired `json:"sell_expired"`
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type SellExpiredPassthrough map[string]interface{}

// The result of sell expired contract
type SellExpiredResp struct {
	// Echo of the request made.
	EchoReq SellExpiredRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType SellExpiredRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// Sell expired contract object containing count of contracts sold
	SellExpired *SellExpiredRespSellExpired `json:"sell_expired,omitempty"`
}

// Echo of the request made.
type SellExpiredRespEchoReq map[string]interface{}

type SellExpiredRespMsgType string

const SellExpiredRespMsgTypeSellExpired SellExpiredRespMsgType = "sell_expired"

// Sell expired contract object containing count of contracts sold
type SellExpiredRespSellExpired struct {
	// The number of contracts that has been sold.
	Count *int `json:"count,omitempty"`
}

type SellExpiredSellExpired int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type SellPassthrough map[string]interface{}

// A message with transaction results is received
type SellResp struct {
	// Echo of the request made.
	EchoReq SellRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType SellRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// Receipt for the transaction
	Sell *SellRespSell `json:"sell,omitempty"`
}

// Echo of the request made.
type SellRespEchoReq map[string]interface{}

type SellRespMsgType string

const SellRespMsgTypeSell SellRespMsgType = "sell"

// Receipt for the transaction
type SellRespSell struct {
	// New account balance after completion of the sale
	BalanceAfter *float64 `json:"balance_after,omitempty"`

	// Internal contract identifier for the sold contract
	ContractId *int `json:"contract_id,omitempty"`

	// Internal transaction identifier for the corresponding buy transaction
	ReferenceId *int `json:"reference_id,omitempty"`

	// Actual effected sale price
	SoldFor *float64 `json:"sold_for,omitempty"`

	// Internal transaction identifier for the sale transaction
	TransactionId *int `json:"transaction_id,omitempty"`
}

// Set account currency, this will be default currency for your account i.e
// currency for trading, deposit. Please note that account currency can only be set
// once, and then can never be changed.
type SetAccountCurrency struct {
	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough SetAccountCurrencyPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// Currency of the account. List of supported currencies can be acquired with
	// `payout_currencies` call.
	SetAccountCurrency string `json:"set_account_currency"`
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type SetAccountCurrencyPassthrough map[string]interface{}

// Status of set account currency call
type SetAccountCurrencyResp struct {
	// Echo of the request made.
	EchoReq SetAccountCurrencyRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType SetAccountCurrencyRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// `1`: success, `0`: no change
	SetAccountCurrency *SetAccountCurrencyRespSetAccountCurrency `json:"set_account_currency,omitempty"`
}

// Echo of the request made.
type SetAccountCurrencyRespEchoReq map[string]interface{}

type SetAccountCurrencyRespMsgType string

const SetAccountCurrencyRespMsgTypeSetAccountCurrency SetAccountCurrencyRespMsgType = "set_account_currency"

type SetAccountCurrencyRespSetAccountCurrency int

// This call sets the financial assessment details based on the client's answers to
// analyze whether they possess the experience and knowledge to understand the
// risks involved with binary options trading.
type SetFinancialAssessment struct {
	// [Optional] The anticipated account turnover.
	AccountTurnover *SetFinancialAssessmentAccountTurnover `json:"account_turnover,omitempty"`

	// [Optional] Binary options trading experience.
	BinaryOptionsTradingExperience *SetFinancialAssessmentBinaryOptionsTradingExperience `json:"binary_options_trading_experience,omitempty"`

	// [Optional] Binary options trading frequency.
	BinaryOptionsTradingFrequency *SetFinancialAssessmentBinaryOptionsTradingFrequency `json:"binary_options_trading_frequency,omitempty"`

	// [Optional] CFDs trading experience.
	CfdTradingExperience *SetFinancialAssessmentCfdTradingExperience `json:"cfd_trading_experience,omitempty"`

	// [Optional] CFDs trading frequency.
	CfdTradingFrequency *SetFinancialAssessmentCfdTradingFrequency `json:"cfd_trading_frequency,omitempty"`

	// [Optional] Level of Education.
	EducationLevel *SetFinancialAssessmentEducationLevel `json:"education_level,omitempty"`

	// [Optional] Industry of Employment.
	EmploymentIndustry *SetFinancialAssessmentEmploymentIndustry `json:"employment_industry,omitempty"`

	// [Optional] Employment Status.
	EmploymentStatus *SetFinancialAssessmentEmploymentStatus `json:"employment_status,omitempty"`

	// [Optional] Estimated Net Worth.
	EstimatedWorth *SetFinancialAssessmentEstimatedWorth `json:"estimated_worth,omitempty"`

	// [Optional] The financial information of a client
	FinancialInformation *SetFinancialAssessmentFinancialInformation `json:"financial_information,omitempty"`

	// [Optional] Forex trading experience.
	ForexTradingExperience *SetFinancialAssessmentForexTradingExperience `json:"forex_trading_experience,omitempty"`

	// [Optional] Forex trading frequency.
	ForexTradingFrequency *SetFinancialAssessmentForexTradingFrequency `json:"forex_trading_frequency,omitempty"`

	// [Optional] Income Source.
	IncomeSource *SetFinancialAssessmentIncomeSource `json:"income_source,omitempty"`

	// [Optional] Net Annual Income.
	NetIncome *SetFinancialAssessmentNetIncome `json:"net_income,omitempty"`

	// [Optional] Occupation.
	Occupation *SetFinancialAssessmentOccupation `json:"occupation,omitempty"`

	// [Optional] Trading experience in other financial instruments.
	OtherInstrumentsTradingExperience *SetFinancialAssessmentOtherInstrumentsTradingExperience `json:"other_instruments_trading_experience,omitempty"`

	// [Optional] Trading frequency in other financial instruments.
	OtherInstrumentsTradingFrequency *SetFinancialAssessmentOtherInstrumentsTradingFrequency `json:"other_instruments_trading_frequency,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough SetFinancialAssessmentPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// Must be `1`
	SetFinancialAssessment SetFinancialAssessmentSetFinancialAssessment `json:"set_financial_assessment"`

	// [Optional] Source of wealth.
	SourceOfWealth *SetFinancialAssessmentSourceOfWealth `json:"source_of_wealth,omitempty"`

	// [Optional] The trading experience of a client
	TradingExperience *SetFinancialAssessmentTradingExperience `json:"trading_experience,omitempty"`

	// [Optional] The trading experience of a `maltainvest` client
	TradingExperienceRegulated *SetFinancialAssessmentTradingExperienceRegulated `json:"trading_experience_regulated,omitempty"`
}

type SetFinancialAssessmentAccountTurnover string

const SetFinancialAssessmentAccountTurnoverA100001500000 SetFinancialAssessmentAccountTurnover = "$100,001 - $500,000"
const SetFinancialAssessmentAccountTurnoverA2500050000 SetFinancialAssessmentAccountTurnover = "$25,000 - $50,000"
const SetFinancialAssessmentAccountTurnoverA50001100000 SetFinancialAssessmentAccountTurnover = "$50,001 - $100,000"
const SetFinancialAssessmentAccountTurnoverLessThan25000 SetFinancialAssessmentAccountTurnover = "Less than $25,000"
const SetFinancialAssessmentAccountTurnoverOver500000 SetFinancialAssessmentAccountTurnover = "Over $500,000"

type SetFinancialAssessmentBinaryOptionsTradingExperience string

const SetFinancialAssessmentBinaryOptionsTradingExperienceA01Year SetFinancialAssessmentBinaryOptionsTradingExperience = "0-1 year"
const SetFinancialAssessmentBinaryOptionsTradingExperienceA12Years SetFinancialAssessmentBinaryOptionsTradingExperience = "1-2 years"
const SetFinancialAssessmentBinaryOptionsTradingExperienceOver3Years SetFinancialAssessmentBinaryOptionsTradingExperience = "Over 3 years"

type SetFinancialAssessmentBinaryOptionsTradingFrequency string

const SetFinancialAssessmentBinaryOptionsTradingFrequencyA05TransactionsInThePast12Months SetFinancialAssessmentBinaryOptionsTradingFrequency = "0-5 transactions in the past 12 months"
const SetFinancialAssessmentBinaryOptionsTradingFrequencyA1139TransactionsInThePast12Months SetFinancialAssessmentBinaryOptionsTradingFrequency = "11-39 transactions in the past 12 months"
const SetFinancialAssessmentBinaryOptionsTradingFrequencyA40TransactionsOrMoreInThePast12Months SetFinancialAssessmentBinaryOptionsTradingFrequency = "40 transactions or more in the past 12 months"
const SetFinancialAssessmentBinaryOptionsTradingFrequencyA610TransactionsInThePast12Months SetFinancialAssessmentBinaryOptionsTradingFrequency = "6-10 transactions in the past 12 months"

type SetFinancialAssessmentCfdTradingExperience string

const SetFinancialAssessmentCfdTradingExperienceA01Year SetFinancialAssessmentCfdTradingExperience = "0-1 year"
const SetFinancialAssessmentCfdTradingExperienceA12Years SetFinancialAssessmentCfdTradingExperience = "1-2 years"
const SetFinancialAssessmentCfdTradingExperienceOver3Years SetFinancialAssessmentCfdTradingExperience = "Over 3 years"

type SetFinancialAssessmentCfdTradingFrequency string

const SetFinancialAssessmentCfdTradingFrequencyA05TransactionsInThePast12Months SetFinancialAssessmentCfdTradingFrequency = "0-5 transactions in the past 12 months"
const SetFinancialAssessmentCfdTradingFrequencyA1139TransactionsInThePast12Months SetFinancialAssessmentCfdTradingFrequency = "11-39 transactions in the past 12 months"
const SetFinancialAssessmentCfdTradingFrequencyA40TransactionsOrMoreInThePast12Months SetFinancialAssessmentCfdTradingFrequency = "40 transactions or more in the past 12 months"
const SetFinancialAssessmentCfdTradingFrequencyA610TransactionsInThePast12Months SetFinancialAssessmentCfdTradingFrequency = "6-10 transactions in the past 12 months"

type SetFinancialAssessmentEducationLevel string

const SetFinancialAssessmentEducationLevelPrimary SetFinancialAssessmentEducationLevel = "Primary"
const SetFinancialAssessmentEducationLevelSecondary SetFinancialAssessmentEducationLevel = "Secondary"
const SetFinancialAssessmentEducationLevelTertiary SetFinancialAssessmentEducationLevel = "Tertiary"

type SetFinancialAssessmentEmploymentIndustry string

const SetFinancialAssessmentEmploymentIndustryAgriculture SetFinancialAssessmentEmploymentIndustry = "Agriculture"
const SetFinancialAssessmentEmploymentIndustryConstruction SetFinancialAssessmentEmploymentIndustry = "Construction"
const SetFinancialAssessmentEmploymentIndustryEducation SetFinancialAssessmentEmploymentIndustry = "Education"
const SetFinancialAssessmentEmploymentIndustryFinance SetFinancialAssessmentEmploymentIndustry = "Finance"
const SetFinancialAssessmentEmploymentIndustryFoodServices SetFinancialAssessmentEmploymentIndustry = "Food Services"
const SetFinancialAssessmentEmploymentIndustryHealth SetFinancialAssessmentEmploymentIndustry = "Health"
const SetFinancialAssessmentEmploymentIndustryInformationCommunicationsTechnology SetFinancialAssessmentEmploymentIndustry = "Information & Communications Technology"
const SetFinancialAssessmentEmploymentIndustryLegal SetFinancialAssessmentEmploymentIndustry = "Legal"
const SetFinancialAssessmentEmploymentIndustryManufacturing SetFinancialAssessmentEmploymentIndustry = "Manufacturing"
const SetFinancialAssessmentEmploymentIndustryRealEstate SetFinancialAssessmentEmploymentIndustry = "Real Estate"
const SetFinancialAssessmentEmploymentIndustryScienceEngineering SetFinancialAssessmentEmploymentIndustry = "Science & Engineering"
const SetFinancialAssessmentEmploymentIndustrySocialCultural SetFinancialAssessmentEmploymentIndustry = "Social & Cultural"
const SetFinancialAssessmentEmploymentIndustryTourism SetFinancialAssessmentEmploymentIndustry = "Tourism"
const SetFinancialAssessmentEmploymentIndustryUnemployed SetFinancialAssessmentEmploymentIndustry = "Unemployed"

type SetFinancialAssessmentEmploymentStatus string

const SetFinancialAssessmentEmploymentStatusEmployed SetFinancialAssessmentEmploymentStatus = "Employed"
const SetFinancialAssessmentEmploymentStatusPensioner SetFinancialAssessmentEmploymentStatus = "Pensioner"
const SetFinancialAssessmentEmploymentStatusSelfEmployed SetFinancialAssessmentEmploymentStatus = "Self-Employed"
const SetFinancialAssessmentEmploymentStatusStudent SetFinancialAssessmentEmploymentStatus = "Student"
const SetFinancialAssessmentEmploymentStatusUnemployed SetFinancialAssessmentEmploymentStatus = "Unemployed"

type SetFinancialAssessmentEstimatedWorth string

const SetFinancialAssessmentEstimatedWorthA100000250000 SetFinancialAssessmentEstimatedWorth = "$100,000 - $250,000"
const SetFinancialAssessmentEstimatedWorthA250001500000 SetFinancialAssessmentEstimatedWorth = "$250,001 - $500,000"
const SetFinancialAssessmentEstimatedWorthA5000011000000 SetFinancialAssessmentEstimatedWorth = "$500,001 - $1,000,000"
const SetFinancialAssessmentEstimatedWorthLessThan100000 SetFinancialAssessmentEstimatedWorth = "Less than $100,000"
const SetFinancialAssessmentEstimatedWorthOver1000000 SetFinancialAssessmentEstimatedWorth = "Over $1,000,000"

// [Optional] The financial information of a client
type SetFinancialAssessmentFinancialInformation struct {
	// [Optional] The anticipated account turnover.
	AccountTurnover *SetFinancialAssessmentFinancialInformationAccountTurnover `json:"account_turnover,omitempty"`

	// Level of Education.
	EducationLevel SetFinancialAssessmentFinancialInformationEducationLevel `json:"education_level"`

	// Industry of Employment.
	EmploymentIndustry SetFinancialAssessmentFinancialInformationEmploymentIndustry `json:"employment_industry"`

	// [Optional] Employment Status.
	EmploymentStatus *SetFinancialAssessmentFinancialInformationEmploymentStatus `json:"employment_status,omitempty"`

	// Estimated Net Worth.
	EstimatedWorth SetFinancialAssessmentFinancialInformationEstimatedWorth `json:"estimated_worth"`

	// Income Source.
	IncomeSource SetFinancialAssessmentFinancialInformationIncomeSource `json:"income_source"`

	// Net Annual Income.
	NetIncome SetFinancialAssessmentFinancialInformationNetIncome `json:"net_income"`

	// Occupation.
	Occupation SetFinancialAssessmentFinancialInformationOccupation `json:"occupation"`

	// [Optional] Source of wealth.
	SourceOfWealth *SetFinancialAssessmentFinancialInformationSourceOfWealth `json:"source_of_wealth,omitempty"`
}

type SetFinancialAssessmentFinancialInformationAccountTurnover string

const SetFinancialAssessmentFinancialInformationAccountTurnoverA100001500000 SetFinancialAssessmentFinancialInformationAccountTurnover = "$100,001 - $500,000"
const SetFinancialAssessmentFinancialInformationAccountTurnoverA2500050000 SetFinancialAssessmentFinancialInformationAccountTurnover = "$25,000 - $50,000"
const SetFinancialAssessmentFinancialInformationAccountTurnoverA50001100000 SetFinancialAssessmentFinancialInformationAccountTurnover = "$50,001 - $100,000"
const SetFinancialAssessmentFinancialInformationAccountTurnoverLessThan25000 SetFinancialAssessmentFinancialInformationAccountTurnover = "Less than $25,000"
const SetFinancialAssessmentFinancialInformationAccountTurnoverOver500000 SetFinancialAssessmentFinancialInformationAccountTurnover = "Over $500,000"

type SetFinancialAssessmentFinancialInformationEducationLevel string

const SetFinancialAssessmentFinancialInformationEducationLevelPrimary SetFinancialAssessmentFinancialInformationEducationLevel = "Primary"
const SetFinancialAssessmentFinancialInformationEducationLevelSecondary SetFinancialAssessmentFinancialInformationEducationLevel = "Secondary"
const SetFinancialAssessmentFinancialInformationEducationLevelTertiary SetFinancialAssessmentFinancialInformationEducationLevel = "Tertiary"

type SetFinancialAssessmentFinancialInformationEmploymentIndustry string

const SetFinancialAssessmentFinancialInformationEmploymentIndustryAgriculture SetFinancialAssessmentFinancialInformationEmploymentIndustry = "Agriculture"
const SetFinancialAssessmentFinancialInformationEmploymentIndustryConstruction SetFinancialAssessmentFinancialInformationEmploymentIndustry = "Construction"
const SetFinancialAssessmentFinancialInformationEmploymentIndustryEducation SetFinancialAssessmentFinancialInformationEmploymentIndustry = "Education"
const SetFinancialAssessmentFinancialInformationEmploymentIndustryFinance SetFinancialAssessmentFinancialInformationEmploymentIndustry = "Finance"
const SetFinancialAssessmentFinancialInformationEmploymentIndustryFoodServices SetFinancialAssessmentFinancialInformationEmploymentIndustry = "Food Services"
const SetFinancialAssessmentFinancialInformationEmploymentIndustryHealth SetFinancialAssessmentFinancialInformationEmploymentIndustry = "Health"
const SetFinancialAssessmentFinancialInformationEmploymentIndustryInformationCommunicationsTechnology SetFinancialAssessmentFinancialInformationEmploymentIndustry = "Information & Communications Technology"
const SetFinancialAssessmentFinancialInformationEmploymentIndustryLegal SetFinancialAssessmentFinancialInformationEmploymentIndustry = "Legal"
const SetFinancialAssessmentFinancialInformationEmploymentIndustryManufacturing SetFinancialAssessmentFinancialInformationEmploymentIndustry = "Manufacturing"
const SetFinancialAssessmentFinancialInformationEmploymentIndustryRealEstate SetFinancialAssessmentFinancialInformationEmploymentIndustry = "Real Estate"
const SetFinancialAssessmentFinancialInformationEmploymentIndustryScienceEngineering SetFinancialAssessmentFinancialInformationEmploymentIndustry = "Science & Engineering"
const SetFinancialAssessmentFinancialInformationEmploymentIndustrySocialCultural SetFinancialAssessmentFinancialInformationEmploymentIndustry = "Social & Cultural"
const SetFinancialAssessmentFinancialInformationEmploymentIndustryTourism SetFinancialAssessmentFinancialInformationEmploymentIndustry = "Tourism"
const SetFinancialAssessmentFinancialInformationEmploymentIndustryUnemployed SetFinancialAssessmentFinancialInformationEmploymentIndustry = "Unemployed"

type SetFinancialAssessmentFinancialInformationEmploymentStatus string

const SetFinancialAssessmentFinancialInformationEmploymentStatusEmployed SetFinancialAssessmentFinancialInformationEmploymentStatus = "Employed"
const SetFinancialAssessmentFinancialInformationEmploymentStatusPensioner SetFinancialAssessmentFinancialInformationEmploymentStatus = "Pensioner"
const SetFinancialAssessmentFinancialInformationEmploymentStatusSelfEmployed SetFinancialAssessmentFinancialInformationEmploymentStatus = "Self-Employed"
const SetFinancialAssessmentFinancialInformationEmploymentStatusStudent SetFinancialAssessmentFinancialInformationEmploymentStatus = "Student"
const SetFinancialAssessmentFinancialInformationEmploymentStatusUnemployed SetFinancialAssessmentFinancialInformationEmploymentStatus = "Unemployed"

type SetFinancialAssessmentFinancialInformationEstimatedWorth string

const SetFinancialAssessmentFinancialInformationEstimatedWorthA100000250000 SetFinancialAssessmentFinancialInformationEstimatedWorth = "$100,000 - $250,000"
const SetFinancialAssessmentFinancialInformationEstimatedWorthA250001500000 SetFinancialAssessmentFinancialInformationEstimatedWorth = "$250,001 - $500,000"
const SetFinancialAssessmentFinancialInformationEstimatedWorthA5000011000000 SetFinancialAssessmentFinancialInformationEstimatedWorth = "$500,001 - $1,000,000"
const SetFinancialAssessmentFinancialInformationEstimatedWorthLessThan100000 SetFinancialAssessmentFinancialInformationEstimatedWorth = "Less than $100,000"
const SetFinancialAssessmentFinancialInformationEstimatedWorthOver1000000 SetFinancialAssessmentFinancialInformationEstimatedWorth = "Over $1,000,000"

type SetFinancialAssessmentFinancialInformationIncomeSource string

const SetFinancialAssessmentFinancialInformationIncomeSourceInvestmentsDividends SetFinancialAssessmentFinancialInformationIncomeSource = "Investments & Dividends"
const SetFinancialAssessmentFinancialInformationIncomeSourcePension SetFinancialAssessmentFinancialInformationIncomeSource = "Pension"
const SetFinancialAssessmentFinancialInformationIncomeSourceSalariedEmployee SetFinancialAssessmentFinancialInformationIncomeSource = "Salaried Employee"
const SetFinancialAssessmentFinancialInformationIncomeSourceSavingsInheritance SetFinancialAssessmentFinancialInformationIncomeSource = "Savings & Inheritance"
const SetFinancialAssessmentFinancialInformationIncomeSourceSelfEmployed SetFinancialAssessmentFinancialInformationIncomeSource = "Self-Employed"
const SetFinancialAssessmentFinancialInformationIncomeSourceStateBenefits SetFinancialAssessmentFinancialInformationIncomeSource = "State Benefits"

type SetFinancialAssessmentFinancialInformationNetIncome string

const SetFinancialAssessmentFinancialInformationNetIncomeA100001500000 SetFinancialAssessmentFinancialInformationNetIncome = "$100,001 - $500,000"
const SetFinancialAssessmentFinancialInformationNetIncomeA2500050000 SetFinancialAssessmentFinancialInformationNetIncome = "$25,000 - $50,000"
const SetFinancialAssessmentFinancialInformationNetIncomeA50001100000 SetFinancialAssessmentFinancialInformationNetIncome = "$50,001 - $100,000"
const SetFinancialAssessmentFinancialInformationNetIncomeLessThan25000 SetFinancialAssessmentFinancialInformationNetIncome = "Less than $25,000"
const SetFinancialAssessmentFinancialInformationNetIncomeOver500000 SetFinancialAssessmentFinancialInformationNetIncome = "Over $500,000"

type SetFinancialAssessmentFinancialInformationOccupation string

const SetFinancialAssessmentFinancialInformationOccupationAgriculturalForestryAndFisheryWorkers SetFinancialAssessmentFinancialInformationOccupation = "Agricultural, Forestry and Fishery Workers"
const SetFinancialAssessmentFinancialInformationOccupationArmedForces SetFinancialAssessmentFinancialInformationOccupation = "Armed Forces"
const SetFinancialAssessmentFinancialInformationOccupationChiefExecutivesSeniorOfficialsAndLegislators SetFinancialAssessmentFinancialInformationOccupation = "Chief Executives, Senior Officials and Legislators"
const SetFinancialAssessmentFinancialInformationOccupationCleanersAndHelpers SetFinancialAssessmentFinancialInformationOccupation = "Cleaners and Helpers"
const SetFinancialAssessmentFinancialInformationOccupationClerks SetFinancialAssessmentFinancialInformationOccupation = "Clerks"
const SetFinancialAssessmentFinancialInformationOccupationCraftMetalElectricalAndElectronicsWorkers SetFinancialAssessmentFinancialInformationOccupation = "Craft, Metal, Electrical and Electronics Workers"
const SetFinancialAssessmentFinancialInformationOccupationGovernmentOfficers SetFinancialAssessmentFinancialInformationOccupation = "Government Officers"
const SetFinancialAssessmentFinancialInformationOccupationManagers SetFinancialAssessmentFinancialInformationOccupation = "Managers"
const SetFinancialAssessmentFinancialInformationOccupationMiningConstructionManufacturingAndTransportWorkers SetFinancialAssessmentFinancialInformationOccupation = "Mining, Construction, Manufacturing and Transport Workers"
const SetFinancialAssessmentFinancialInformationOccupationPersonalCareSalesAndServiceWorkers SetFinancialAssessmentFinancialInformationOccupation = "Personal Care, Sales and Service Workers"
const SetFinancialAssessmentFinancialInformationOccupationPlantAndMachineOperatorsAndAssemblers SetFinancialAssessmentFinancialInformationOccupation = "Plant and Machine Operators and Assemblers"
const SetFinancialAssessmentFinancialInformationOccupationProfessionals SetFinancialAssessmentFinancialInformationOccupation = "Professionals"
const SetFinancialAssessmentFinancialInformationOccupationStudents SetFinancialAssessmentFinancialInformationOccupation = "Students"
const SetFinancialAssessmentFinancialInformationOccupationUnemployed SetFinancialAssessmentFinancialInformationOccupation = "Unemployed"

type SetFinancialAssessmentFinancialInformationSourceOfWealth string

const SetFinancialAssessmentFinancialInformationSourceOfWealthAccumulationOfIncomeSavings SetFinancialAssessmentFinancialInformationSourceOfWealth = "Accumulation of Income/Savings"
const SetFinancialAssessmentFinancialInformationSourceOfWealthCashBusiness SetFinancialAssessmentFinancialInformationSourceOfWealth = "Cash Business"
const SetFinancialAssessmentFinancialInformationSourceOfWealthCompanyOwnership SetFinancialAssessmentFinancialInformationSourceOfWealth = "Company Ownership"
const SetFinancialAssessmentFinancialInformationSourceOfWealthDivorceSettlement SetFinancialAssessmentFinancialInformationSourceOfWealth = "Divorce Settlement"
const SetFinancialAssessmentFinancialInformationSourceOfWealthInheritance SetFinancialAssessmentFinancialInformationSourceOfWealth = "Inheritance"
const SetFinancialAssessmentFinancialInformationSourceOfWealthInvestmentIncome SetFinancialAssessmentFinancialInformationSourceOfWealth = "Investment Income"
const SetFinancialAssessmentFinancialInformationSourceOfWealthSaleOfProperty SetFinancialAssessmentFinancialInformationSourceOfWealth = "Sale of Property"

type SetFinancialAssessmentForexTradingExperience string

const SetFinancialAssessmentForexTradingExperienceA01Year SetFinancialAssessmentForexTradingExperience = "0-1 year"
const SetFinancialAssessmentForexTradingExperienceA12Years SetFinancialAssessmentForexTradingExperience = "1-2 years"
const SetFinancialAssessmentForexTradingExperienceOver3Years SetFinancialAssessmentForexTradingExperience = "Over 3 years"

type SetFinancialAssessmentForexTradingFrequency string

const SetFinancialAssessmentForexTradingFrequencyA05TransactionsInThePast12Months SetFinancialAssessmentForexTradingFrequency = "0-5 transactions in the past 12 months"
const SetFinancialAssessmentForexTradingFrequencyA1139TransactionsInThePast12Months SetFinancialAssessmentForexTradingFrequency = "11-39 transactions in the past 12 months"
const SetFinancialAssessmentForexTradingFrequencyA40TransactionsOrMoreInThePast12Months SetFinancialAssessmentForexTradingFrequency = "40 transactions or more in the past 12 months"
const SetFinancialAssessmentForexTradingFrequencyA610TransactionsInThePast12Months SetFinancialAssessmentForexTradingFrequency = "6-10 transactions in the past 12 months"

type SetFinancialAssessmentIncomeSource string

const SetFinancialAssessmentIncomeSourceInvestmentsDividends SetFinancialAssessmentIncomeSource = "Investments & Dividends"
const SetFinancialAssessmentIncomeSourcePension SetFinancialAssessmentIncomeSource = "Pension"
const SetFinancialAssessmentIncomeSourceSalariedEmployee SetFinancialAssessmentIncomeSource = "Salaried Employee"
const SetFinancialAssessmentIncomeSourceSavingsInheritance SetFinancialAssessmentIncomeSource = "Savings & Inheritance"
const SetFinancialAssessmentIncomeSourceSelfEmployed SetFinancialAssessmentIncomeSource = "Self-Employed"
const SetFinancialAssessmentIncomeSourceStateBenefits SetFinancialAssessmentIncomeSource = "State Benefits"

type SetFinancialAssessmentNetIncome string

const SetFinancialAssessmentNetIncomeA100001500000 SetFinancialAssessmentNetIncome = "$100,001 - $500,000"
const SetFinancialAssessmentNetIncomeA2500050000 SetFinancialAssessmentNetIncome = "$25,000 - $50,000"
const SetFinancialAssessmentNetIncomeA50001100000 SetFinancialAssessmentNetIncome = "$50,001 - $100,000"
const SetFinancialAssessmentNetIncomeLessThan25000 SetFinancialAssessmentNetIncome = "Less than $25,000"
const SetFinancialAssessmentNetIncomeOver500000 SetFinancialAssessmentNetIncome = "Over $500,000"

type SetFinancialAssessmentOccupation string

const SetFinancialAssessmentOccupationAgriculturalForestryAndFisheryWorkers SetFinancialAssessmentOccupation = "Agricultural, Forestry and Fishery Workers"
const SetFinancialAssessmentOccupationArmedForces SetFinancialAssessmentOccupation = "Armed Forces"
const SetFinancialAssessmentOccupationChiefExecutivesSeniorOfficialsAndLegislators SetFinancialAssessmentOccupation = "Chief Executives, Senior Officials and Legislators"
const SetFinancialAssessmentOccupationCleanersAndHelpers SetFinancialAssessmentOccupation = "Cleaners and Helpers"
const SetFinancialAssessmentOccupationClerks SetFinancialAssessmentOccupation = "Clerks"
const SetFinancialAssessmentOccupationCraftMetalElectricalAndElectronicsWorkers SetFinancialAssessmentOccupation = "Craft, Metal, Electrical and Electronics Workers"
const SetFinancialAssessmentOccupationGovernmentOfficers SetFinancialAssessmentOccupation = "Government Officers"
const SetFinancialAssessmentOccupationManagers SetFinancialAssessmentOccupation = "Managers"
const SetFinancialAssessmentOccupationMiningConstructionManufacturingAndTransportWorkers SetFinancialAssessmentOccupation = "Mining, Construction, Manufacturing and Transport Workers"
const SetFinancialAssessmentOccupationPersonalCareSalesAndServiceWorkers SetFinancialAssessmentOccupation = "Personal Care, Sales and Service Workers"
const SetFinancialAssessmentOccupationPlantAndMachineOperatorsAndAssemblers SetFinancialAssessmentOccupation = "Plant and Machine Operators and Assemblers"
const SetFinancialAssessmentOccupationProfessionals SetFinancialAssessmentOccupation = "Professionals"
const SetFinancialAssessmentOccupationStudents SetFinancialAssessmentOccupation = "Students"
const SetFinancialAssessmentOccupationUnemployed SetFinancialAssessmentOccupation = "Unemployed"

type SetFinancialAssessmentOtherInstrumentsTradingExperience string

const SetFinancialAssessmentOtherInstrumentsTradingExperienceA01Year SetFinancialAssessmentOtherInstrumentsTradingExperience = "0-1 year"
const SetFinancialAssessmentOtherInstrumentsTradingExperienceA12Years SetFinancialAssessmentOtherInstrumentsTradingExperience = "1-2 years"
const SetFinancialAssessmentOtherInstrumentsTradingExperienceOver3Years SetFinancialAssessmentOtherInstrumentsTradingExperience = "Over 3 years"

type SetFinancialAssessmentOtherInstrumentsTradingFrequency string

const SetFinancialAssessmentOtherInstrumentsTradingFrequencyA05TransactionsInThePast12Months SetFinancialAssessmentOtherInstrumentsTradingFrequency = "0-5 transactions in the past 12 months"
const SetFinancialAssessmentOtherInstrumentsTradingFrequencyA1139TransactionsInThePast12Months SetFinancialAssessmentOtherInstrumentsTradingFrequency = "11-39 transactions in the past 12 months"
const SetFinancialAssessmentOtherInstrumentsTradingFrequencyA40TransactionsOrMoreInThePast12Months SetFinancialAssessmentOtherInstrumentsTradingFrequency = "40 transactions or more in the past 12 months"
const SetFinancialAssessmentOtherInstrumentsTradingFrequencyA610TransactionsInThePast12Months SetFinancialAssessmentOtherInstrumentsTradingFrequency = "6-10 transactions in the past 12 months"

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type SetFinancialAssessmentPassthrough map[string]interface{}

// Set Financial Assessment Receive
type SetFinancialAssessmentResp struct {
	// Echo of the request made.
	EchoReq SetFinancialAssessmentRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType SetFinancialAssessmentRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// The financial assessment score assigned to the submitted financial assessment
	SetFinancialAssessment *SetFinancialAssessmentRespSetFinancialAssessment `json:"set_financial_assessment,omitempty"`
}

// Echo of the request made.
type SetFinancialAssessmentRespEchoReq map[string]interface{}

type SetFinancialAssessmentRespMsgType string

const SetFinancialAssessmentRespMsgTypeSetFinancialAssessment SetFinancialAssessmentRespMsgType = "set_financial_assessment"

// The financial assessment score assigned to the submitted financial assessment
type SetFinancialAssessmentRespSetFinancialAssessment struct {
	// CFD score based on answers
	CfdScore *int `json:"cfd_score,omitempty"`

	// Financial information score based on answers
	FinancialInformationScore *int `json:"financial_information_score,omitempty"`

	// Financial Assessment score based on answers
	TotalScore *int `json:"total_score,omitempty"`

	// Trading experience score based on answers
	TradingScore *int `json:"trading_score,omitempty"`
}

type SetFinancialAssessmentSetFinancialAssessment int

type SetFinancialAssessmentSourceOfWealth string

const SetFinancialAssessmentSourceOfWealthAccumulationOfIncomeSavings SetFinancialAssessmentSourceOfWealth = "Accumulation of Income/Savings"
const SetFinancialAssessmentSourceOfWealthCashBusiness SetFinancialAssessmentSourceOfWealth = "Cash Business"
const SetFinancialAssessmentSourceOfWealthCompanyOwnership SetFinancialAssessmentSourceOfWealth = "Company Ownership"
const SetFinancialAssessmentSourceOfWealthDivorceSettlement SetFinancialAssessmentSourceOfWealth = "Divorce Settlement"
const SetFinancialAssessmentSourceOfWealthInheritance SetFinancialAssessmentSourceOfWealth = "Inheritance"
const SetFinancialAssessmentSourceOfWealthInvestmentIncome SetFinancialAssessmentSourceOfWealth = "Investment Income"
const SetFinancialAssessmentSourceOfWealthSaleOfProperty SetFinancialAssessmentSourceOfWealth = "Sale of Property"

// [Optional] The trading experience of a client
type SetFinancialAssessmentTradingExperience struct {
	// [Optional] Binary options trading experience.
	BinaryOptionsTradingExperience *SetFinancialAssessmentTradingExperienceBinaryOptionsTradingExperience `json:"binary_options_trading_experience,omitempty"`

	// [Optional] Binary options trading frequency.
	BinaryOptionsTradingFrequency *SetFinancialAssessmentTradingExperienceBinaryOptionsTradingFrequency `json:"binary_options_trading_frequency,omitempty"`

	// [Optional] CFDs trading experience.
	CfdTradingExperience *SetFinancialAssessmentTradingExperienceCfdTradingExperience `json:"cfd_trading_experience,omitempty"`

	// [Optional] CFDs trading frequency.
	CfdTradingFrequency *SetFinancialAssessmentTradingExperienceCfdTradingFrequency `json:"cfd_trading_frequency,omitempty"`

	// [Optional] Forex trading experience.
	ForexTradingExperience *SetFinancialAssessmentTradingExperienceForexTradingExperience `json:"forex_trading_experience,omitempty"`

	// [Optional] Forex trading frequency.
	ForexTradingFrequency *SetFinancialAssessmentTradingExperienceForexTradingFrequency `json:"forex_trading_frequency,omitempty"`

	// [Optional] Trading experience in other financial instruments.
	OtherInstrumentsTradingExperience *SetFinancialAssessmentTradingExperienceOtherInstrumentsTradingExperience `json:"other_instruments_trading_experience,omitempty"`

	// [Optional] Trading frequency in other financial instruments.
	OtherInstrumentsTradingFrequency *SetFinancialAssessmentTradingExperienceOtherInstrumentsTradingFrequency `json:"other_instruments_trading_frequency,omitempty"`
}

type SetFinancialAssessmentTradingExperienceBinaryOptionsTradingExperience string

const SetFinancialAssessmentTradingExperienceBinaryOptionsTradingExperienceA01Year SetFinancialAssessmentTradingExperienceBinaryOptionsTradingExperience = "0-1 year"
const SetFinancialAssessmentTradingExperienceBinaryOptionsTradingExperienceA12Years SetFinancialAssessmentTradingExperienceBinaryOptionsTradingExperience = "1-2 years"
const SetFinancialAssessmentTradingExperienceBinaryOptionsTradingExperienceOver3Years SetFinancialAssessmentTradingExperienceBinaryOptionsTradingExperience = "Over 3 years"

type SetFinancialAssessmentTradingExperienceBinaryOptionsTradingFrequency string

const SetFinancialAssessmentTradingExperienceBinaryOptionsTradingFrequencyA05TransactionsInThePast12Months SetFinancialAssessmentTradingExperienceBinaryOptionsTradingFrequency = "0-5 transactions in the past 12 months"
const SetFinancialAssessmentTradingExperienceBinaryOptionsTradingFrequencyA1139TransactionsInThePast12Months SetFinancialAssessmentTradingExperienceBinaryOptionsTradingFrequency = "11-39 transactions in the past 12 months"
const SetFinancialAssessmentTradingExperienceBinaryOptionsTradingFrequencyA40TransactionsOrMoreInThePast12Months SetFinancialAssessmentTradingExperienceBinaryOptionsTradingFrequency = "40 transactions or more in the past 12 months"
const SetFinancialAssessmentTradingExperienceBinaryOptionsTradingFrequencyA610TransactionsInThePast12Months SetFinancialAssessmentTradingExperienceBinaryOptionsTradingFrequency = "6-10 transactions in the past 12 months"

type SetFinancialAssessmentTradingExperienceCfdTradingExperience string

const SetFinancialAssessmentTradingExperienceCfdTradingExperienceA01Year SetFinancialAssessmentTradingExperienceCfdTradingExperience = "0-1 year"
const SetFinancialAssessmentTradingExperienceCfdTradingExperienceA12Years SetFinancialAssessmentTradingExperienceCfdTradingExperience = "1-2 years"
const SetFinancialAssessmentTradingExperienceCfdTradingExperienceOver3Years SetFinancialAssessmentTradingExperienceCfdTradingExperience = "Over 3 years"

type SetFinancialAssessmentTradingExperienceCfdTradingFrequency string

const SetFinancialAssessmentTradingExperienceCfdTradingFrequencyA05TransactionsInThePast12Months SetFinancialAssessmentTradingExperienceCfdTradingFrequency = "0-5 transactions in the past 12 months"
const SetFinancialAssessmentTradingExperienceCfdTradingFrequencyA1139TransactionsInThePast12Months SetFinancialAssessmentTradingExperienceCfdTradingFrequency = "11-39 transactions in the past 12 months"
const SetFinancialAssessmentTradingExperienceCfdTradingFrequencyA40TransactionsOrMoreInThePast12Months SetFinancialAssessmentTradingExperienceCfdTradingFrequency = "40 transactions or more in the past 12 months"
const SetFinancialAssessmentTradingExperienceCfdTradingFrequencyA610TransactionsInThePast12Months SetFinancialAssessmentTradingExperienceCfdTradingFrequency = "6-10 transactions in the past 12 months"

type SetFinancialAssessmentTradingExperienceForexTradingExperience string

const SetFinancialAssessmentTradingExperienceForexTradingExperienceA01Year SetFinancialAssessmentTradingExperienceForexTradingExperience = "0-1 year"
const SetFinancialAssessmentTradingExperienceForexTradingExperienceA12Years SetFinancialAssessmentTradingExperienceForexTradingExperience = "1-2 years"
const SetFinancialAssessmentTradingExperienceForexTradingExperienceOver3Years SetFinancialAssessmentTradingExperienceForexTradingExperience = "Over 3 years"

type SetFinancialAssessmentTradingExperienceForexTradingFrequency string

const SetFinancialAssessmentTradingExperienceForexTradingFrequencyA05TransactionsInThePast12Months SetFinancialAssessmentTradingExperienceForexTradingFrequency = "0-5 transactions in the past 12 months"
const SetFinancialAssessmentTradingExperienceForexTradingFrequencyA1139TransactionsInThePast12Months SetFinancialAssessmentTradingExperienceForexTradingFrequency = "11-39 transactions in the past 12 months"
const SetFinancialAssessmentTradingExperienceForexTradingFrequencyA40TransactionsOrMoreInThePast12Months SetFinancialAssessmentTradingExperienceForexTradingFrequency = "40 transactions or more in the past 12 months"
const SetFinancialAssessmentTradingExperienceForexTradingFrequencyA610TransactionsInThePast12Months SetFinancialAssessmentTradingExperienceForexTradingFrequency = "6-10 transactions in the past 12 months"

type SetFinancialAssessmentTradingExperienceOtherInstrumentsTradingExperience string

const SetFinancialAssessmentTradingExperienceOtherInstrumentsTradingExperienceA01Year SetFinancialAssessmentTradingExperienceOtherInstrumentsTradingExperience = "0-1 year"
const SetFinancialAssessmentTradingExperienceOtherInstrumentsTradingExperienceA12Years SetFinancialAssessmentTradingExperienceOtherInstrumentsTradingExperience = "1-2 years"
const SetFinancialAssessmentTradingExperienceOtherInstrumentsTradingExperienceOver3Years SetFinancialAssessmentTradingExperienceOtherInstrumentsTradingExperience = "Over 3 years"

type SetFinancialAssessmentTradingExperienceOtherInstrumentsTradingFrequency string

const SetFinancialAssessmentTradingExperienceOtherInstrumentsTradingFrequencyA05TransactionsInThePast12Months SetFinancialAssessmentTradingExperienceOtherInstrumentsTradingFrequency = "0-5 transactions in the past 12 months"
const SetFinancialAssessmentTradingExperienceOtherInstrumentsTradingFrequencyA1139TransactionsInThePast12Months SetFinancialAssessmentTradingExperienceOtherInstrumentsTradingFrequency = "11-39 transactions in the past 12 months"
const SetFinancialAssessmentTradingExperienceOtherInstrumentsTradingFrequencyA40TransactionsOrMoreInThePast12Months SetFinancialAssessmentTradingExperienceOtherInstrumentsTradingFrequency = "40 transactions or more in the past 12 months"
const SetFinancialAssessmentTradingExperienceOtherInstrumentsTradingFrequencyA610TransactionsInThePast12Months SetFinancialAssessmentTradingExperienceOtherInstrumentsTradingFrequency = "6-10 transactions in the past 12 months"

// [Optional] The trading experience of a `maltainvest` client
type SetFinancialAssessmentTradingExperienceRegulated struct {
	// How much experience do you have in CFD trading?
	CfdExperience SetFinancialAssessmentTradingExperienceRegulatedCfdExperience `json:"cfd_experience"`

	// How many CFD trades have you placed in the past 12 months?
	CfdFrequency SetFinancialAssessmentTradingExperienceRegulatedCfdFrequency `json:"cfd_frequency"`

	// In your understanding, CFD trading allows you to:
	CfdTradingDefinition SetFinancialAssessmentTradingExperienceRegulatedCfdTradingDefinition `json:"cfd_trading_definition"`

	// How does leverage affect CFD trading?
	LeverageImpactTrading SetFinancialAssessmentTradingExperienceRegulatedLeverageImpactTrading `json:"leverage_impact_trading"`

	// Leverage trading is high-risk, so it's a good idea to use risk management
	// features such as stop loss. Stop loss allows you to
	LeverageTradingHighRiskStopLoss SetFinancialAssessmentTradingExperienceRegulatedLeverageTradingHighRiskStopLoss `json:"leverage_trading_high_risk_stop_loss"`

	// When would you be required to pay an initial margin?
	RequiredInitialMargin SetFinancialAssessmentTradingExperienceRegulatedRequiredInitialMargin `json:"required_initial_margin"`

	// Do you understand that you could potentially lose 100% of the money you use to
	// trade?
	RiskTolerance SetFinancialAssessmentTradingExperienceRegulatedRiskTolerance `json:"risk_tolerance"`

	// How much knowledge and experience do you have in relation to online trading?
	SourceOfExperience SetFinancialAssessmentTradingExperienceRegulatedSourceOfExperience `json:"source_of_experience"`

	// How much experience do you have with other financial instruments?
	TradingExperienceFinancialInstruments SetFinancialAssessmentTradingExperienceRegulatedTradingExperienceFinancialInstruments `json:"trading_experience_financial_instruments"`

	// How many trades have you placed with other financial instruments in the past 12
	// months?
	TradingFrequencyFinancialInstruments SetFinancialAssessmentTradingExperienceRegulatedTradingFrequencyFinancialInstruments `json:"trading_frequency_financial_instruments"`
}

type SetFinancialAssessmentTradingExperienceRegulatedCfdExperience string

const SetFinancialAssessmentTradingExperienceRegulatedCfdExperienceA12Years SetFinancialAssessmentTradingExperienceRegulatedCfdExperience = "1 - 2 years"
const SetFinancialAssessmentTradingExperienceRegulatedCfdExperienceLessThanAYear SetFinancialAssessmentTradingExperienceRegulatedCfdExperience = "Less than a year"
const SetFinancialAssessmentTradingExperienceRegulatedCfdExperienceNoExperience SetFinancialAssessmentTradingExperienceRegulatedCfdExperience = "No experience"
const SetFinancialAssessmentTradingExperienceRegulatedCfdExperienceOver3Years SetFinancialAssessmentTradingExperienceRegulatedCfdExperience = "Over 3 years"

type SetFinancialAssessmentTradingExperienceRegulatedCfdFrequency string

const SetFinancialAssessmentTradingExperienceRegulatedCfdFrequencyA1139TransactionsInThePast12Months SetFinancialAssessmentTradingExperienceRegulatedCfdFrequency = "11 - 39 transactions in the past 12 months"
const SetFinancialAssessmentTradingExperienceRegulatedCfdFrequencyA15TransactionsInThePast12Months SetFinancialAssessmentTradingExperienceRegulatedCfdFrequency = "1 - 5 transactions in the past 12 months"
const SetFinancialAssessmentTradingExperienceRegulatedCfdFrequencyA40TransactionsOrMoreInThePast12Months SetFinancialAssessmentTradingExperienceRegulatedCfdFrequency = "40 transactions or more in the past 12 months"
const SetFinancialAssessmentTradingExperienceRegulatedCfdFrequencyA610TransactionsInThePast12Months SetFinancialAssessmentTradingExperienceRegulatedCfdFrequency = "6 - 10 transactions in the past 12 months"
const SetFinancialAssessmentTradingExperienceRegulatedCfdFrequencyNoTransactionsInThePast12Months SetFinancialAssessmentTradingExperienceRegulatedCfdFrequency = "No transactions in the past 12 months"

type SetFinancialAssessmentTradingExperienceRegulatedCfdTradingDefinition string

const SetFinancialAssessmentTradingExperienceRegulatedCfdTradingDefinitionMakeALongTermInvestment SetFinancialAssessmentTradingExperienceRegulatedCfdTradingDefinition = "Make a long-term investment."
const SetFinancialAssessmentTradingExperienceRegulatedCfdTradingDefinitionPlaceABetOnThePriceMovement SetFinancialAssessmentTradingExperienceRegulatedCfdTradingDefinition = "Place a bet on the price movement."
const SetFinancialAssessmentTradingExperienceRegulatedCfdTradingDefinitionPurchaseSharesOfACompanyOrPhysicalCommodities SetFinancialAssessmentTradingExperienceRegulatedCfdTradingDefinition = "Purchase shares of a company or physical commodities."
const SetFinancialAssessmentTradingExperienceRegulatedCfdTradingDefinitionSpeculateOnThePriceMovement SetFinancialAssessmentTradingExperienceRegulatedCfdTradingDefinition = "Speculate on the price movement."

type SetFinancialAssessmentTradingExperienceRegulatedLeverageImpactTrading string

const SetFinancialAssessmentTradingExperienceRegulatedLeverageImpactTradingLeverageGuaranteesProfits SetFinancialAssessmentTradingExperienceRegulatedLeverageImpactTrading = "Leverage guarantees profits."
const SetFinancialAssessmentTradingExperienceRegulatedLeverageImpactTradingLeverageIsARiskMitigationTechnique SetFinancialAssessmentTradingExperienceRegulatedLeverageImpactTrading = "Leverage is a risk mitigation technique."
const SetFinancialAssessmentTradingExperienceRegulatedLeverageImpactTradingLeverageLetsYouOpenLargerPositionsForAFractionOfTheTradeSValue SetFinancialAssessmentTradingExperienceRegulatedLeverageImpactTrading = "Leverage lets you open larger positions for a fraction of the trade's value."
const SetFinancialAssessmentTradingExperienceRegulatedLeverageImpactTradingLeveragePreventsYouFromOpeningLargePositions SetFinancialAssessmentTradingExperienceRegulatedLeverageImpactTrading = "Leverage prevents you from opening large positions."

type SetFinancialAssessmentTradingExperienceRegulatedLeverageTradingHighRiskStopLoss string

const SetFinancialAssessmentTradingExperienceRegulatedLeverageTradingHighRiskStopLossCancelYourTradeAtAnyTimeWithinAChosenTimeframe SetFinancialAssessmentTradingExperienceRegulatedLeverageTradingHighRiskStopLoss = "Cancel your trade at any time within a chosen timeframe."
const SetFinancialAssessmentTradingExperienceRegulatedLeverageTradingHighRiskStopLossCloseYourTradeAutomaticallyWhenTheLossIsMoreThanOrEqualToASpecificAmount SetFinancialAssessmentTradingExperienceRegulatedLeverageTradingHighRiskStopLoss = "Close your trade automatically when the loss is more than or equal to a specific amount."
const SetFinancialAssessmentTradingExperienceRegulatedLeverageTradingHighRiskStopLossCloseYourTradeAutomaticallyWhenTheProfitIsMoreThanOrEqualToASpecificAmount SetFinancialAssessmentTradingExperienceRegulatedLeverageTradingHighRiskStopLoss = "Close your trade automatically when the profit is more than or equal to a specific amount."
const SetFinancialAssessmentTradingExperienceRegulatedLeverageTradingHighRiskStopLossMakeAGuaranteedProfitOnYourTrade SetFinancialAssessmentTradingExperienceRegulatedLeverageTradingHighRiskStopLoss = "Make a guaranteed profit on your trade."

type SetFinancialAssessmentTradingExperienceRegulatedRequiredInitialMargin string

const SetFinancialAssessmentTradingExperienceRegulatedRequiredInitialMarginAllOfTheAbove SetFinancialAssessmentTradingExperienceRegulatedRequiredInitialMargin = "All of the above."
const SetFinancialAssessmentTradingExperienceRegulatedRequiredInitialMarginWhenBuyingSharesOfACompany SetFinancialAssessmentTradingExperienceRegulatedRequiredInitialMargin = "When buying shares of a company."
const SetFinancialAssessmentTradingExperienceRegulatedRequiredInitialMarginWhenOpeningALeveragedCFDTrade SetFinancialAssessmentTradingExperienceRegulatedRequiredInitialMargin = "When opening a Leveraged CFD trade."
const SetFinancialAssessmentTradingExperienceRegulatedRequiredInitialMarginWhenTradingMultipliers SetFinancialAssessmentTradingExperienceRegulatedRequiredInitialMargin = "When trading Multipliers."

type SetFinancialAssessmentTradingExperienceRegulatedRiskTolerance string

const SetFinancialAssessmentTradingExperienceRegulatedRiskToleranceNo SetFinancialAssessmentTradingExperienceRegulatedRiskTolerance = "No"
const SetFinancialAssessmentTradingExperienceRegulatedRiskToleranceYes SetFinancialAssessmentTradingExperienceRegulatedRiskTolerance = "Yes"

type SetFinancialAssessmentTradingExperienceRegulatedSourceOfExperience string

const SetFinancialAssessmentTradingExperienceRegulatedSourceOfExperienceIHaveAnAcademicDegreeProfessionalCertificationAndOrWorkExperience SetFinancialAssessmentTradingExperienceRegulatedSourceOfExperience = "I have an academic degree, professional certification, and/or work experience."
const SetFinancialAssessmentTradingExperienceRegulatedSourceOfExperienceIHaveAttendedSeminarsTrainingAndOrWorkshops SetFinancialAssessmentTradingExperienceRegulatedSourceOfExperience = "I have attended seminars, training, and/or workshops."
const SetFinancialAssessmentTradingExperienceRegulatedSourceOfExperienceIHaveLittleExperience SetFinancialAssessmentTradingExperienceRegulatedSourceOfExperience = "I have little experience."
const SetFinancialAssessmentTradingExperienceRegulatedSourceOfExperienceIHaveNoKnowledge SetFinancialAssessmentTradingExperienceRegulatedSourceOfExperience = "I have no knowledge."
const SetFinancialAssessmentTradingExperienceRegulatedSourceOfExperienceITradeForexCFDsAndOtherComplexFinancialInstruments SetFinancialAssessmentTradingExperienceRegulatedSourceOfExperience = "I trade forex CFDs and other complex financial instruments."

type SetFinancialAssessmentTradingExperienceRegulatedTradingExperienceFinancialInstruments string

const SetFinancialAssessmentTradingExperienceRegulatedTradingExperienceFinancialInstrumentsA12Years SetFinancialAssessmentTradingExperienceRegulatedTradingExperienceFinancialInstruments = "1 - 2 years"
const SetFinancialAssessmentTradingExperienceRegulatedTradingExperienceFinancialInstrumentsLessThanAYear SetFinancialAssessmentTradingExperienceRegulatedTradingExperienceFinancialInstruments = "Less than a year"
const SetFinancialAssessmentTradingExperienceRegulatedTradingExperienceFinancialInstrumentsNoExperience SetFinancialAssessmentTradingExperienceRegulatedTradingExperienceFinancialInstruments = "No experience"
const SetFinancialAssessmentTradingExperienceRegulatedTradingExperienceFinancialInstrumentsOver3Years SetFinancialAssessmentTradingExperienceRegulatedTradingExperienceFinancialInstruments = "Over 3 years"

type SetFinancialAssessmentTradingExperienceRegulatedTradingFrequencyFinancialInstruments string

const SetFinancialAssessmentTradingExperienceRegulatedTradingFrequencyFinancialInstrumentsA1139TransactionsInThePast12Months SetFinancialAssessmentTradingExperienceRegulatedTradingFrequencyFinancialInstruments = "11 - 39 transactions in the past 12 months"
const SetFinancialAssessmentTradingExperienceRegulatedTradingFrequencyFinancialInstrumentsA15TransactionsInThePast12Months SetFinancialAssessmentTradingExperienceRegulatedTradingFrequencyFinancialInstruments = "1 - 5 transactions in the past 12 months"
const SetFinancialAssessmentTradingExperienceRegulatedTradingFrequencyFinancialInstrumentsA40TransactionsOrMoreInThePast12Months SetFinancialAssessmentTradingExperienceRegulatedTradingFrequencyFinancialInstruments = "40 transactions or more in the past 12 months"
const SetFinancialAssessmentTradingExperienceRegulatedTradingFrequencyFinancialInstrumentsA610TransactionsInThePast12Months SetFinancialAssessmentTradingExperienceRegulatedTradingFrequencyFinancialInstruments = "6 - 10 transactions in the past 12 months"
const SetFinancialAssessmentTradingExperienceRegulatedTradingFrequencyFinancialInstrumentsNoTransactionsInThePast12Months SetFinancialAssessmentTradingExperienceRegulatedTradingFrequencyFinancialInstruments = "No transactions in the past 12 months"

// Set Self-Exclusion (this call should be used in conjunction with
// `get_self_exclusion`)
type SetSelfExclusion struct {
	// [Optional] Exclude me from the website (for a minimum of 6 months, up to a
	// maximum of 5 years). Note: uplifting this self-exclusion may require contacting
	// the company.
	ExcludeUntil interface{} `json:"exclude_until,omitempty"`

	// [Optional] 7-day limit on deposits.
	Max30DayDeposit interface{} `json:"max_30day_deposit,omitempty"`

	// [Optional] 30-day limit on losses.
	Max30DayLosses interface{} `json:"max_30day_losses,omitempty"`

	// [Optional] 30-day turnover limit.
	Max30DayTurnover interface{} `json:"max_30day_turnover,omitempty"`

	// [Optional] 7-day limit on deposits.
	Max7DayDeposit interface{} `json:"max_7day_deposit,omitempty"`

	// [Optional] 7-day limit on losses.
	Max7DayLosses interface{} `json:"max_7day_losses,omitempty"`

	// [Optional] 7-day turnover limit.
	Max7DayTurnover interface{} `json:"max_7day_turnover,omitempty"`

	// [Optional] Maximum account cash balance.
	MaxBalance interface{} `json:"max_balance,omitempty"`

	// [Optional] Daily deposit limit.
	MaxDeposit interface{} `json:"max_deposit,omitempty"`

	// [Optional] Daily limit on losses.
	MaxLosses interface{} `json:"max_losses,omitempty"`

	// [Optional] Maximum number of open positions.
	MaxOpenBets interface{} `json:"max_open_bets,omitempty"`

	// [Optional] Daily turnover limit.
	MaxTurnover interface{} `json:"max_turnover,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough SetSelfExclusionPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// [Optional] Session duration limit, in minutes.
	SessionDurationLimit interface{} `json:"session_duration_limit,omitempty"`

	// Must be `1`
	SetSelfExclusion SetSelfExclusionSetSelfExclusion `json:"set_self_exclusion"`

	// [Optional] Exclude me from the website (for up to 6 weeks). Requires time in
	// epoch format. Note: unlike `exclude_until`, this self-exclusion will be lifted
	// automatically at the expiry of the timeout period.
	TimeoutUntil interface{} `json:"timeout_until,omitempty"`
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type SetSelfExclusionPassthrough map[string]interface{}

// A message with User Self-Exclusion
type SetSelfExclusionResp struct {
	// Echo of the request made.
	EchoReq SetSelfExclusionRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType SetSelfExclusionRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// `1` on success
	SetSelfExclusion *int `json:"set_self_exclusion,omitempty"`
}

// Echo of the request made.
type SetSelfExclusionRespEchoReq map[string]interface{}

type SetSelfExclusionRespMsgType string

const SetSelfExclusionRespMsgTypeSetSelfExclusion SetSelfExclusionRespMsgType = "set_self_exclusion"

type SetSelfExclusionSetSelfExclusion int

// Set User Settings (this call should be used in conjunction with `get_settings`)
type SetSettings struct {
	// [Optional] Purpose and reason for requesting the account opening. Only
	// applicable for real money account. Required for clients that have not set it
	// yet. Can only be set once.
	AccountOpeningReason *SetSettingsAccountOpeningReason `json:"account_opening_reason,omitempty"`

	// [Optional] Note: not applicable for virtual account. Required field for real
	// money account.
	AddressCity *string `json:"address_city,omitempty"`

	// [Optional] Note: not applicable for virtual account. Required field for real
	// money account.
	AddressLine1 *string `json:"address_line_1,omitempty"`

	// [Optional] Note: not applicable for virtual account. Optional field for real
	// money account.
	AddressLine2 interface{} `json:"address_line_2,omitempty"`

	// [Optional] Note: not applicable for virtual account. Optional field for real
	// money account.
	AddressPostcode *string `json:"address_postcode,omitempty"`

	// [Optional] Note: not applicable for virtual account. Optional field for real
	// money account.
	AddressState *string `json:"address_state,omitempty"`

	// [Optional] Boolean value 1 or 0, indicating permission to allow others to
	// follow your trades. Note: not applicable for Virtual account. Only allow for
	// real money account.
	AllowCopiers *SetSettingsAllowCopiers `json:"allow_copiers,omitempty"`

	// [Optional] Country of legal citizenship, 2-letter country code.
	Citizen interface{} `json:"citizen,omitempty"`

	// [Optional] Date of birth format: yyyy-mm-dd (can only be changed on
	// unauthenticated svg accounts).
	DateOfBirth *string `json:"date_of_birth,omitempty"`

	// Boolean value 1 or 0, indicating if user email belong to dxtrade exception
	// list.
	DxtradeUserException *SetSettingsDxtradeUserException `json:"dxtrade_user_exception,omitempty"`

	// [Optional] Boolean value 1 or 0, indicating permission to use email address for
	// any contact which may include marketing
	EmailConsent *SetSettingsEmailConsent `json:"email_consent,omitempty"`

	// [Optional] Employment Status.
	EmploymentStatus *SetSettingsEmploymentStatus `json:"employment_status,omitempty"`

	// [Optional] Enable or disable one or multiple features.
	FeatureFlag *SetSettingsFeatureFlag `json:"feature_flag,omitempty"`

	// [Optional] Within 2-50 characters, use only letters, spaces, hyphens,
	// full-stops or apostrophes (can only be changed on unauthenticated svg
	// accounts).
	FirstName *string `json:"first_name,omitempty"`

	// [Optional] Within 2-50 characters, use only letters, spaces, hyphens,
	// full-stops or apostrophes (can only be changed on unauthenticated svg
	// accounts).
	LastName *string `json:"last_name,omitempty"`

	// [Optional] Indicates client's self-declaration of not being a PEP/RCA
	// (Politically Exposed Person/Relatives and Close Associates). Effective for real
	// accounts only.
	NonPepDeclaration *SetSettingsNonPepDeclaration `json:"non_pep_declaration,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough SetSettingsPassthrough `json:"passthrough,omitempty"`

	// [Optional] Note: not applicable for virtual account. Starting with `+` followed
	// by 9-35 digits, hyphens or space.
	Phone interface{} `json:"phone,omitempty"`

	// [Optional] Place of birth, 2-letter country code.
	PlaceOfBirth *string `json:"place_of_birth,omitempty"`

	// [Optional] User's preferred language, ISO standard language code
	PreferredLanguage interface{} `json:"preferred_language,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// [Optional] Required when client wants to be treated as professional. Applicable
	// for financial accounts only.
	RequestProfessionalStatus *SetSettingsRequestProfessionalStatus `json:"request_professional_status,omitempty"`

	// [Optional] 2-letter country code. Note: not applicable for real money account.
	// Only allow for Virtual account without residence set.
	Residence interface{} `json:"residence,omitempty"`

	// [Optional] Accept any value in enum list (can only be changed on
	// unauthenticated svg accounts).
	Salutation *SetSettingsSalutation `json:"salutation,omitempty"`

	// [Optional] Answer to secret question, within 4-50 characters. Required for new
	// account and existing client details will be used if client opens another
	// account.
	SecretAnswer *string `json:"secret_answer,omitempty"`

	// [Optional] Accept any value in enum list. Required for new account and existing
	// client details will be used if client opens another account.
	SecretQuestion *SetSettingsSecretQuestion `json:"secret_question,omitempty"`

	// Must be `1`
	SetSettings SetSettingsSetSettings `json:"set_settings"`

	// [Optional] Tax identification number. Only applicable for real money account.
	// Required for maltainvest landing company.
	TaxIdentificationNumber *string `json:"tax_identification_number,omitempty"`

	// [Optional] Residence for tax purpose. Comma separated iso country code if
	// multiple jurisdictions. Only applicable for real money account. Required for
	// maltainvest landing company.
	TaxResidence *string `json:"tax_residence,omitempty"`

	// [Optional] Enable/Disable Trading Hub dashboard
	TradingHub *SetSettingsTradingHub `json:"trading_hub,omitempty"`
}

type SetSettingsAccountOpeningReason string

const SetSettingsAccountOpeningReasonHedging SetSettingsAccountOpeningReason = "Hedging"
const SetSettingsAccountOpeningReasonIncomeEarning SetSettingsAccountOpeningReason = "Income Earning"
const SetSettingsAccountOpeningReasonPeerToPeerExchange SetSettingsAccountOpeningReason = "Peer-to-peer exchange"
const SetSettingsAccountOpeningReasonSpeculative SetSettingsAccountOpeningReason = "Speculative"

type SetSettingsAllowCopiers int

type SetSettingsDxtradeUserException int

type SetSettingsEmailConsent int

type SetSettingsEmploymentStatus string

const SetSettingsEmploymentStatusEmployed SetSettingsEmploymentStatus = "Employed"
const SetSettingsEmploymentStatusPensioner SetSettingsEmploymentStatus = "Pensioner"
const SetSettingsEmploymentStatusSelfEmployed SetSettingsEmploymentStatus = "Self-Employed"
const SetSettingsEmploymentStatusStudent SetSettingsEmploymentStatus = "Student"
const SetSettingsEmploymentStatusUnemployed SetSettingsEmploymentStatus = "Unemployed"

// [Optional] Enable or disable one or multiple features.
type SetSettingsFeatureFlag struct {
	// [Optional] Boolean value 1 or 0 indicating whether to enable/disable this
	// feature
	Wallet *SetSettingsFeatureFlagWallet `json:"wallet,omitempty"`
}

type SetSettingsFeatureFlagWallet int

type SetSettingsNonPepDeclaration int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type SetSettingsPassthrough map[string]interface{}

type SetSettingsRequestProfessionalStatus int

// A message with User Settings
type SetSettingsResp struct {
	// Echo of the request made.
	EchoReq SetSettingsRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType SetSettingsRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// 1 on success
	SetSettings *int `json:"set_settings,omitempty"`
}

// Echo of the request made.
type SetSettingsRespEchoReq map[string]interface{}

type SetSettingsRespMsgType string

const SetSettingsRespMsgTypeSetSettings SetSettingsRespMsgType = "set_settings"

type SetSettingsSalutation string

const SetSettingsSalutationMiss SetSettingsSalutation = "Miss"
const SetSettingsSalutationMr SetSettingsSalutation = "Mr"
const SetSettingsSalutationMrs SetSettingsSalutation = "Mrs"
const SetSettingsSalutationMs SetSettingsSalutation = "Ms"

type SetSettingsSecretQuestion string

const SetSettingsSecretQuestionBrandOfFirstCar SetSettingsSecretQuestion = "Brand of first car"
const SetSettingsSecretQuestionFavouriteArtist SetSettingsSecretQuestion = "Favourite artist"
const SetSettingsSecretQuestionFavouriteDish SetSettingsSecretQuestion = "Favourite dish"
const SetSettingsSecretQuestionMemorableDate SetSettingsSecretQuestion = "Memorable date"
const SetSettingsSecretQuestionMemorableTownCity SetSettingsSecretQuestion = "Memorable town/city"
const SetSettingsSecretQuestionMotherSMaidenName SetSettingsSecretQuestion = "Mother's maiden name"
const SetSettingsSecretQuestionNameOfFirstLove SetSettingsSecretQuestion = "Name of first love"
const SetSettingsSecretQuestionNameOfYourPet SetSettingsSecretQuestion = "Name of your pet"

type SetSettingsSetSettings int

type SetSettingsTradingHub int

// Retrieve a summary of account transactions, according to given search criteria
type Statement struct {
	// [Optional] To filter the statement according to the type of transaction.
	ActionType *StatementActionType `json:"action_type,omitempty"`

	// [Optional] Start date (epoch)
	DateFrom *int `json:"date_from,omitempty"`

	// [Optional] End date (epoch)
	DateTo *int `json:"date_to,omitempty"`

	// [Optional] If set to 1, will return full contracts description.
	Description *StatementDescription `json:"description,omitempty"`

	// [Optional] Maximum number of transactions to receive.
	Limit float64 `json:"limit,omitempty"`

	// [Optional] Number of transactions to skip.
	Offset *int `json:"offset,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough StatementPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// Must be `1`
	Statement StatementStatement `json:"statement"`
}

type StatementActionType string

const StatementActionTypeAdjustment StatementActionType = "adjustment"
const StatementActionTypeBuy StatementActionType = "buy"
const StatementActionTypeDeposit StatementActionType = "deposit"
const StatementActionTypeEscrow StatementActionType = "escrow"
const StatementActionTypeSell StatementActionType = "sell"
const StatementActionTypeTransfer StatementActionType = "transfer"
const StatementActionTypeVirtualCredit StatementActionType = "virtual_credit"
const StatementActionTypeWithdrawal StatementActionType = "withdrawal"

type StatementDescription int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type StatementPassthrough map[string]interface{}

// A summary of account statement is received
type StatementResp struct {
	// Echo of the request made.
	EchoReq StatementRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType StatementRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// Account statement.
	Statement *StatementRespStatement `json:"statement,omitempty"`
}

// Echo of the request made.
type StatementRespEchoReq map[string]interface{}

type StatementRespMsgType string

const StatementRespMsgTypeStatement StatementRespMsgType = "statement"

// Account statement.
type StatementRespStatement struct {
	// Number of transactions returned in this call
	Count *float64 `json:"count,omitempty"`

	// Array of returned transactions
	Transactions []StatementRespStatementTransactionsElem `json:"transactions,omitempty"`
}

type StatementRespStatementTransactionsElem struct {
	// It is the type of action.
	ActionType *StatementRespStatementTransactionsElemActionType `json:"action_type,omitempty"`

	// It is the amount of transaction.
	Amount *float64 `json:"amount,omitempty"`

	// ID of the application where this contract was purchased.
	AppId interface{} `json:"app_id,omitempty"`

	// It is the remaining balance.
	BalanceAfter *float64 `json:"balance_after,omitempty"`

	// It is the contract ID.
	ContractId interface{} `json:"contract_id,omitempty"`

	// Contains details about fees used for transfer. It is present only when action
	// type is transfer.
	Fees *StatementRespStatementTransactionsElemFees `json:"fees,omitempty"`

	// Contains details of account from which amount was transferred. It is present
	// only when action type is transfer.
	From *StatementRespStatementTransactionsElemFrom `json:"from,omitempty"`

	// The description of contract purchased if description is set to `1`.
	Longcode *string `json:"longcode,omitempty"`

	// Payout price
	Payout interface{} `json:"payout,omitempty"`

	// Time at which contract was purchased, present only for sell transaction
	PurchaseTime *int `json:"purchase_time,omitempty"`

	// Internal transaction identifier for the corresponding buy transaction ( set
	// only for contract selling )
	ReferenceId interface{} `json:"reference_id,omitempty"`

	// Compact description of the contract purchased if description is set to `1`.
	Shortcode interface{} `json:"shortcode,omitempty"`

	// Contains details of account to which amount was transferred. It is present only
	// when action type is transfer.
	To *StatementRespStatementTransactionsElemTo `json:"to,omitempty"`

	// It is the transaction ID. In statement every contract (buy or sell) and every
	// payment has a unique ID.
	TransactionId *int `json:"transaction_id,omitempty"`

	// It is the time of transaction.
	TransactionTime *int `json:"transaction_time,omitempty"`

	// Additional withdrawal details such as typical processing times, if description
	// is set to `1`.
	WithdrawalDetails *string `json:"withdrawal_details,omitempty"`
}

type StatementRespStatementTransactionsElemActionType string

const StatementRespStatementTransactionsElemActionTypeAdjustment StatementRespStatementTransactionsElemActionType = "adjustment"
const StatementRespStatementTransactionsElemActionTypeBuy StatementRespStatementTransactionsElemActionType = "buy"
const StatementRespStatementTransactionsElemActionTypeDeposit StatementRespStatementTransactionsElemActionType = "deposit"
const StatementRespStatementTransactionsElemActionTypeHold StatementRespStatementTransactionsElemActionType = "hold"
const StatementRespStatementTransactionsElemActionTypeRelease StatementRespStatementTransactionsElemActionType = "release"
const StatementRespStatementTransactionsElemActionTypeSell StatementRespStatementTransactionsElemActionType = "sell"
const StatementRespStatementTransactionsElemActionTypeTransfer StatementRespStatementTransactionsElemActionType = "transfer"
const StatementRespStatementTransactionsElemActionTypeVirtualCredit StatementRespStatementTransactionsElemActionType = "virtual_credit"
const StatementRespStatementTransactionsElemActionTypeWithdrawal StatementRespStatementTransactionsElemActionType = "withdrawal"

// Contains details about fees used for transfer. It is present only when action
// type is transfer.
type StatementRespStatementTransactionsElemFees struct {
	// Fees amount
	Amount *float64 `json:"amount,omitempty"`

	// Fees currency
	Currency *string `json:"currency,omitempty"`

	// Minimum amount of fees
	Minimum *float64 `json:"minimum,omitempty"`

	// Fees percentage
	Percentage *float64 `json:"percentage,omitempty"`
}

// Contains details of account from which amount was transferred. It is present
// only when action type is transfer.
type StatementRespStatementTransactionsElemFrom struct {
	// Login id of the account from which money was transferred.
	Loginid *string `json:"loginid,omitempty"`
}

// Contains details of account to which amount was transferred. It is present only
// when action type is transfer.
type StatementRespStatementTransactionsElemTo struct {
	// Login id of the account to which money was transferred.
	Loginid *string `json:"loginid,omitempty"`
}

type StatementStatement int

// For a given country, returns a list of States of that country. This is useful to
// populate the account opening form.
type StatesList struct {
	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough StatesListPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// Client's 2-letter country code (obtained from `residence_list` call)
	StatesList string `json:"states_list"`
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type StatesListPassthrough map[string]interface{}

// A message with States List
type StatesListResp struct {
	// Echo of the request made.
	EchoReq StatesListRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType StatesListRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// List of states.
	StatesList []StatesListRespStatesListElem `json:"states_list,omitempty"`
}

// Echo of the request made.
type StatesListRespEchoReq map[string]interface{}

type StatesListRespMsgType string

const StatesListRespMsgTypeStatesList StatesListRespMsgType = "states_list"

type StatesListRespStatesListElem struct {
	// The state name.
	Text *string `json:"text,omitempty"`

	// The state code.
	Value *string `json:"value,omitempty"`
}

type StreamTypes string

const StreamTypesBalance StreamTypes = "balance"
const StreamTypesCandles StreamTypes = "candles"
const StreamTypesCashierPayments StreamTypes = "cashier_payments"
const StreamTypesP2PAdvert StreamTypes = "p2p_advert"
const StreamTypesP2PAdvertiser StreamTypes = "p2p_advertiser"
const StreamTypesP2POrder StreamTypes = "p2p_order"
const StreamTypesProposal StreamTypes = "proposal"
const StreamTypesProposalOpenContract StreamTypes = "proposal_open_contract"
const StreamTypesTicks StreamTypes = "ticks"
const StreamTypesTradingPlatformAssetListing StreamTypes = "trading_platform_asset_listing"
const StreamTypesTransaction StreamTypes = "transaction"
const StreamTypesWebsiteStatus StreamTypes = "website_status"

// Initiate a continuous stream of spot price updates for a given symbol.
type Ticks struct {
	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough TicksPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// [Optional] If set to 1, will send updates whenever a new tick is received.
	Subscribe *TicksSubscribe `json:"subscribe,omitempty"`

	// The short symbol name or array of symbols (obtained from `active_symbols`
	// call).
	Ticks interface{} `json:"ticks"`
}

// Get historic tick data for a given symbol.
type TicksHistory struct {
	// [Optional] 1 - if the market is closed at the end time, or license limit is
	// before end time, adjust interval backwards to compensate.
	AdjustStartTime *TicksHistoryAdjustStartTime `json:"adjust_start_time,omitempty"`

	// [Optional] An upper limit on ticks to receive.
	Count int `json:"count,omitempty"`

	// Epoch value representing the latest boundary of the returned ticks. If `latest`
	// is specified, this will be the latest available timestamp.
	End string `json:"end"`

	// [Optional] Only applicable for style: `candles`. Candle time-dimension width
	// setting. (default: `60`).
	Granularity *TicksHistoryGranularity `json:"granularity,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough TicksHistoryPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// [Optional] Epoch value representing the earliest boundary of the returned
	// ticks.
	// - For `"style": "ticks"`: this will default to 1 day ago.
	// - For `"style": "candles"`: it will default to 1 day ago if count or
	// granularity is undefined.
	Start *int `json:"start,omitempty"`

	// [Optional] The tick-output style.
	Style TicksHistoryStyle `json:"style,omitempty"`

	// [Optional] 1 - to send updates whenever a new tick is received.
	Subscribe *TicksHistorySubscribe `json:"subscribe,omitempty"`

	// Short symbol name (obtained from the `active_symbols` call).
	TicksHistory string `json:"ticks_history"`
}

type TicksHistoryAdjustStartTime int

type TicksHistoryGranularity int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type TicksHistoryPassthrough map[string]interface{}

// Historic tick data for a single symbol
type TicksHistoryResp struct {
	// Array of OHLC (open/high/low/close) price values for the given time (only for
	// style=`candles`)
	Candles []TicksHistoryRespCandlesElem `json:"candles,omitempty"`

	// Echo of the request made.
	EchoReq TicksHistoryRespEchoReq `json:"echo_req"`

	// Historic tick data for a given symbol. Note: this will always return the latest
	// possible set of ticks with accordance to the parameters specified.
	History *TicksHistoryRespHistory `json:"history,omitempty"`

	// Type of the response according to the `style` sent in request. Would be
	// `history` or `candles` for the first response, and `tick` or `ohlc` for the
	// rest when subscribed.
	MsgType TicksHistoryRespMsgType `json:"msg_type"`

	// Historic tick data for a given symbol. Note: this will always return the latest
	// possible set of ticks with accordance to the parameters specified.
	Ohlc *TicksHistoryRespOhlc `json:"ohlc,omitempty"`

	// Indicates the number of decimal points that the returned amounts must be
	// displayed with
	PipSize *float64 `json:"pip_size,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// For subscription requests only.
	Subscription *TicksHistoryRespSubscription `json:"subscription,omitempty"`
}

type TicksHistoryRespCandlesElem struct {
	// It is the close price value for the given time
	Close *float64 `json:"close,omitempty"`

	// It is an epoch value
	Epoch *int `json:"epoch,omitempty"`

	// It is the high price value for the given time
	High *float64 `json:"high,omitempty"`

	// It is the low price value for the given time
	Low *float64 `json:"low,omitempty"`

	// It is the open price value for the given time
	Open *float64 `json:"open,omitempty"`
}

// Echo of the request made.
type TicksHistoryRespEchoReq map[string]interface{}

// Historic tick data for a given symbol. Note: this will always return the latest
// possible set of ticks with accordance to the parameters specified.
type TicksHistoryRespHistory struct {
	// An array containing list of tick values for the corresponding epoch values in
	// `times` array.
	Prices []float64 `json:"prices,omitempty"`

	// An array containing list of epoch values for the corresponding tick values in
	// `prices` array.
	Times []int `json:"times,omitempty"`
}

type TicksHistoryRespMsgType string

const TicksHistoryRespMsgTypeCandles TicksHistoryRespMsgType = "candles"
const TicksHistoryRespMsgTypeHistory TicksHistoryRespMsgType = "history"
const TicksHistoryRespMsgTypeOhlc TicksHistoryRespMsgType = "ohlc"
const TicksHistoryRespMsgTypeTick TicksHistoryRespMsgType = "tick"

// Historic tick data for a given symbol. Note: this will always return the latest
// possible set of ticks with accordance to the parameters specified.
type TicksHistoryRespOhlc struct {
	// It is the close price value for the given time
	Close *string `json:"close,omitempty"`

	// It is an epoch value
	Epoch *int `json:"epoch,omitempty"`

	// Granularity
	Granularity *int `json:"granularity,omitempty"`

	// It is the high price value for the given time
	High *string `json:"high,omitempty"`

	// Subscription unique identifier. Can be passed to the `forget` API call to
	// unsubscribe.
	Id *string `json:"id,omitempty"`

	// It is the low price value for the given time
	Low *string `json:"low,omitempty"`

	// It is the open price value for the given time
	Open *string `json:"open,omitempty"`

	// It is an epoch of open time
	OpenTime *int `json:"open_time,omitempty"`

	// PIP size
	PipSize *int `json:"pip_size,omitempty"`

	// Symbol name
	Symbol *string `json:"symbol,omitempty"`
}

// For subscription requests only.
type TicksHistoryRespSubscription struct {
	// A per-connection unique identifier. Can be passed to the `forget` API call to
	// unsubscribe.
	Id string `json:"id"`
}

type TicksHistoryStyle string

const TicksHistoryStyleCandles TicksHistoryStyle = "candles"
const TicksHistoryStyleTicks TicksHistoryStyle = "ticks"

type TicksHistorySubscribe int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type TicksPassthrough map[string]interface{}

// Latest spot price for a given symbol. Continuous responses with a frequency of
// up to one second.
type TicksResp struct {
	// Echo of the request made.
	EchoReq TicksRespEchoReq `json:"echo_req"`

	// Type of the response.
	MsgType TicksRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// For subscription requests only.
	Subscription *TicksRespSubscription `json:"subscription,omitempty"`

	// Tick by tick list of streamed data
	Tick *TicksRespTick `json:"tick,omitempty"`
}

// Echo of the request made.
type TicksRespEchoReq map[string]interface{}

type TicksRespMsgType string

const TicksRespMsgTypeTick TicksRespMsgType = "tick"

// For subscription requests only.
type TicksRespSubscription struct {
	// A per-connection unique identifier. Can be passed to the `forget` API call to
	// unsubscribe.
	Id string `json:"id"`
}

// Tick by tick list of streamed data
type TicksRespTick struct {
	// Market ask at the epoch
	Ask *float64 `json:"ask,omitempty"`

	// Market bid at the epoch
	Bid *float64 `json:"bid,omitempty"`

	// Epoch time of the tick
	Epoch *int `json:"epoch,omitempty"`

	// A per-connection unique identifier. Can be passed to the `forget` API call to
	// unsubscribe.
	Id *string `json:"id,omitempty"`

	// Indicates the number of decimal points that the returned amounts must be
	// displayed with
	PipSize float64 `json:"pip_size"`

	// Market value at the epoch
	Quote *float64 `json:"quote,omitempty"`

	// Symbol
	Symbol *string `json:"symbol,omitempty"`
}

type TicksSubscribe int

// Request back-end server epoch time.
type Time struct {
	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough TimePassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// Must be `1`
	Time TimeTime `json:"time"`
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type TimePassthrough map[string]interface{}

// The result of server time request.
type TimeResp struct {
	// Echo of the request made.
	EchoReq TimeRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType TimeRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// Epoch of server time.
	Time *int `json:"time,omitempty"`
}

// Echo of the request made.
type TimeRespEchoReq map[string]interface{}

type TimeRespMsgType string

const TimeRespMsgTypeTime TimeRespMsgType = "time"

type TimeTime int

// To approve the latest version of terms and conditions.
type TncApproval struct {
	// [Optional] For Affiliate's Code of Conduct Agreement.
	AffiliateCocAgreement *TncApprovalAffiliateCocAgreement `json:"affiliate_coc_agreement,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough TncApprovalPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// Must be `1`
	TncApproval TncApprovalTncApproval `json:"tnc_approval"`

	// [Optional] For `ASK_UK_FUNDS_PROTECTION` in `cashier`.
	UkgcFundsProtection *TncApprovalUkgcFundsProtection `json:"ukgc_funds_protection,omitempty"`
}

type TncApprovalAffiliateCocAgreement int

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type TncApprovalPassthrough map[string]interface{}

// The result of T&C approval request.
type TncApprovalResp struct {
	// Echo of the request made.
	EchoReq TncApprovalRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType TncApprovalRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// Set terms and conditions 1: success
	TncApproval *TncApprovalRespTncApproval `json:"tnc_approval,omitempty"`
}

// Echo of the request made.
type TncApprovalRespEchoReq map[string]interface{}

type TncApprovalRespMsgType string

const TncApprovalRespMsgTypeTncApproval TncApprovalRespMsgType = "tnc_approval"

type TncApprovalRespTncApproval int

type TncApprovalTncApproval float64

type TncApprovalUkgcFundsProtection int

// When a virtual-money's account balance becomes low, it can be topped up using
// this call.
type TopupVirtual struct {
	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough TopupVirtualPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// Must be `1`
	TopupVirtual TopupVirtualTopupVirtual `json:"topup_virtual"`
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type TopupVirtualPassthrough map[string]interface{}

// The result of virtual money top up
type TopupVirtualResp struct {
	// Echo of the request made.
	EchoReq TopupVirtualRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType TopupVirtualRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// The information regarding a successful top up for a virtual money account
	TopupVirtual *TopupVirtualRespTopupVirtual `json:"topup_virtual,omitempty"`
}

// Echo of the request made.
type TopupVirtualRespEchoReq map[string]interface{}

type TopupVirtualRespMsgType string

const TopupVirtualRespMsgTypeTopupVirtual TopupVirtualRespMsgType = "topup_virtual"

// The information regarding a successful top up for a virtual money account
type TopupVirtualRespTopupVirtual struct {
	// Top up amount
	Amount *float64 `json:"amount,omitempty"`

	// Top up currency string
	Currency *string `json:"currency,omitempty"`
}

type TopupVirtualTopupVirtual int

// Retrieve a list of all available underlyings and the corresponding contract
// types and trading duration boundaries. If the user is logged in, only the assets
// available for that user's landing company will be returned.
type TradingDurations struct {
	// Deprecated - Replaced by landing_company_short.
	LandingCompany *TradingDurationsLandingCompany `json:"landing_company,omitempty"`

	// [Optional] If specified, will return only the underlyings for the specified
	// landing company.
	LandingCompanyShort *TradingDurationsLandingCompanyShort `json:"landing_company_short,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough TradingDurationsPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// Must be `1`
	TradingDurations TradingDurationsTradingDurations `json:"trading_durations"`
}

type TradingDurationsLandingCompany string

const TradingDurationsLandingCompanyChampion TradingDurationsLandingCompany = "champion"
const TradingDurationsLandingCompanyChampionVirtual TradingDurationsLandingCompany = "champion-virtual"
const TradingDurationsLandingCompanyIom TradingDurationsLandingCompany = "iom"
const TradingDurationsLandingCompanyMalta TradingDurationsLandingCompany = "malta"
const TradingDurationsLandingCompanyMaltainvest TradingDurationsLandingCompany = "maltainvest"

type TradingDurationsLandingCompanyShort string

const TradingDurationsLandingCompanyShortChampion TradingDurationsLandingCompanyShort = "champion"
const TradingDurationsLandingCompanyShortChampionVirtual TradingDurationsLandingCompanyShort = "champion-virtual"
const TradingDurationsLandingCompanyShortIom TradingDurationsLandingCompanyShort = "iom"
const TradingDurationsLandingCompanyShortMalta TradingDurationsLandingCompanyShort = "malta"
const TradingDurationsLandingCompanyShortMaltainvest TradingDurationsLandingCompanyShort = "maltainvest"
const TradingDurationsLandingCompanyShortSvg TradingDurationsLandingCompanyShort = "svg"
const TradingDurationsLandingCompanyShortVanuatu TradingDurationsLandingCompanyShort = "vanuatu"
const TradingDurationsLandingCompanyShortVirtual TradingDurationsLandingCompanyShort = "virtual"
const TradingDurationsLandingCompanySvg TradingDurationsLandingCompany = "svg"
const TradingDurationsLandingCompanyVanuatu TradingDurationsLandingCompany = "vanuatu"
const TradingDurationsLandingCompanyVirtual TradingDurationsLandingCompany = "virtual"

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type TradingDurationsPassthrough map[string]interface{}

// A message with trading duration information for symbol and contract
// combinations.
type TradingDurationsResp struct {
	// Echo of the request made.
	EchoReq TradingDurationsRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType TradingDurationsRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// List of underlyings by their display name and symbol followed by their
	// available contract types and trading duration boundaries.
	TradingDurations []TradingDurationsRespTradingDurationsElem `json:"trading_durations,omitempty"`
}

// Echo of the request made.
type TradingDurationsRespEchoReq map[string]interface{}

type TradingDurationsRespMsgType string

const TradingDurationsRespMsgTypeTradingDurations TradingDurationsRespMsgType = "trading_durations"

type TradingDurationsRespTradingDurationsElem struct {
	// Available contract types and trading duration boundaries
	Data []TradingDurationsRespTradingDurationsElemDataElem `json:"data,omitempty"`

	// The market in which the underlyings listed in `symbol` located.
	Market *TradingDurationsRespTradingDurationsElemMarket `json:"market,omitempty"`

	// The submarket in which the underlyings listed in `symbol` located.
	Submarket *TradingDurationsRespTradingDurationsElemSubmarket `json:"submarket,omitempty"`
}

type TradingDurationsRespTradingDurationsElemDataElem struct {
	// The market in which the underlyings listed in `symbol` located.
	Market *TradingDurationsRespTradingDurationsElemDataElemMarket `json:"market,omitempty"`

	// The submarket in which the underlyings listed in `symbol` located.
	Submarket *TradingDurationsRespTradingDurationsElemDataElemSubmarket `json:"submarket,omitempty"`

	// List of underlying symbols.
	Symbol []TradingDurationsRespTradingDurationsElemDataElemSymbolElem `json:"symbol,omitempty"`

	// List of trade durations available for symbols and contract combinations.
	TradeDurations []TradingDurationsRespTradingDurationsElemDataElemTradeDurationsElem `json:"trade_durations,omitempty"`
}

// The market in which the underlyings listed in `symbol` located.
type TradingDurationsRespTradingDurationsElemDataElemMarket struct {
	// Translated market name.
	DisplayName *string `json:"display_name,omitempty"`

	// Market name.
	Name *string `json:"name,omitempty"`
}

// The submarket in which the underlyings listed in `symbol` located.
type TradingDurationsRespTradingDurationsElemDataElemSubmarket struct {
	// Translated submarket name.
	DisplayName *string `json:"display_name,omitempty"`

	// Submarket name.
	Name *string `json:"name,omitempty"`
}

type TradingDurationsRespTradingDurationsElemDataElemSymbolElem struct {
	// Translated symbol name.
	DisplayName *string `json:"display_name,omitempty"`

	// Symbol name.
	Name *string `json:"name,omitempty"`
}

type TradingDurationsRespTradingDurationsElemDataElemTradeDurationsElem struct {
	// List of trade durations available for the symbols.
	Durations []TradingDurationsRespTradingDurationsElemDataElemTradeDurationsElemDurationsElem `json:"durations,omitempty"`

	// List of trade types available for the symbols.
	TradeType *TradingDurationsRespTradingDurationsElemDataElemTradeDurationsElemTradeType `json:"trade_type,omitempty"`
}

type TradingDurationsRespTradingDurationsElemDataElemTradeDurationsElemDurationsElem struct {
	// Translated duration type name.
	DisplayName *string `json:"display_name,omitempty"`

	// Maximum allowed duration for this type.
	Max *int `json:"max,omitempty"`

	// Minimum allowed duration for this type.
	Min *int `json:"min,omitempty"`

	// Duration type name.
	Name *string `json:"name,omitempty"`
}

// List of trade types available for the symbols.
type TradingDurationsRespTradingDurationsElemDataElemTradeDurationsElemTradeType struct {
	// Translated trade type name.
	DisplayName *string `json:"display_name,omitempty"`

	// Trade type name.
	Name *string `json:"name,omitempty"`
}

// The market in which the underlyings listed in `symbol` located.
type TradingDurationsRespTradingDurationsElemMarket struct {
	// Translated market name.
	DisplayName *string `json:"display_name,omitempty"`

	// Market name.
	Name *string `json:"name,omitempty"`
}

// The submarket in which the underlyings listed in `symbol` located.
type TradingDurationsRespTradingDurationsElemSubmarket struct {
	// Translated submarket name.
	DisplayName *string `json:"display_name,omitempty"`

	// Submarket name.
	Name *string `json:"name,omitempty"`
}

type TradingDurationsTradingDurations int

// Reset the investor password of a Trading Platform Account
type TradingPlatformInvestorPasswordReset struct {
	// Trading account ID.
	AccountId string `json:"account_id"`

	// New password of the account. For validation (Accepts any printable ASCII
	// character. Must be within 8-25 characters, and include numbers, lowercase and
	// uppercase letters. Must not be the same as the user's email address).
	NewPassword string `json:"new_password"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough TradingPlatformInvestorPasswordResetPassthrough `json:"passthrough,omitempty"`

	// Name of trading platform.
	Platform TradingPlatformInvestorPasswordResetPlatform `json:"platform"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// Must be `1`
	TradingPlatformInvestorPasswordReset TradingPlatformInvestorPasswordResetTradingPlatformInvestorPasswordReset `json:"trading_platform_investor_password_reset"`

	// Email verification code (received from a `verify_email` call, which must be
	// done first)
	VerificationCode string `json:"verification_code"`
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type TradingPlatformInvestorPasswordResetPassthrough map[string]interface{}

type TradingPlatformInvestorPasswordResetPlatform string

const TradingPlatformInvestorPasswordResetPlatformMt5 TradingPlatformInvestorPasswordResetPlatform = "mt5"

// The result of the Trading Platform investor password reset.
type TradingPlatformInvestorPasswordResetResp struct {
	// Echo of the request made.
	EchoReq TradingPlatformInvestorPasswordResetRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType TradingPlatformInvestorPasswordResetRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// If set to 1, the investor password has been reset.
	TradingPlatformPasswordReset *TradingPlatformInvestorPasswordResetRespTradingPlatformPasswordReset `json:"trading_platform_password_reset,omitempty"`
}

// Echo of the request made.
type TradingPlatformInvestorPasswordResetRespEchoReq map[string]interface{}

type TradingPlatformInvestorPasswordResetRespMsgType string

const TradingPlatformInvestorPasswordResetRespMsgTypeTradingPlatformInvestorPasswordReset TradingPlatformInvestorPasswordResetRespMsgType = "trading_platform_investor_password_reset"

type TradingPlatformInvestorPasswordResetRespTradingPlatformPasswordReset int

type TradingPlatformInvestorPasswordResetTradingPlatformInvestorPasswordReset int

// Reset the password of a Trading Platform Account
type TradingPlatformPasswordReset struct {
	// New password of the account. For validation (Accepts any printable ASCII
	// character. Must be within 8-25 characters, and include numbers, lowercase and
	// uppercase letters. Must not be the same as the user's email address).
	NewPassword string `json:"new_password"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough TradingPlatformPasswordResetPassthrough `json:"passthrough,omitempty"`

	// Name of trading platform.
	Platform TradingPlatformPasswordResetPlatform `json:"platform"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// Must be `1`
	TradingPlatformPasswordReset TradingPlatformPasswordResetTradingPlatformPasswordReset `json:"trading_platform_password_reset"`

	// Email verification code (received from a `verify_email` call, which must be
	// done first)
	VerificationCode string `json:"verification_code"`
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type TradingPlatformPasswordResetPassthrough map[string]interface{}

type TradingPlatformPasswordResetPlatform string

const TradingPlatformPasswordResetPlatformDxtrade TradingPlatformPasswordResetPlatform = "dxtrade"
const TradingPlatformPasswordResetPlatformMt5 TradingPlatformPasswordResetPlatform = "mt5"

// The result of the Trading Platform password reset.
type TradingPlatformPasswordResetResp struct {
	// Echo of the request made.
	EchoReq TradingPlatformPasswordResetRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType TradingPlatformPasswordResetRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// If set to 1, the password has been reset.
	TradingPlatformPasswordReset *TradingPlatformPasswordResetRespTradingPlatformPasswordReset `json:"trading_platform_password_reset,omitempty"`
}

// Echo of the request made.
type TradingPlatformPasswordResetRespEchoReq map[string]interface{}

type TradingPlatformPasswordResetRespMsgType string

const TradingPlatformPasswordResetRespMsgTypeTradingPlatformPasswordReset TradingPlatformPasswordResetRespMsgType = "trading_platform_password_reset"

type TradingPlatformPasswordResetRespTradingPlatformPasswordReset int

type TradingPlatformPasswordResetTradingPlatformPasswordReset int

// Get the list of servers for a trading platform.
type TradingServers struct {
	// [Optional] Trading account type.
	AccountType *TradingServersAccountType `json:"account_type,omitempty"`

	// [Optional] Pass the environment (installation) instance. Currently, there are
	// one demo and two real environments. Defaults to 'all'.
	Environment TradingServersEnvironment `json:"environment,omitempty"`

	// [Optional] Market type.
	MarketType TradingServersMarketType `json:"market_type,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough TradingServersPassthrough `json:"passthrough,omitempty"`

	// [Optional] Pass the trading platform name, default to mt5
	Platform TradingServersPlatform `json:"platform,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// Must be `1`
	TradingServers TradingServersTradingServers `json:"trading_servers"`
}

type TradingServersAccountType string

const TradingServersAccountTypeDemo TradingServersAccountType = "demo"
const TradingServersAccountTypeReal TradingServersAccountType = "real"

type TradingServersEnvironment string

const TradingServersEnvironmentAll TradingServersEnvironment = "all"
const TradingServersEnvironmentDerivDemo TradingServersEnvironment = "Deriv-Demo"
const TradingServersEnvironmentDerivServer TradingServersEnvironment = "Deriv-Server"
const TradingServersEnvironmentDerivServer02 TradingServersEnvironment = "Deriv-Server-02"

type TradingServersMarketType string

const TradingServersMarketTypeFinancial TradingServersMarketType = "financial"
const TradingServersMarketTypeSynthetic TradingServersMarketType = "synthetic"

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type TradingServersPassthrough map[string]interface{}

type TradingServersPlatform string

const TradingServersPlatformDxtrade TradingServersPlatform = "dxtrade"
const TradingServersPlatformMt5 TradingServersPlatform = "mt5"

// Get list of servers for the platform provided.
type TradingServersResp struct {
	// Echo of the request made.
	EchoReq TradingServersRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType TradingServersRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// Array containing platform server objects.
	TradingServers []TradingServersRespTradingServersElem `json:"trading_servers,omitempty"`
}

// Echo of the request made.
type TradingServersRespEchoReq map[string]interface{}

type TradingServersRespMsgType string

const TradingServersRespMsgTypeTradingServers TradingServersRespMsgType = "trading_servers"

type TradingServersRespTradingServersElem struct {
	// Supported trading account type.
	AccountType *TradingServersRespTradingServersElemAccountType `json:"account_type,omitempty"`

	// Flag to represent if this server is currently disabled or not
	Disabled *TradingServersRespTradingServersElemDisabled `json:"disabled,omitempty"`

	// Current environment (installation instance) where servers are deployed.
	// Currently, there are one demo and two real environments.
	Environment *TradingServersRespTradingServersElemEnvironment `json:"environment,omitempty"`

	// Object containing geolocation information of the server.
	Geolocation *TradingServersRespTradingServersElemGeolocation `json:"geolocation,omitempty"`

	// Server unique id.
	Id *TradingServersRespTradingServersElemId `json:"id,omitempty"`

	// Market type
	MarketType *string `json:"market_type,omitempty"`

	// Error message to client when server is disabled
	MessageToClient *string `json:"message_to_client,omitempty"`

	// Flag to represent if this is server is recommended based on client's country of
	// residence.
	Recommended *TradingServersRespTradingServersElemRecommended `json:"recommended,omitempty"`

	// Account type supported by the server.
	SupportedAccounts []string `json:"supported_accounts,omitempty"`
}

type TradingServersRespTradingServersElemAccountType string

const TradingServersRespTradingServersElemAccountTypeDemo TradingServersRespTradingServersElemAccountType = "demo"
const TradingServersRespTradingServersElemAccountTypeReal TradingServersRespTradingServersElemAccountType = "real"

type TradingServersRespTradingServersElemDisabled int

type TradingServersRespTradingServersElemEnvironment string

const TradingServersRespTradingServersElemEnvironmentDerivDemo TradingServersRespTradingServersElemEnvironment = "Deriv-Demo"
const TradingServersRespTradingServersElemEnvironmentDerivServer TradingServersRespTradingServersElemEnvironment = "Deriv-Server"
const TradingServersRespTradingServersElemEnvironmentDerivServer02 TradingServersRespTradingServersElemEnvironment = "Deriv-Server-02"

// Object containing geolocation information of the server.
type TradingServersRespTradingServersElemGeolocation struct {
	// Internal server grouping.
	Group *string `json:"group,omitempty"`

	// Geolocation country or place where server is located.
	Location *string `json:"location,omitempty"`

	// Geolocation region where server is located.
	Region *string `json:"region,omitempty"`

	// Sequence number of the server in that region.
	Sequence *int `json:"sequence,omitempty"`
}

type TradingServersRespTradingServersElemId string

const TradingServersRespTradingServersElemIdP01Ts01 TradingServersRespTradingServersElemId = "p01_ts01"
const TradingServersRespTradingServersElemIdP01Ts02 TradingServersRespTradingServersElemId = "p01_ts02"
const TradingServersRespTradingServersElemIdP01Ts03 TradingServersRespTradingServersElemId = "p01_ts03"
const TradingServersRespTradingServersElemIdP01Ts04 TradingServersRespTradingServersElemId = "p01_ts04"
const TradingServersRespTradingServersElemIdP02Ts02 TradingServersRespTradingServersElemId = "p02_ts02"

type TradingServersRespTradingServersElemRecommended int

type TradingServersTradingServers int

// Receive a list of market opening times for a given date.
type TradingTimes struct {
	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough TradingTimesPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// Date to receive market opening times for. (`yyyy-mm-dd` format. `today` can
	// also be specified).
	TradingTimes string `json:"trading_times"`
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type TradingTimesPassthrough map[string]interface{}

// A message with Trading Times
type TradingTimesResp struct {
	// Echo of the request made.
	EchoReq TradingTimesRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType TradingTimesRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// The trading times structure is a hierarchy as follows: Market -> SubMarket ->
	// Underlyings
	TradingTimes *TradingTimesRespTradingTimes `json:"trading_times,omitempty"`
}

// Echo of the request made.
type TradingTimesRespEchoReq map[string]interface{}

type TradingTimesRespMsgType string

const TradingTimesRespMsgTypeTradingTimes TradingTimesRespMsgType = "trading_times"

// The trading times structure is a hierarchy as follows: Market -> SubMarket ->
// Underlyings
type TradingTimesRespTradingTimes struct {
	// An array of markets
	Markets []TradingTimesRespTradingTimesMarketsElem `json:"markets"`
}

type TradingTimesRespTradingTimesMarketsElem struct {
	// Market name
	Name string `json:"name"`

	// An array of submarkets
	Submarkets []TradingTimesRespTradingTimesMarketsElemSubmarketsElem `json:"submarkets,omitempty"`
}

type TradingTimesRespTradingTimesMarketsElemSubmarketsElem struct {
	// Submarket name
	Name string `json:"name"`

	// Symbols array
	Symbols []TradingTimesRespTradingTimesMarketsElemSubmarketsElemSymbolsElem `json:"symbols,omitempty"`
}

type TradingTimesRespTradingTimesMarketsElemSubmarketsElemSymbolsElem struct {
	// Events
	Events []interface{} `json:"events,omitempty"`

	// Symbol name
	Name string `json:"name"`

	// Symbol shortcode
	Symbol string `json:"symbol"`

	// Open, close and settlement times
	Times TradingTimesRespTradingTimesMarketsElemSubmarketsElemSymbolsElemTimes `json:"times,omitempty"`

	// Trading days
	TradingDays []TradingTimesRespTradingTimesMarketsElemSubmarketsElemSymbolsElemTradingDaysElem `json:"trading_days,omitempty"`
}

// Open, close and settlement times
type TradingTimesRespTradingTimesMarketsElemSubmarketsElemSymbolsElemTimes map[string]interface{}

type TradingTimesRespTradingTimesMarketsElemSubmarketsElemSymbolsElemTradingDaysElem string

const TradingTimesRespTradingTimesMarketsElemSubmarketsElemSymbolsElemTradingDaysElemFri TradingTimesRespTradingTimesMarketsElemSubmarketsElemSymbolsElemTradingDaysElem = "Fri"
const TradingTimesRespTradingTimesMarketsElemSubmarketsElemSymbolsElemTradingDaysElemMon TradingTimesRespTradingTimesMarketsElemSubmarketsElemSymbolsElemTradingDaysElem = "Mon"
const TradingTimesRespTradingTimesMarketsElemSubmarketsElemSymbolsElemTradingDaysElemSat TradingTimesRespTradingTimesMarketsElemSubmarketsElemSymbolsElemTradingDaysElem = "Sat"
const TradingTimesRespTradingTimesMarketsElemSubmarketsElemSymbolsElemTradingDaysElemSun TradingTimesRespTradingTimesMarketsElemSubmarketsElemSymbolsElemTradingDaysElem = "Sun"
const TradingTimesRespTradingTimesMarketsElemSubmarketsElemSymbolsElemTradingDaysElemThu TradingTimesRespTradingTimesMarketsElemSubmarketsElemSymbolsElemTradingDaysElem = "Thu"
const TradingTimesRespTradingTimesMarketsElemSubmarketsElemSymbolsElemTradingDaysElemTue TradingTimesRespTradingTimesMarketsElemSubmarketsElemSymbolsElemTradingDaysElem = "Tue"
const TradingTimesRespTradingTimesMarketsElemSubmarketsElemSymbolsElemTradingDaysElemWed TradingTimesRespTradingTimesMarketsElemSubmarketsElemSymbolsElemTradingDaysElem = "Wed"

// Subscribe to transaction notifications
type Transaction struct {
	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough TransactionPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// If set to 1, will send updates whenever there is an update to transactions. If
	// not to 1 then it will not return any records.
	Subscribe TransactionSubscribe `json:"subscribe"`

	// Must be `1`
	Transaction TransactionTransaction `json:"transaction"`
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type TransactionPassthrough map[string]interface{}

// Return transaction updates
type TransactionResp struct {
	// Echo of the request made.
	EchoReq TransactionRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType TransactionRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// For subscription requests only.
	Subscription *TransactionRespSubscription `json:"subscription,omitempty"`

	// Realtime stream of user transaction updates.
	Transaction *TransactionRespTransaction `json:"transaction,omitempty"`
}

// Echo of the request made.
type TransactionRespEchoReq map[string]interface{}

type TransactionRespMsgType string

const TransactionRespMsgTypeTransaction TransactionRespMsgType = "transaction"

// For subscription requests only.
type TransactionRespSubscription struct {
	// A per-connection unique identifier. Can be passed to the `forget` API call to
	// unsubscribe.
	Id string `json:"id"`
}

// Realtime stream of user transaction updates.
type TransactionRespTransaction struct {
	// The transaction type.
	Action *TransactionRespTransactionAction `json:"action,omitempty"`

	// It is the amount of transaction performed.
	Amount *float64 `json:"amount,omitempty"`

	// Balance amount
	Balance *float64 `json:"balance,omitempty"`

	// Barrier of the contract. Only applicable to single barrier contracts. Could be
	// undefined if a contract does not have a barrier.
	Barrier interface{} `json:"barrier,omitempty"`

	// It is the contract ID.
	ContractId interface{} `json:"contract_id,omitempty"`

	// Transaction currency
	Currency *string `json:"currency,omitempty"`

	// Epoch value of the expiry time of the contract. Please note that in case of buy
	// transaction this is approximate value not exact one.
	DateExpiry *int `json:"date_expiry,omitempty"`

	// Display name of symbol
	DisplayName *string `json:"display_name,omitempty"`

	// The high barrier of a contract. Only applicable to double barrier contracts.
	HighBarrier interface{} `json:"high_barrier,omitempty"`

	// A per-connection unique identifier. Can be passed to the `forget` API call to
	// unsubscribe.
	Id *string `json:"id,omitempty"`

	// Description of contract purchased
	Longcode *string `json:"longcode,omitempty"`

	// The low barrier of a contract. Only applicable to double barrier contracts.
	LowBarrier *string `json:"low_barrier,omitempty"`

	// Time at which contract was purchased, present only for sell transaction
	PurchaseTime *int `json:"purchase_time,omitempty"`

	// The pip-sized target spot price where the contract will be closed automatically
	// at the loss specified by the user.
	StopLoss interface{} `json:"stop_loss,omitempty"`

	// The pip-sized target spot price where the contract will be closed automatically
	// when the value of the contract is close to zero. This is set by the us.
	StopOut interface{} `json:"stop_out,omitempty"`

	// Symbol code
	Symbol *string `json:"symbol,omitempty"`

	// The pip-sized target spot price where the contract will be closed automatically
	// at the profit specified by the user.
	TakeProfit interface{} `json:"take_profit,omitempty"`

	// It is the transaction ID. Every contract (buy or sell) or payment has a unique
	// ID.
	TransactionId *int `json:"transaction_id,omitempty"`

	// Time at which transaction was performed: for buy it is purchase time, for sell
	// it is sell time.
	TransactionTime *int `json:"transaction_time,omitempty"`
}

type TransactionRespTransactionAction string

const TransactionRespTransactionActionAdjustment TransactionRespTransactionAction = "adjustment"
const TransactionRespTransactionActionBuy TransactionRespTransactionAction = "buy"
const TransactionRespTransactionActionDeposit TransactionRespTransactionAction = "deposit"
const TransactionRespTransactionActionEscrow TransactionRespTransactionAction = "escrow"
const TransactionRespTransactionActionSell TransactionRespTransactionAction = "sell"
const TransactionRespTransactionActionTransfer TransactionRespTransactionAction = "transfer"
const TransactionRespTransactionActionVirtualCredit TransactionRespTransactionAction = "virtual_credit"
const TransactionRespTransactionActionWithdrawal TransactionRespTransactionAction = "withdrawal"

type TransactionSubscribe int

type TransactionTransaction int

// This call allows transfers between accounts held by a given user. Transfer funds
// between your fiat and cryptocurrency accounts (for a fee). Please note that
// account_from should be same as current authorized account.
type TransferBetweenAccounts struct {
	// [Optional] The loginid of the account to transfer funds from.
	AccountFrom *string `json:"account_from,omitempty"`

	// [Optional] The loginid of the account to transfer funds to.
	AccountTo *string `json:"account_to,omitempty"`

	// [Optional] To control the list of accounts returned when `account_from` or
	// `account_to` is not provided. `brief` (default value) means that accounts with
	// `mt5` account_type will be excluded; it will run faster. `all` means that all
	// accounts with any account_type (including `mt5`) will be returned.
	Accounts TransferBetweenAccountsAccounts `json:"accounts,omitempty"`

	// [Optional] The amount to transfer.
	Amount *float64 `json:"amount,omitempty"`

	// [Optional] Currency code.
	Currency *string `json:"currency,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough TransferBetweenAccountsPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// If `account_from` or `account_to` is not provided, it just returns the
	// available accounts.
	TransferBetweenAccounts TransferBetweenAccountsTransferBetweenAccounts `json:"transfer_between_accounts"`
}

type TransferBetweenAccountsAccounts string

const TransferBetweenAccountsAccountsAll TransferBetweenAccountsAccounts = "all"
const TransferBetweenAccountsAccountsBrief TransferBetweenAccountsAccounts = "brief"

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type TransferBetweenAccountsPassthrough map[string]interface{}

// The result of transfer order.
type TransferBetweenAccountsResp struct {
	// The available accounts to transfer, or the accounts affected by a successful
	// transfer.
	Accounts []TransferBetweenAccountsRespAccountsElem `json:"accounts,omitempty"`

	// The account to client full name
	ClientToFullName *string `json:"client_to_full_name,omitempty"`

	// The account to client loginid
	ClientToLoginid *string `json:"client_to_loginid,omitempty"`

	// Echo of the request made.
	EchoReq TransferBetweenAccountsRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType TransferBetweenAccountsRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// Reference ID of transfer performed
	TransactionId *int `json:"transaction_id,omitempty"`

	// If set to 1, transfer succeeded.
	TransferBetweenAccounts *TransferBetweenAccountsRespTransferBetweenAccounts `json:"transfer_between_accounts,omitempty"`
}

type TransferBetweenAccountsRespAccountsElem struct {
	// Type of the account. Please note that `binary` is deprecated and replaced by
	// `trading`
	AccountType *TransferBetweenAccountsRespAccountsElemAccountType `json:"account_type,omitempty"`

	// Account balance.
	Balance *string `json:"balance,omitempty"`

	// Default account currency.
	Currency *string `json:"currency,omitempty"`

	// 0 for real accounts; 1 for virtual/demo accounts.
	DemoAccount *TransferBetweenAccountsRespAccountsElemDemoAccount `json:"demo_account,omitempty"`

	// The group of derivez account.
	DerivezGroup *string `json:"derivez_group,omitempty"`

	// Account identifier used for system transfers.
	Loginid *string `json:"loginid,omitempty"`

	// Market type of account.
	MarketType *TransferBetweenAccountsRespAccountsElemMarketType `json:"market_type,omitempty"`

	// The group of mt5 account.
	Mt5Group *string `json:"mt5_group,omitempty"`

	// The status of account.
	Status interface{} `json:"status,omitempty"`
}

type TransferBetweenAccountsRespAccountsElemAccountType string

const TransferBetweenAccountsRespAccountsElemAccountTypeBinary TransferBetweenAccountsRespAccountsElemAccountType = "binary"
const TransferBetweenAccountsRespAccountsElemAccountTypeDerivez TransferBetweenAccountsRespAccountsElemAccountType = "derivez"
const TransferBetweenAccountsRespAccountsElemAccountTypeDxtrade TransferBetweenAccountsRespAccountsElemAccountType = "dxtrade"
const TransferBetweenAccountsRespAccountsElemAccountTypeMt5 TransferBetweenAccountsRespAccountsElemAccountType = "mt5"
const TransferBetweenAccountsRespAccountsElemAccountTypeTrading TransferBetweenAccountsRespAccountsElemAccountType = "trading"
const TransferBetweenAccountsRespAccountsElemAccountTypeWallet TransferBetweenAccountsRespAccountsElemAccountType = "wallet"

type TransferBetweenAccountsRespAccountsElemDemoAccount int

type TransferBetweenAccountsRespAccountsElemMarketType string

const TransferBetweenAccountsRespAccountsElemMarketTypeAll TransferBetweenAccountsRespAccountsElemMarketType = "all"
const TransferBetweenAccountsRespAccountsElemMarketTypeFinancial TransferBetweenAccountsRespAccountsElemMarketType = "financial"
const TransferBetweenAccountsRespAccountsElemMarketTypeSynthetic TransferBetweenAccountsRespAccountsElemMarketType = "synthetic"

// Echo of the request made.
type TransferBetweenAccountsRespEchoReq map[string]interface{}

type TransferBetweenAccountsRespMsgType string

const TransferBetweenAccountsRespMsgTypeTransferBetweenAccounts TransferBetweenAccountsRespMsgType = "transfer_between_accounts"

type TransferBetweenAccountsRespTransferBetweenAccounts int

type TransferBetweenAccountsTransferBetweenAccounts int

// It unsubscribe user from the email subscription.
type UnsubscribeEmail struct {
	// Customer User ID.
	BinaryUserId float64 `json:"binary_user_id"`

	// The generated checksum for the customer.
	Checksum string `json:"checksum"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough UnsubscribeEmailPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// Must be `1`
	UnsubscribeEmail UnsubscribeEmailUnsubscribeEmail `json:"unsubscribe_email"`
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type UnsubscribeEmailPassthrough map[string]interface{}

// The result of the unsubscribe email request.
type UnsubscribeEmailResp struct {
	// Customer User ID.
	BinaryUserId *float64 `json:"binary_user_id,omitempty"`

	// Echo of the request made.
	EchoReq UnsubscribeEmailRespEchoReq `json:"echo_req"`

	// `1`: email notification unsubscribed sucssesfully, `0`: failed to unsubscribed
	// email notification
	EmailUnsubscribeStatus *UnsubscribeEmailRespEmailUnsubscribeStatus `json:"email_unsubscribe_status,omitempty"`

	// Action name of the request made.
	MsgType UnsubscribeEmailRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type UnsubscribeEmailRespEchoReq map[string]interface{}

type UnsubscribeEmailRespEmailUnsubscribeStatus int

type UnsubscribeEmailRespMsgType string

const UnsubscribeEmailRespMsgTypeUnsubscribeEmail UnsubscribeEmailRespMsgType = "unsubscribe_email"

type UnsubscribeEmailUnsubscribeEmail int

// Verify an email address for various purposes. The system will send an email to
// the address containing a security code for verification.
type VerifyEmail struct {
	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough VerifyEmailPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// Purpose of email verification, request_email and reset_password are the only
	// two types restricted from all unoffical apps
	Type VerifyEmailType `json:"type"`

	// [Optional] Extra parameters that can be attached to the verify email link URL.
	UrlParameters *VerifyEmailUrlParameters `json:"url_parameters,omitempty"`

	// Email address to be verified.
	VerifyEmail string `json:"verify_email"`
}

// Verify an email address for Cellxpert. The system will send an email to the
// address containing a security code for verification.
type VerifyEmailCellxpert struct {
	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough VerifyEmailCellxpertPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// Purpose of the email verification call.
	Type VerifyEmailCellxpertType `json:"type"`

	// [Optional] Extra parameters that can be attached to the verify email link URL.
	UrlParameters *VerifyEmailCellxpertUrlParameters `json:"url_parameters,omitempty"`

	// Email address to be verified.
	VerifyEmailCellxpert string `json:"verify_email_cellxpert"`
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type VerifyEmailCellxpertPassthrough map[string]interface{}

// Verify Email Cellxpert Receive
type VerifyEmailCellxpertResp struct {
	// Echo of the request made.
	EchoReq VerifyEmailCellxpertRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType VerifyEmailCellxpertRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// 1 for success (secure code has been sent to the email address)
	VerifyEmailCellxpert *VerifyEmailCellxpertRespVerifyEmailCellxpert `json:"verify_email_cellxpert,omitempty"`
}

// Echo of the request made.
type VerifyEmailCellxpertRespEchoReq map[string]interface{}

type VerifyEmailCellxpertRespMsgType string

const VerifyEmailCellxpertRespMsgTypeVerifyEmailCellxpert VerifyEmailCellxpertRespMsgType = "verify_email_cellxpert"

type VerifyEmailCellxpertRespVerifyEmailCellxpert int

type VerifyEmailCellxpertType string

const VerifyEmailCellxpertTypePartnerAccountOpening VerifyEmailCellxpertType = "partner_account_opening"

// [Optional] Extra parameters that can be attached to the verify email link URL.
type VerifyEmailCellxpertUrlParameters struct {
	// [Optional] Affiliate token, within 32 characters.
	AffiliateToken *string `json:"affiliate_token,omitempty"`

	// [Optional] Master affiliate Id.
	Bta *int `json:"bta,omitempty"`

	// [Optional] Date of first contact, format: yyyy-mm-dd in GMT timezone.
	DateFirstContact *string `json:"date_first_contact,omitempty"`

	// [Optional] Google Click Identifier to track source.
	GclidUrl *string `json:"gclid_url,omitempty"`

	// [Optional] The amount to withdraw to the payment agent. Only allowed for
	// payment agent withdraw.
	PaAmount *float64 `json:"pa_amount,omitempty"`

	// [Optional] The currency code. Only allowed for payment agent withdraw.
	PaCurrency *string `json:"pa_currency,omitempty"`

	// [Optional] The payment agent loginid received from the `paymentagent_list`
	// call. Only allowed for payment agent withdraw.
	PaLoginid *string `json:"pa_loginid,omitempty"`

	// [Optional] Remarks about the withdraw. Only letters, numbers, space, period,
	// comma, - ' are allowed. Only allowed for payment agent withdraw.
	PaRemarks *string `json:"pa_remarks,omitempty"`

	// [Optional] The page ID to redirect to
	RedirectTo *int `json:"redirect_to,omitempty"`

	// [Optional] Show whether user has used mobile or desktop.
	SignupDevice *VerifyEmailCellxpertUrlParametersSignupDevice `json:"signup_device,omitempty"`

	// [Optional] Identifier of particular ad. Value must match Regex pattern to be
	// recorded
	UtmAdId interface{} `json:"utm_ad_id,omitempty"`

	// [Optional] Identifier of ad group in the campaign. Value must match Regex
	// pattern to be recorded
	UtmAdgroupId interface{} `json:"utm_adgroup_id,omitempty"`

	// [Optional] Unique identifier of click on AdRoll ads platform. Value must match
	// Regex pattern to be recorded
	UtmAdrollclkId interface{} `json:"utm_adrollclk_id,omitempty"`

	// [Optional] Identifies a specific product promotion or strategic campaign such
	// as a spring sale or other promotions. Value must match Regex pattern to be
	// recorded
	UtmCampaign interface{} `json:"utm_campaign,omitempty"`

	// [Optional] Identifier of paid ad campaign. Value must match Regex pattern to be
	// recorded
	UtmCampaignId interface{} `json:"utm_campaign_id,omitempty"`

	// [Optional] Used to differentiate similar content, or links within the same ad.
	// Value must match Regex pattern to be recorded
	UtmContent interface{} `json:"utm_content,omitempty"`

	// [Optional] Unique identifier of click on Facebook ads platform. Value must
	// match Regex pattern to be recorded
	UtmFbclId interface{} `json:"utm_fbcl_id,omitempty"`

	// [Optional] Unique visitor identifier on Google Ads platform. Value must match
	// Regex pattern to be recorded
	UtmGlClientId interface{} `json:"utm_gl_client_id,omitempty"`

	// [Optional] Identifies the medium the link was used upon such as: email, CPC, or
	// other methods of sharing. Value must match Regex pattern to be recorded
	UtmMedium interface{} `json:"utm_medium,omitempty"`

	// [Optional] Unique click identifier on Microsoft Bing ads platform. Value must
	// match Regex pattern to be recorded
	UtmMsclkId interface{} `json:"utm_msclk_id,omitempty"`

	// [Optional] Identifies the source of traffic such as: search engine, newsletter,
	// or other referral. Value must match Regex pattern to be recorded
	UtmSource interface{} `json:"utm_source,omitempty"`

	// [Optional] Used to send information related to the campaign term like paid
	// search keywords. Value must match Regex pattern to be recorded
	UtmTerm interface{} `json:"utm_term,omitempty"`
}

type VerifyEmailCellxpertUrlParametersSignupDevice string

const VerifyEmailCellxpertUrlParametersSignupDeviceDesktop VerifyEmailCellxpertUrlParametersSignupDevice = "desktop"
const VerifyEmailCellxpertUrlParametersSignupDeviceMobile VerifyEmailCellxpertUrlParametersSignupDevice = "mobile"

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type VerifyEmailPassthrough map[string]interface{}

// Verify Email Receive
type VerifyEmailResp struct {
	// Echo of the request made.
	EchoReq VerifyEmailRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType VerifyEmailRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// 1 for success (secure code has been sent to the email address)
	VerifyEmail *VerifyEmailRespVerifyEmail `json:"verify_email,omitempty"`
}

// Echo of the request made.
type VerifyEmailRespEchoReq map[string]interface{}

type VerifyEmailRespMsgType string

const VerifyEmailRespMsgTypeVerifyEmail VerifyEmailRespMsgType = "verify_email"

type VerifyEmailRespVerifyEmail int

type VerifyEmailType string

const VerifyEmailTypeAccountOpening VerifyEmailType = "account_opening"
const VerifyEmailTypePartnerAccountOpening VerifyEmailType = "partner_account_opening"
const VerifyEmailTypePaymentWithdraw VerifyEmailType = "payment_withdraw"
const VerifyEmailTypePaymentagentWithdraw VerifyEmailType = "paymentagent_withdraw"
const VerifyEmailTypeRequestEmail VerifyEmailType = "request_email"
const VerifyEmailTypeResetPassword VerifyEmailType = "reset_password"
const VerifyEmailTypeTradingPlatformDxtradePasswordReset VerifyEmailType = "trading_platform_dxtrade_password_reset"
const VerifyEmailTypeTradingPlatformInvestorPasswordReset VerifyEmailType = "trading_platform_investor_password_reset"
const VerifyEmailTypeTradingPlatformMt5PasswordReset VerifyEmailType = "trading_platform_mt5_password_reset"
const VerifyEmailTypeTradingPlatformPasswordReset VerifyEmailType = "trading_platform_password_reset"

// [Optional] Extra parameters that can be attached to the verify email link URL.
type VerifyEmailUrlParameters struct {
	// [Optional] Affiliate token, within 32 characters.
	AffiliateToken *string `json:"affiliate_token,omitempty"`

	// [Optional] Date of first contact, format: yyyy-mm-dd in GMT timezone.
	DateFirstContact *string `json:"date_first_contact,omitempty"`

	// [Optional] Google Click Identifier to track source.
	GclidUrl *string `json:"gclid_url,omitempty"`

	// [Optional] The amount to withdraw to the payment agent. Only allowed for
	// payment agent withdraw.
	PaAmount *float64 `json:"pa_amount,omitempty"`

	// [Optional] The currency code. Only allowed for payment agent withdraw.
	PaCurrency *string `json:"pa_currency,omitempty"`

	// [Optional] The payment agent loginid received from the `paymentagent_list`
	// call. Only allowed for payment agent withdraw.
	PaLoginid *string `json:"pa_loginid,omitempty"`

	// [Optional] Remarks about the withdraw. Only letters, numbers, space, period,
	// comma, - ' are allowed. Only allowed for payment agent withdraw.
	PaRemarks *string `json:"pa_remarks,omitempty"`

	// [Optional] The page ID to redirect to
	RedirectTo *int `json:"redirect_to,omitempty"`

	// [Optional] Show whether user has used mobile or desktop.
	SignupDevice *VerifyEmailUrlParametersSignupDevice `json:"signup_device,omitempty"`

	// [Optional] Identifier of particular ad. Value must match Regex pattern to be
	// recorded
	UtmAdId interface{} `json:"utm_ad_id,omitempty"`

	// [Optional] Identifier of ad group in the campaign. Value must match Regex
	// pattern to be recorded
	UtmAdgroupId interface{} `json:"utm_adgroup_id,omitempty"`

	// [Optional] Unique identifier of click on AdRoll ads platform. Value must match
	// Regex pattern to be recorded
	UtmAdrollclkId interface{} `json:"utm_adrollclk_id,omitempty"`

	// [Optional] Identifies a specific product promotion or strategic campaign such
	// as a spring sale or other promotions. Value must match Regex pattern to be
	// recorded
	UtmCampaign interface{} `json:"utm_campaign,omitempty"`

	// [Optional] Identifier of paid ad campaign. Value must match Regex pattern to be
	// recorded
	UtmCampaignId interface{} `json:"utm_campaign_id,omitempty"`

	// [Optional] Used to differentiate similar content, or links within the same ad.
	// Value must match Regex pattern to be recorded
	UtmContent interface{} `json:"utm_content,omitempty"`

	// [Optional] Unique identifier of click on Facebook ads platform. Value must
	// match Regex pattern to be recorded
	UtmFbclId interface{} `json:"utm_fbcl_id,omitempty"`

	// [Optional] Unique visitor identifier on Google Ads platform. Value must match
	// Regex pattern to be recorded
	UtmGlClientId interface{} `json:"utm_gl_client_id,omitempty"`

	// [Optional] Identifies the medium the link was used upon such as: email, CPC, or
	// other methods of sharing. Value must match Regex pattern to be recorded
	UtmMedium interface{} `json:"utm_medium,omitempty"`

	// [Optional] Unique click identifier on Microsoft Bing ads platform. Value must
	// match Regex pattern to be recorded
	UtmMsclkId interface{} `json:"utm_msclk_id,omitempty"`

	// [Optional] Identifies the source of traffic such as: search engine, newsletter,
	// or other referral. Value must match Regex pattern to be recorded
	UtmSource interface{} `json:"utm_source,omitempty"`

	// [Optional] Used to send information related to the campaign term like paid
	// search keywords. Value must match Regex pattern to be recorded
	UtmTerm interface{} `json:"utm_term,omitempty"`
}

type VerifyEmailUrlParametersSignupDevice string

const VerifyEmailUrlParametersSignupDeviceDesktop VerifyEmailUrlParametersSignupDevice = "desktop"
const VerifyEmailUrlParametersSignupDeviceMobile VerifyEmailUrlParametersSignupDevice = "mobile"

// Request server status.
type WebsiteStatus struct {
	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough WebsiteStatusPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// [Optional] `1` to stream the server/website status updates.
	Subscribe *WebsiteStatusSubscribe `json:"subscribe,omitempty"`

	// Must be `1`
	WebsiteStatus WebsiteStatusWebsiteStatus `json:"website_status"`
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type WebsiteStatusPassthrough map[string]interface{}

// Server status alongside general settings like call limits, currencies
// information, supported languages, etc.
type WebsiteStatusResp struct {
	// Echo of the request made.
	EchoReq WebsiteStatusRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType WebsiteStatusRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// For subscription requests only.
	Subscription *WebsiteStatusRespSubscription `json:"subscription,omitempty"`

	// Server status and other information regarding general settings
	WebsiteStatus *WebsiteStatusRespWebsiteStatus `json:"website_status,omitempty"`
}

// Echo of the request made.
type WebsiteStatusRespEchoReq map[string]interface{}

type WebsiteStatusRespMsgType string

const WebsiteStatusRespMsgTypeWebsiteStatus WebsiteStatusRespMsgType = "website_status"

// For subscription requests only.
type WebsiteStatusRespSubscription struct {
	// A per-connection unique identifier. Can be passed to the `forget` API call to
	// unsubscribe.
	Id string `json:"id"`
}

// Server status and other information regarding general settings
type WebsiteStatusRespWebsiteStatus struct {
	// Maximum number of API calls during specified period of time.
	ApiCallLimits WebsiteStatusRespWebsiteStatusApiCallLimits `json:"api_call_limits"`

	// List of all available broker codes.
	BrokerCodes []string `json:"broker_codes,omitempty"`

	// Country code of connected IP
	ClientsCountry *string `json:"clients_country,omitempty"`

	// Available currencies and their information
	CurrenciesConfig WebsiteStatusRespWebsiteStatusCurrenciesConfig `json:"currencies_config"`

	// Suspension status of Dxtrade/DerivX API calls
	DxtradeStatus *WebsiteStatusRespWebsiteStatusDxtradeStatus `json:"dxtrade_status,omitempty"`

	// Text for site status banner, contains problem description. shown only if set by
	// the system.
	Message *string `json:"message,omitempty"`

	// Suspension status of MT5 API calls
	Mt5Status *WebsiteStatusRespWebsiteStatusMt5Status `json:"mt5_status,omitempty"`

	// Peer-to-peer payment system settings.
	P2PConfig *WebsiteStatusRespWebsiteStatusP2PConfig `json:"p2p_config,omitempty"`

	// Payments Agents system settings.
	PaymentAgents *WebsiteStatusRespWebsiteStatusPaymentAgents `json:"payment_agents,omitempty"`

	// The current status of the website.
	SiteStatus *WebsiteStatusRespWebsiteStatusSiteStatus `json:"site_status,omitempty"`

	// Provides codes for languages supported.
	SupportedLanguages []string `json:"supported_languages,omitempty"`

	// Latest terms and conditions version.
	TermsConditionsVersion *string `json:"terms_conditions_version,omitempty"`
}

// Maximum number of API calls during specified period of time.
type WebsiteStatusRespWebsiteStatusApiCallLimits struct {
	// Maximum subscription to proposal calls.
	MaxProposalSubscription WebsiteStatusRespWebsiteStatusApiCallLimitsMaxProposalSubscription `json:"max_proposal_subscription"`

	// Maximum number of general requests allowed during specified period of time.
	MaxRequestesGeneral WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestesGeneral `json:"max_requestes_general"`

	// Maximum number of outcome requests allowed during specified period of time.
	MaxRequestsOutcome WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestsOutcome `json:"max_requests_outcome"`

	// Maximum number of pricing requests allowed during specified period of time.
	MaxRequestsPricing WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestsPricing `json:"max_requests_pricing"`
}

// Maximum subscription to proposal calls.
type WebsiteStatusRespWebsiteStatusApiCallLimitsMaxProposalSubscription struct {
	// Describes which calls this limit applies to.
	AppliesTo string `json:"applies_to"`

	// Maximum number of allowed calls.
	Max float64 `json:"max"`
}

// Maximum number of general requests allowed during specified period of time.
type WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestesGeneral struct {
	// Describes which calls this limit applies to.
	AppliesTo string `json:"applies_to"`

	// The maximum of allowed calls per hour.
	Hourly float64 `json:"hourly"`

	// The maximum of allowed calls per minute.
	Minutely float64 `json:"minutely"`
}

// Maximum number of outcome requests allowed during specified period of time.
type WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestsOutcome struct {
	// Describes which calls this limit applies to.
	AppliesTo string `json:"applies_to"`

	// The maximum of allowed calls per hour.
	Hourly float64 `json:"hourly"`

	// The maximum of allowed calls per minute.
	Minutely float64 `json:"minutely"`
}

// Maximum number of pricing requests allowed during specified period of time.
type WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestsPricing struct {
	// Describes which calls this limit applies to.
	AppliesTo string `json:"applies_to"`

	// The maximum of allowed calls per hour.
	Hourly float64 `json:"hourly"`

	// The maximum of allowed calls per minute.
	Minutely float64 `json:"minutely"`
}

// Available currencies and their information
type WebsiteStatusRespWebsiteStatusCurrenciesConfig map[string]interface{}

// Suspension status of Dxtrade/DerivX API calls
type WebsiteStatusRespWebsiteStatusDxtradeStatus struct {
	// Suspension of Dxtrade/DerivX API calls on all servers.
	All *int `json:"all,omitempty"`

	// Suspension of Dxtrade/DerivX API calls on demo servers.
	Demo *int `json:"demo,omitempty"`

	// Suspension of Dxtrade/DerivX API calls on real trading servers.
	Real *int `json:"real,omitempty"`
}

// Suspension status of MT5 API calls
type WebsiteStatusRespWebsiteStatusMt5Status struct {
	// Suspension of MT5 API calls on demo servers.
	Demo []interface{} `json:"demo,omitempty"`

	// Suspension of MT5 API calls on real trading servers.
	Real []interface{} `json:"real,omitempty"`
}

// Peer-to-peer payment system settings.
type WebsiteStatusRespWebsiteStatusP2PConfig struct {
	// Maximum number of active ads allowed by an advertiser per currency pair and
	// advert type (buy or sell).
	AdvertsActiveLimit int `json:"adverts_active_limit"`

	// Adverts will be deactivated if no activity occurs within this period, in days.
	AdvertsArchivePeriod *int `json:"adverts_archive_period,omitempty"`

	// Block trading settings
	BlockTrade WebsiteStatusRespWebsiteStatusP2PConfigBlockTrade `json:"block_trade"`

	// A buyer will be blocked for this duration after exceeding the cancellation
	// limit, in hours.
	CancellationBlockDuration int `json:"cancellation_block_duration"`

	// The period within which to count buyer cancellations, in hours.
	CancellationCountPeriod int `json:"cancellation_count_period"`

	// A buyer may cancel an order within this period without negative consequences,
	// in minutes after order creation.
	CancellationGracePeriod int `json:"cancellation_grace_period"`

	// A buyer will be temporarily barred after marking this number of cancellations
	// within cancellation_period.
	CancellationLimit int `json:"cancellation_limit"`

	// When 0, only exchanges in local currency are allowed for P2P advertiser.
	CrossBorderAdsEnabled WebsiteStatusRespWebsiteStatusP2PConfigCrossBorderAdsEnabled `json:"cross_border_ads_enabled"`

	// When 1, the P2P service is unavailable.
	Disabled WebsiteStatusRespWebsiteStatusP2PConfigDisabled `json:"disabled"`

	// Indicates the availbility of certain backend features.
	FeatureLevel int `json:"feature_level"`

	// Availability of fixed rate adverts.
	FixedRateAdverts WebsiteStatusRespWebsiteStatusP2PConfigFixedRateAdverts `json:"fixed_rate_adverts"`

	// Date on which fixed rate adverts will be deactivated.
	FixedRateAdvertsEndDate *string `json:"fixed_rate_adverts_end_date,omitempty"`

	// Availability of floating rate adverts.
	FloatRateAdverts WebsiteStatusRespWebsiteStatusP2PConfigFloatRateAdverts `json:"float_rate_adverts"`

	// Maximum rate offset for floating rate adverts.
	FloatRateOffsetLimit float64 `json:"float_rate_offset_limit"`

	// Available local currencies for p2p_advert_list request.
	LocalCurrencies []WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElem `json:"local_currencies"`

	// Maximum amount of an advert, in USD.
	MaximumAdvertAmount float64 `json:"maximum_advert_amount"`

	// Maximum amount of an order, in USD.
	MaximumOrderAmount float64 `json:"maximum_order_amount"`

	// Maximum number of orders a user may create per day.
	OrderDailyLimit int `json:"order_daily_limit"`

	// Time allowed for order payment, in minutes after order creation.
	OrderPaymentPeriod int `json:"order_payment_period"`

	// Local P2P exchange rate which should be used instead of those obtained from the
	// `exchange_rates` call.
	OverrideExchangeRate *string `json:"override_exchange_rate,omitempty"`

	// Indicates if the payment methods feature is enabled.
	PaymentMethodsEnabled WebsiteStatusRespWebsiteStatusP2PConfigPaymentMethodsEnabled `json:"payment_methods_enabled"`

	// Time after successful order completion during which reviews can be created, in
	// hours.
	ReviewPeriod float64 `json:"review_period"`

	// List of currencies for which P2P is available
	SupportedCurrencies []string `json:"supported_currencies"`
}

// Block trading settings
type WebsiteStatusRespWebsiteStatusP2PConfigBlockTrade struct {
	// When 1, Block trading is unavailable.
	Disabled *WebsiteStatusRespWebsiteStatusP2PConfigBlockTradeDisabled `json:"disabled,omitempty"`

	// Maximum amount of a block trade advert, in USD.
	MaximumAdvertAmount *float64 `json:"maximum_advert_amount,omitempty"`
}

type WebsiteStatusRespWebsiteStatusP2PConfigBlockTradeDisabled int

type WebsiteStatusRespWebsiteStatusP2PConfigCrossBorderAdsEnabled int

type WebsiteStatusRespWebsiteStatusP2PConfigDisabled int

type WebsiteStatusRespWebsiteStatusP2PConfigFixedRateAdverts string

const WebsiteStatusRespWebsiteStatusP2PConfigFixedRateAdvertsDisabled WebsiteStatusRespWebsiteStatusP2PConfigFixedRateAdverts = "disabled"
const WebsiteStatusRespWebsiteStatusP2PConfigFixedRateAdvertsEnabled WebsiteStatusRespWebsiteStatusP2PConfigFixedRateAdverts = "enabled"
const WebsiteStatusRespWebsiteStatusP2PConfigFixedRateAdvertsListOnly WebsiteStatusRespWebsiteStatusP2PConfigFixedRateAdverts = "list_only"

type WebsiteStatusRespWebsiteStatusP2PConfigFloatRateAdverts string

const WebsiteStatusRespWebsiteStatusP2PConfigFloatRateAdvertsDisabled WebsiteStatusRespWebsiteStatusP2PConfigFloatRateAdverts = "disabled"
const WebsiteStatusRespWebsiteStatusP2PConfigFloatRateAdvertsEnabled WebsiteStatusRespWebsiteStatusP2PConfigFloatRateAdverts = "enabled"
const WebsiteStatusRespWebsiteStatusP2PConfigFloatRateAdvertsListOnly WebsiteStatusRespWebsiteStatusP2PConfigFloatRateAdverts = "list_only"

// Local currency details.
type WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElem struct {
	// Local currency name
	DisplayName string `json:"display_name"`

	// Indicates that there are adverts available for this currency.
	HasAdverts WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElemHasAdverts `json:"has_adverts"`

	// Indicates that this is local currency for the current country.
	IsDefault *WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElemIsDefault `json:"is_default,omitempty"`

	// Local currency symbol
	Symbol string `json:"symbol"`
}

type WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElemHasAdverts int

type WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElemIsDefault int

type WebsiteStatusRespWebsiteStatusP2PConfigPaymentMethodsEnabled int

// Payments Agents system settings.
type WebsiteStatusRespWebsiteStatusPaymentAgents struct {
	// Initial deposit requirement per country.
	InitialDepositPerCountry WebsiteStatusRespWebsiteStatusPaymentAgentsInitialDepositPerCountry `json:"initial_deposit_per_country"`
}

// Initial deposit requirement per country.
type WebsiteStatusRespWebsiteStatusPaymentAgentsInitialDepositPerCountry map[string]interface{}

type WebsiteStatusRespWebsiteStatusSiteStatus string

const WebsiteStatusRespWebsiteStatusSiteStatusDown WebsiteStatusRespWebsiteStatusSiteStatus = "down"
const WebsiteStatusRespWebsiteStatusSiteStatusUp WebsiteStatusRespWebsiteStatusSiteStatus = "up"
const WebsiteStatusRespWebsiteStatusSiteStatusUpdating WebsiteStatusRespWebsiteStatusSiteStatus = "updating"

type WebsiteStatusSubscribe int

type WebsiteStatusWebsiteStatus int

var enumValues_ActiveSymbolsActiveSymbols = []interface{}{
	"brief",
	"full",
}
var enumValues_ActiveSymbolsLandingCompany = []interface{}{
	"iom",
	"malta",
	"maltainvest",
	"svg",
	"virtual",
	"vanuatu",
	"champion",
	"champion-virtual",
}
var enumValues_ActiveSymbolsLandingCompanyShort = []interface{}{
	"iom",
	"malta",
	"maltainvest",
	"svg",
	"virtual",
	"vanuatu",
	"champion",
	"champion-virtual",
}
var enumValues_ActiveSymbolsProductType = []interface{}{
	"basic",
}
var enumValues_ActiveSymbolsRespActiveSymbolsElemAllowForwardStarting = []interface{}{
	0,
	1,
}
var enumValues_ActiveSymbolsRespActiveSymbolsElemExchangeIsOpen = []interface{}{
	0,
	1,
}
var enumValues_ActiveSymbolsRespActiveSymbolsElemIsTradingSuspended = []interface{}{
	0,
	1,
}
var enumValues_ActiveSymbolsRespMsgType = []interface{}{
	"active_symbols",
}
var enumValues_ApiTokenApiToken = []interface{}{
	1,
}
var enumValues_ApiTokenNewTokenScopesElem = []interface{}{
	"read",
	"trade",
	"trading_information",
	"payments",
	"admin",
}
var enumValues_ApiTokenRespApiTokenDeleteToken = []interface{}{
	1,
}
var enumValues_ApiTokenRespApiTokenNewToken = []interface{}{
	1,
}
var enumValues_ApiTokenRespApiTokenTokensElemScopesElem = []interface{}{
	"read",
	"trade",
	"trading_information",
	"payments",
	"admin",
}
var enumValues_ApiTokenRespMsgType = []interface{}{
	"api_token",
}
var enumValues_ApiTokenValidForCurrentIpOnly = []interface{}{
	0,
	1,
}
var enumValues_AppDeleteRespMsgType = []interface{}{
	"app_delete",
}
var enumValues_AppGetRespMsgType = []interface{}{
	"app_get",
}
var enumValues_AppListAppList = []interface{}{
	1,
}
var enumValues_AppListRespMsgType = []interface{}{
	"app_list",
}
var enumValues_AppMarkupDetailsAppMarkupDetails = []interface{}{
	1,
}
var enumValues_AppMarkupDetailsDescription = []interface{}{
	0,
	1,
}
var enumValues_AppMarkupDetailsRespMsgType = []interface{}{
	"app_markup_details",
}
var enumValues_AppMarkupDetailsSort = []interface{}{
	"ASC",
	"DESC",
}
var enumValues_AppMarkupDetailsSortFieldsElem = []interface{}{
	"app_id",
	"client_loginid",
	"transaction_time",
}
var enumValues_AppMarkupStatisticsAppMarkupStatistics = []interface{}{
	1,
}
var enumValues_AppMarkupStatisticsRespMsgType = []interface{}{
	"app_markup_statistics",
}
var enumValues_AppRegisterAppRegister = []interface{}{
	1,
}
var enumValues_AppRegisterRespMsgType = []interface{}{
	"app_register",
}
var enumValues_AppRegisterScopesElem = []interface{}{
	"read",
	"trade",
	"trading_information",
	"payments",
	"admin",
}
var enumValues_AppUpdateRespMsgType = []interface{}{
	"app_update",
}
var enumValues_AppUpdateScopesElem = []interface{}{
	"read",
	"trade",
	"trading_information",
	"payments",
	"admin",
}
var enumValues_AssetIndexAssetIndex = []interface{}{
	1,
}
var enumValues_AssetIndexLandingCompany = []interface{}{
	"iom",
	"malta",
	"maltainvest",
	"svg",
	"virtual",
	"vanuatu",
	"champion",
	"champion-virtual",
}
var enumValues_AssetIndexLandingCompanyShort = []interface{}{
	"iom",
	"malta",
	"maltainvest",
	"svg",
	"virtual",
	"vanuatu",
	"champion",
	"champion-virtual",
}
var enumValues_AssetIndexRespMsgType = []interface{}{
	"asset_index",
}
var enumValues_AuthorizeAddToLoginHistory = []interface{}{
	1,
	0,
}
var enumValues_AuthorizeRespAuthorizeAccountListElemAccountCategory = []interface{}{
	"trading",
	"wallet",
}
var enumValues_AuthorizeRespAuthorizeAccountListElemIsDisabled = []interface{}{
	1,
	0,
}
var enumValues_AuthorizeRespAuthorizeAccountListElemIsVirtual = []interface{}{
	1,
	0,
}
var enumValues_AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatform = []interface{}{
	"derivez",
	"dtrade",
	"dwallet",
	"dxtrade",
	"mt5",
}
var enumValues_AuthorizeRespAuthorizeIsVirtual = []interface{}{
	0,
	1,
}
var enumValues_AuthorizeRespAuthorizeLinkedToElemPlatform = []interface{}{
	"derivez",
	"dtrade",
	"dwallet",
	"dxtrade",
	"mt5",
}
var enumValues_AuthorizeRespMsgType = []interface{}{
	"authorize",
}
var enumValues_BalanceBalance = []interface{}{
	1,
}
var enumValues_BalanceRespMsgType = []interface{}{
	"balance",
}
var enumValues_BalanceSubscribe = []interface{}{
	0,
	1,
}
var enumValues_BuyContractForMultipleAccountsParametersBasis = []interface{}{
	"payout",
	"stake",
}
var enumValues_BuyContractForMultipleAccountsParametersContractType = []interface{}{
	"MULTUP",
	"MULTDOWN",
	"UPORDOWN",
	"EXPIRYRANGE",
	"ONETOUCH",
	"CALLE",
	"LBHIGHLOW",
	"ASIAND",
	"EXPIRYRANGEE",
	"DIGITDIFF",
	"DIGITMATCH",
	"DIGITOVER",
	"PUTE",
	"DIGITUNDER",
	"NOTOUCH",
	"CALL",
	"RANGE",
	"LBFLOATPUT",
	"DIGITODD",
	"PUT",
	"ASIANU",
	"LBFLOATCALL",
	"EXPIRYMISSE",
	"EXPIRYMISS",
	"DIGITEVEN",
	"TICKHIGH",
	"TICKLOW",
	"RESETCALL",
	"RESETPUT",
	"CALLSPREAD",
	"PUTSPREAD",
	"RUNHIGH",
	"RUNLOW",
	"VANILLALONGCALL",
	"VANILLALONGPUT",
	"TURBOSLONG",
	"TURBOSSHORT",
}
var enumValues_BuyContractForMultipleAccountsParametersDurationUnit = []interface{}{
	"d",
	"m",
	"s",
	"h",
	"t",
}
var enumValues_BuyContractForMultipleAccountsRespMsgType = []interface{}{
	"buy_contract_for_multiple_accounts",
}
var enumValues_BuyParametersBarrierRange = []interface{}{
	"tight",
	"middle",
	"wide",
}
var enumValues_BuyParametersBasis = []interface{}{
	"payout",
	"stake",
}
var enumValues_BuyParametersContractType = []interface{}{
	"MULTUP",
	"MULTDOWN",
	"UPORDOWN",
	"EXPIRYRANGE",
	"ONETOUCH",
	"CALLE",
	"LBHIGHLOW",
	"ASIAND",
	"EXPIRYRANGEE",
	"DIGITDIFF",
	"DIGITMATCH",
	"DIGITOVER",
	"PUTE",
	"DIGITUNDER",
	"NOTOUCH",
	"CALL",
	"RANGE",
	"LBFLOATPUT",
	"DIGITODD",
	"PUT",
	"ASIANU",
	"LBFLOATCALL",
	"EXPIRYMISSE",
	"EXPIRYMISS",
	"DIGITEVEN",
	"TICKHIGH",
	"TICKLOW",
	"RESETCALL",
	"RESETPUT",
	"CALLSPREAD",
	"PUTSPREAD",
	"RUNHIGH",
	"RUNLOW",
	"ACCU",
	"VANILLALONGCALL",
	"VANILLALONGPUT",
	"TURBOSLONG",
	"TURBOSSHORT",
}
var enumValues_BuyParametersDurationUnit = []interface{}{
	"d",
	"m",
	"s",
	"h",
	"t",
}
var enumValues_BuyParametersProductType = []interface{}{
	"basic",
}
var enumValues_BuyRespMsgType = []interface{}{
	"buy",
}
var enumValues_BuySubscribe = []interface{}{
	1,
}
var enumValues_CancelRespMsgType = []interface{}{
	"cancel",
}
var enumValues_CashierCashier = []interface{}{
	"deposit",
	"withdraw",
}
var enumValues_CashierDryRun = []interface{}{
	0,
	1,
}
var enumValues_CashierProvider = []interface{}{
	"doughflow",
	"crypto",
}
var enumValues_CashierRespMsgType = []interface{}{
	"cashier",
}
var enumValues_CashierType = []interface{}{
	"url",
	"api",
}
var enumValues_ContractUpdateContractUpdate = []interface{}{
	1,
}
var enumValues_ContractUpdateHistoryContractUpdateHistory = []interface{}{
	1,
}
var enumValues_ContractUpdateHistoryRespMsgType = []interface{}{
	"contract_update_history",
}
var enumValues_ContractUpdateRespMsgType = []interface{}{
	"contract_update",
}
var enumValues_ContractsForLandingCompany = []interface{}{
	"iom",
	"malta",
	"maltainvest",
	"svg",
	"virtual",
	"vanuatu",
	"champion",
	"champion-virtual",
}
var enumValues_ContractsForLandingCompanyShort = []interface{}{
	"iom",
	"malta",
	"maltainvest",
	"svg",
	"virtual",
	"vanuatu",
	"champion",
	"champion-virtual",
}
var enumValues_ContractsForProductType = []interface{}{
	"basic",
}
var enumValues_ContractsForRespMsgType = []interface{}{
	"contracts_for",
}
var enumValues_CopyStartRespMsgType = []interface{}{
	"copy_start",
}
var enumValues_CopyStopRespMsgType = []interface{}{
	"copy_stop",
}
var enumValues_CopytradingListCopytradingList = []interface{}{
	1,
}
var enumValues_CopytradingListRespMsgType = []interface{}{
	"copytrading_list",
}
var enumValues_CopytradingStatisticsCopytradingStatistics = []interface{}{
	1,
}
var enumValues_CopytradingStatisticsRespMsgType = []interface{}{
	"copytrading_statistics",
}
var enumValues_CryptoConfigCryptoConfig = []interface{}{
	1,
}
var enumValues_CryptoConfigRespMsgType = []interface{}{
	"crypto_config",
}
var enumValues_DocumentUploadDocumentFormat = []interface{}{
	"PNG",
	"JPG",
	"JPEG",
	"GIF",
	"PDF",
}
var enumValues_DocumentUploadDocumentType = []interface{}{
	"passport",
	"national_identity_card",
	"driving_licence",
	"utility_bill",
	"bankstatement",
	"power_of_attorney",
	"amlglobalcheck",
	"docverification",
	"proofid",
	"driverslicense",
	"proofaddress",
	"other",
	"voter_card",
	"student_card",
	"nimc_slip",
	"birth_certificate",
	"pan_card",
	"tax_photo_id",
	"selfie_with_id",
	"poi_others",
	"insurance_bill",
	"tax_receipt",
	"phone_bill",
	"poa_others",
	"proof_of_ownership",
	"tax_return",
	"employment_contract",
	"brokerage statement",
	"payslip",
	"edd_others",
	"coi",
	"business_poa",
	"article_of_association",
	"memorandum",
	"authorisation_letter",
	"declarations",
	"business_documents_others",
}
var enumValues_DocumentUploadDocumentUpload = []interface{}{
	1,
}
var enumValues_DocumentUploadLifetimeValid = []interface{}{
	0,
	1,
}
var enumValues_DocumentUploadPageType = []interface{}{
	"front",
	"back",
	"photo",
}
var enumValues_DocumentUploadRespMsgType = []interface{}{
	"document_upload",
}
var enumValues_EconomicCalendarEconomicCalendar = []interface{}{
	1,
}
var enumValues_EconomicCalendarRespMsgType = []interface{}{
	"economic_calendar",
}
var enumValues_ExchangeRatesExchangeRates = []interface{}{
	1,
}
var enumValues_ExchangeRatesRespMsgType = []interface{}{
	"exchange_rates",
}
var enumValues_ExchangeRatesSubscribe = []interface{}{
	1,
}
var enumValues_ForgetAllRespMsgType = []interface{}{
	"forget_all",
}
var enumValues_ForgetRespForget = []interface{}{
	0,
	1,
}
var enumValues_ForgetRespMsgType = []interface{}{
	"forget",
}
var enumValues_GetAccountStatusGetAccountStatus = []interface{}{
	1,
}
var enumValues_GetAccountStatusRespGetAccountStatusAuthenticationAttemptsHistoryElemStatus = []interface{}{
	"verified",
	"rejected",
	"pending",
	"expired",
	"none",
}
var enumValues_GetAccountStatusRespGetAccountStatusAuthenticationDocumentStatus = []interface{}{
	"none",
	"pending",
	"rejected",
	"verified",
	"expired",
	"suspected",
}
var enumValues_GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesIdvStatus = []interface{}{
	"none",
	"pending",
	"rejected",
	"verified",
	"expired",
}
var enumValues_GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesManualStatus = []interface{}{
	"none",
	"pending",
	"rejected",
	"verified",
	"expired",
	"suspected",
}
var enumValues_GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesOnfidoIsCountrySupported = []interface{}{
	1,
	0,
}
var enumValues_GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesOnfidoStatus = []interface{}{
	"none",
	"pending",
	"rejected",
	"verified",
	"expired",
	"suspected",
}
var enumValues_GetAccountStatusRespGetAccountStatusAuthenticationIdentityStatus = []interface{}{
	"none",
	"pending",
	"rejected",
	"verified",
	"expired",
	"suspected",
}
var enumValues_GetAccountStatusRespGetAccountStatusAuthenticationIncomeStatus = []interface{}{
	"none",
	"pending",
	"rejected",
	"verified",
	"locked",
}
var enumValues_GetAccountStatusRespGetAccountStatusAuthenticationOwnershipStatus = []interface{}{
	"none",
	"pending",
	"rejected",
	"verified",
}
var enumValues_GetAccountStatusRespGetAccountStatusP2PStatus = []interface{}{
	"none",
	"active",
	"temp_ban",
	"perm_ban",
}
var enumValues_GetAccountStatusRespGetAccountStatusPromptClientToAuthenticate = []interface{}{
	1,
	0,
}
var enumValues_GetAccountStatusRespGetAccountStatusSocialIdentityProvider = []interface{}{
	"google",
	"facebook",
	"apple",
}
var enumValues_GetAccountStatusRespMsgType = []interface{}{
	"get_account_status",
}
var enumValues_GetFinancialAssessmentGetFinancialAssessment = []interface{}{
	1,
}
var enumValues_GetFinancialAssessmentRespMsgType = []interface{}{
	"get_financial_assessment",
}
var enumValues_GetLimitsGetLimits = []interface{}{
	1,
}
var enumValues_GetLimitsRespMsgType = []interface{}{
	"get_limits",
}
var enumValues_GetSelfExclusionGetSelfExclusion = []interface{}{
	1,
}
var enumValues_GetSelfExclusionRespMsgType = []interface{}{
	"get_self_exclusion",
}
var enumValues_GetSettingsGetSettings = []interface{}{
	1,
}
var enumValues_GetSettingsRespGetSettingsAllowCopiers = []interface{}{
	0,
	1,
}
var enumValues_GetSettingsRespGetSettingsDxtradeUserException = []interface{}{
	0,
	1,
}
var enumValues_GetSettingsRespGetSettingsEmailConsent = []interface{}{
	0,
	1,
}
var enumValues_GetSettingsRespGetSettingsEmploymentStatus = []interface{}{
	"Employed",
	"Pensioner",
	"Self-Employed",
	"Student",
	"Unemployed",
}
var enumValues_GetSettingsRespGetSettingsFeatureFlagWallet = []interface{}{
	0,
	1,
}
var enumValues_GetSettingsRespGetSettingsHasSecretAnswer = []interface{}{
	0,
	1,
}
var enumValues_GetSettingsRespGetSettingsIsAuthenticatedPaymentAgent = []interface{}{
	0,
	1,
}
var enumValues_GetSettingsRespGetSettingsNonPepDeclaration = []interface{}{
	0,
	1,
}
var enumValues_GetSettingsRespGetSettingsRequestProfessionalStatus = []interface{}{
	0,
	1,
}
var enumValues_GetSettingsRespMsgType = []interface{}{
	"get_settings",
}
var enumValues_IdentityVerificationDocumentAddIdentityVerificationDocumentAdd = []interface{}{
	1,
}
var enumValues_IdentityVerificationDocumentAddRespIdentityVerificationDocumentAdd = []interface{}{
	1,
}
var enumValues_IdentityVerificationDocumentAddRespMsgType = []interface{}{
	"identity_verification_document_add",
}
var enumValues_LandingCompanyDetailsLandingCompanyDetails = []interface{}{
	"iom",
	"malta",
	"maltainvest",
	"svg",
	"virtual",
	"vanuatu",
	"champion",
	"champion-virtual",
	"samoa",
	"samoa-virtual",
	"dsl",
	"bvi",
	"labuan",
}
var enumValues_LandingCompanyDetailsRespLandingCompanyDetailsHasRealityCheck = []interface{}{
	0,
	1,
}
var enumValues_LandingCompanyDetailsRespLandingCompanyDetailsSupportProfessionalClient = []interface{}{
	0,
	1,
}
var enumValues_LandingCompanyDetailsRespLandingCompanyDetailsTinNotMandatory = []interface{}{
	0,
	1,
}
var enumValues_LandingCompanyDetailsRespMsgType = []interface{}{
	"landing_company_details",
}
var enumValues_LandingCompanyRespLandingCompanyAddressParseable = []interface{}{
	1,
	0,
}
var enumValues_LandingCompanyRespLandingCompanyAllCompany = []interface{}{
	"svg",
	"none",
}
var enumValues_LandingCompanyRespLandingCompanyCtraderAllStandard = []interface{}{
	"svg",
	"none",
}
var enumValues_LandingCompanyRespLandingCompanyDerivezAllStandard = []interface{}{
	"svg",
	"none",
}
var enumValues_LandingCompanyRespLandingCompanyDxtradeAllCompanyStandardHasRealityCheck = []interface{}{
	0,
	1,
}
var enumValues_LandingCompanyRespLandingCompanyDxtradeAllCompanyStandardSupportProfessionalClient = []interface{}{
	0,
	1,
}
var enumValues_LandingCompanyRespLandingCompanyDxtradeAllCompanyStandardTinNotMandatory = []interface{}{
	0,
	1,
}
var enumValues_LandingCompanyRespLandingCompanyDxtradeFinancialCompanyStandardHasRealityCheck = []interface{}{
	0,
	1,
}
var enumValues_LandingCompanyRespLandingCompanyDxtradeFinancialCompanyStandardSupportProfessionalClient = []interface{}{
	0,
	1,
}
var enumValues_LandingCompanyRespLandingCompanyDxtradeFinancialCompanyStandardTinNotMandatory = []interface{}{
	0,
	1,
}
var enumValues_LandingCompanyRespLandingCompanyDxtradeGamingCompanyStandardHasRealityCheck = []interface{}{
	0,
	1,
}
var enumValues_LandingCompanyRespLandingCompanyDxtradeGamingCompanyStandardSupportProfessionalClient = []interface{}{
	0,
	1,
}
var enumValues_LandingCompanyRespLandingCompanyDxtradeGamingCompanyStandardTinNotMandatory = []interface{}{
	0,
	1,
}
var enumValues_LandingCompanyRespLandingCompanyIsIdvSupported = []interface{}{
	1,
	0,
}
var enumValues_LandingCompanyRespLandingCompanyMt5AgeVerification = []interface{}{
	1,
	0,
}
var enumValues_LandingCompanyRespLandingCompanyNeedSetMaxTurnoverLimit = []interface{}{
	0,
	1,
}
var enumValues_LandingCompanyRespLandingCompanyNoProvince = []interface{}{
	0,
	1,
}
var enumValues_LandingCompanyRespLandingCompanyRequireAddressPostcode = []interface{}{
	0,
	1,
}
var enumValues_LandingCompanyRespLandingCompanyRequireAgeVerifiedForSynthetic = []interface{}{
	0,
	1,
}
var enumValues_LandingCompanyRespLandingCompanyRequirePoi = []interface{}{
	0,
	1,
}
var enumValues_LandingCompanyRespLandingCompanyRequireVerificationWhenNotAgeVerified = []interface{}{
	0,
	1,
}
var enumValues_LandingCompanyRespLandingCompanySkipDepositVerification = []interface{}{
	0,
	1,
}
var enumValues_LandingCompanyRespLandingCompanyUkgcFundsProtection = []interface{}{
	0,
	1,
}
var enumValues_LandingCompanyRespMsgType = []interface{}{
	"landing_company",
}
var enumValues_LoginHistoryLoginHistory = []interface{}{
	1,
}
var enumValues_LoginHistoryRespLoginHistoryElemStatus = []interface{}{
	0,
	1,
}
var enumValues_LoginHistoryRespMsgType = []interface{}{
	"login_history",
}
var enumValues_LogoutLogout = []interface{}{
	1,
}
var enumValues_LogoutRespLogout = []interface{}{
	1,
}
var enumValues_LogoutRespMsgType = []interface{}{
	"logout",
}
var enumValues_Mt5DepositMt5Deposit = []interface{}{
	1,
}
var enumValues_Mt5DepositRespMsgType = []interface{}{
	"mt5_deposit",
}
var enumValues_Mt5GetSettingsMt5GetSettings = []interface{}{
	1,
}
var enumValues_Mt5GetSettingsRespMsgType = []interface{}{
	"mt5_get_settings",
}
var enumValues_Mt5GetSettingsRespMt5GetSettingsAccountType = []interface{}{
	"demo",
	"real",
}
var enumValues_Mt5GetSettingsRespMt5GetSettingsLandingCompanyShort = []interface{}{
	"bvi",
	"labuan",
	"malta",
	"maltainvest",
	"svg",
	"vanuatu",
}
var enumValues_Mt5GetSettingsRespMt5GetSettingsMarketType = []interface{}{
	"financial",
	"synthetic",
}
var enumValues_Mt5GetSettingsRespMt5GetSettingsSubAccountType = []interface{}{
	"financial",
	"financial_stp",
}
var enumValues_Mt5LoginListMt5LoginList = []interface{}{
	1,
}
var enumValues_Mt5LoginListRespMsgType = []interface{}{
	"mt5_login_list",
}
var enumValues_Mt5LoginListRespMt5LoginListElemAccountType = []interface{}{
	"demo",
	"real",
}
var enumValues_Mt5LoginListRespMt5LoginListElemErrorDetailsServerInfoEnvironment = []interface{}{
	"Deriv-Demo",
	"Deriv-Server",
	"Deriv-Server-02",
}
var enumValues_Mt5LoginListRespMt5LoginListElemLandingCompanyShort = []interface{}{
	"bvi",
	"labuan",
	"malta",
	"maltainvest",
	"svg",
	"vanuatu",
	"seychelles",
}
var enumValues_Mt5LoginListRespMt5LoginListElemMarketType = []interface{}{
	"financial",
	"synthetic",
	"all",
}
var enumValues_Mt5LoginListRespMt5LoginListElemServerInfoEnvironment = []interface{}{
	"Deriv-Demo",
	"Deriv-Server",
	"Deriv-Server-02",
}
var enumValues_Mt5LoginListRespMt5LoginListElemSubAccountCategory = []interface{}{
	"",
	"swap_free",
	"swap_free_high_risk",
	"ibt",
	"stp",
}
var enumValues_Mt5LoginListRespMt5LoginListElemSubAccountType = []interface{}{
	"standard",
	"financial",
	"financial_stp",
}
var enumValues_Mt5NewAccountAccountType = []interface{}{
	"demo",
	"gaming",
	"financial",
	"all",
}
var enumValues_Mt5NewAccountDryRun = []interface{}{
	0,
	1,
}
var enumValues_Mt5NewAccountMt5AccountCategory = []interface{}{
	"conventional",
	"swap_free",
}
var enumValues_Mt5NewAccountMt5AccountType = []interface{}{
	"financial",
	"financial_stp",
}
var enumValues_Mt5NewAccountMt5NewAccount = []interface{}{
	1,
}
var enumValues_Mt5NewAccountRespMsgType = []interface{}{
	"mt5_new_account",
}
var enumValues_Mt5NewAccountRespMt5NewAccountAccountType = []interface{}{
	"demo",
	"gaming",
	"financial",
	"all",
}
var enumValues_Mt5NewAccountRespMt5NewAccountMt5AccountCategory = []interface{}{
	"conventional",
	"swap_free",
}
var enumValues_Mt5NewAccountRespMt5NewAccountMt5AccountType = []interface{}{
	"financial",
	"financial_stp",
	"standard",
}
var enumValues_Mt5NewAccountServer = []interface{}{
	"p01_ts01",
	"p01_ts02",
	"p01_ts03",
	"p01_ts04",
	"p02_ts02",
}
var enumValues_Mt5NewAccountSubAccountCategory = []interface{}{
	"swap_free",
	"swap_free_high_risk",
}
var enumValues_Mt5PasswordChangeMt5PasswordChange = []interface{}{
	1,
}
var enumValues_Mt5PasswordChangePasswordType = []interface{}{
	"main",
	"investor",
}
var enumValues_Mt5PasswordChangeRespMsgType = []interface{}{
	"mt5_password_change",
}
var enumValues_Mt5PasswordCheckMt5PasswordCheck = []interface{}{
	1,
}
var enumValues_Mt5PasswordCheckPasswordType = []interface{}{
	"main",
	"investor",
}
var enumValues_Mt5PasswordCheckRespMsgType = []interface{}{
	"mt5_password_check",
}
var enumValues_Mt5PasswordResetMt5PasswordReset = []interface{}{
	1,
}
var enumValues_Mt5PasswordResetPasswordType = []interface{}{
	"main",
	"investor",
}
var enumValues_Mt5PasswordResetRespMsgType = []interface{}{
	"mt5_password_reset",
}
var enumValues_Mt5WithdrawalMt5Withdrawal = []interface{}{
	1,
}
var enumValues_Mt5WithdrawalRespMsgType = []interface{}{
	"mt5_withdrawal",
}
var enumValues_NewAccountMaltainvestAcceptRisk = []interface{}{
	0,
	1,
}
var enumValues_NewAccountMaltainvestAccountOpeningReason = []interface{}{
	"Speculative",
	"Income Earning",
	"Hedging",
}
var enumValues_NewAccountMaltainvestAccountTurnover = []interface{}{
	"Less than $25,000",
	"$25,000 - $50,000",
	"$50,001 - $100,000",
	"$100,001 - $500,000",
	"Over $500,000",
}
var enumValues_NewAccountMaltainvestCfdExperience = []interface{}{
	"No experience",
	"Less than a year",
	"1 - 2 years",
	"Over 3 years",
}
var enumValues_NewAccountMaltainvestCfdFrequency = []interface{}{
	"No transactions in the past 12 months",
	"1 - 5 transactions in the past 12 months",
	"6 - 10 transactions in the past 12 months",
	"11 - 39 transactions in the past 12 months",
	"40 transactions or more in the past 12 months",
}
var enumValues_NewAccountMaltainvestCfdTradingDefinition = []interface{}{
	"Purchase shares of a company or physical commodities.",
	"Place a bet on the price movement.",
	"Speculate on the price movement.",
	"Make a long-term investment.",
}
var enumValues_NewAccountMaltainvestClientType = []interface{}{
	"professional",
	"retail",
}
var enumValues_NewAccountMaltainvestEducationLevel = []interface{}{
	"Primary",
	"Secondary",
	"Tertiary",
}
var enumValues_NewAccountMaltainvestEmploymentIndustry = []interface{}{
	"Construction",
	"Education",
	"Finance",
	"Health",
	"Tourism",
	"Information & Communications Technology",
	"Science & Engineering",
	"Legal",
	"Social & Cultural",
	"Agriculture",
	"Real Estate",
	"Food Services",
	"Manufacturing",
	"Unemployed",
}
var enumValues_NewAccountMaltainvestEmploymentStatus = []interface{}{
	"Employed",
	"Pensioner",
	"Self-Employed",
	"Student",
	"Unemployed",
}
var enumValues_NewAccountMaltainvestEstimatedWorth = []interface{}{
	"Less than $100,000",
	"$100,000 - $250,000",
	"$250,001 - $500,000",
	"$500,001 - $1,000,000",
	"Over $1,000,000",
}
var enumValues_NewAccountMaltainvestIncomeSource = []interface{}{
	"Salaried Employee",
	"Self-Employed",
	"Investments & Dividends",
	"Pension",
	"State Benefits",
	"Savings & Inheritance",
}
var enumValues_NewAccountMaltainvestLeverageImpactTrading = []interface{}{
	"Leverage is a risk mitigation technique.",
	"Leverage prevents you from opening large positions.",
	"Leverage guarantees profits.",
	"Leverage lets you open larger positions for a fraction of the trade's value.",
}
var enumValues_NewAccountMaltainvestLeverageTradingHighRiskStopLoss = []interface{}{
	"Cancel your trade at any time within a chosen timeframe.",
	"Close your trade automatically when the loss is more than or equal to a specific amount.",
	"Close your trade automatically when the profit is more than or equal to a specific amount.",
	"Make a guaranteed profit on your trade.",
}
var enumValues_NewAccountMaltainvestNetIncome = []interface{}{
	"Less than $25,000",
	"$25,000 - $50,000",
	"$50,001 - $100,000",
	"$100,001 - $500,000",
	"Over $500,000",
}
var enumValues_NewAccountMaltainvestNewAccountMaltainvest = []interface{}{
	1,
}
var enumValues_NewAccountMaltainvestOccupation = []interface{}{
	"Chief Executives, Senior Officials and Legislators",
	"Managers",
	"Professionals",
	"Clerks",
	"Personal Care, Sales and Service Workers",
	"Agricultural, Forestry and Fishery Workers",
	"Craft, Metal, Electrical and Electronics Workers",
	"Plant and Machine Operators and Assemblers",
	"Cleaners and Helpers",
	"Mining, Construction, Manufacturing and Transport Workers",
	"Armed Forces",
	"Government Officers",
	"Students",
	"Unemployed",
}
var enumValues_NewAccountMaltainvestRequiredInitialMargin = []interface{}{
	"When opening a Leveraged CFD trade.",
	"When trading Multipliers.",
	"When buying shares of a company.",
	"All of the above.",
}
var enumValues_NewAccountMaltainvestRespMsgType = []interface{}{
	"new_account_maltainvest",
}
var enumValues_NewAccountMaltainvestRiskTolerance = []interface{}{
	"Yes",
	"No",
}
var enumValues_NewAccountMaltainvestSalutation = []interface{}{
	"Mr",
	"Ms",
	"Miss",
	"Mrs",
}
var enumValues_NewAccountMaltainvestSecretQuestion = []interface{}{
	"Mother's maiden name",
	"Name of your pet",
	"Name of first love",
	"Memorable town/city",
	"Memorable date",
	"Favourite dish",
	"Brand of first car",
	"Favourite artist",
}
var enumValues_NewAccountMaltainvestSourceOfExperience = []interface{}{
	"I have an academic degree, professional certification, and/or work experience.",
	"I trade forex CFDs and other complex financial instruments.",
	"I have attended seminars, training, and/or workshops.",
	"I have little experience.",
	"I have no knowledge.",
}
var enumValues_NewAccountMaltainvestSourceOfWealth = []interface{}{
	"Accumulation of Income/Savings",
	"Cash Business",
	"Company Ownership",
	"Divorce Settlement",
	"Inheritance",
	"Investment Income",
	"Sale of Property",
}
var enumValues_NewAccountMaltainvestTradingExperienceFinancialInstruments = []interface{}{
	"No experience",
	"Less than a year",
	"1 - 2 years",
	"Over 3 years",
}
var enumValues_NewAccountMaltainvestTradingFrequencyFinancialInstruments = []interface{}{
	"No transactions in the past 12 months",
	"1 - 5 transactions in the past 12 months",
	"6 - 10 transactions in the past 12 months",
	"11 - 39 transactions in the past 12 months",
	"40 transactions or more in the past 12 months",
}
var enumValues_NewAccountRealAccountOpeningReason = []interface{}{
	"Speculative",
	"Income Earning",
	"Hedging",
	"Peer-to-peer exchange",
}
var enumValues_NewAccountRealAccountTurnover = []interface{}{
	"Less than $25,000",
	"$25,000 - $50,000",
	"$50,001 - $100,000",
	"$100,001 - $500,000",
	"Over $500,000",
}
var enumValues_NewAccountRealClientType = []interface{}{
	"professional",
	"retail",
}
var enumValues_NewAccountRealNewAccountReal = []interface{}{
	1,
}
var enumValues_NewAccountRealRespMsgType = []interface{}{
	"new_account_real",
}
var enumValues_NewAccountRealSalutation = []interface{}{
	"Mr",
	"Ms",
	"Miss",
	"Mrs",
}
var enumValues_NewAccountRealSecretQuestion = []interface{}{
	"Mother's maiden name",
	"Name of your pet",
	"Name of first love",
	"Memorable town/city",
	"Memorable date",
	"Favourite dish",
	"Brand of first car",
	"Favourite artist",
}
var enumValues_NewAccountVirtualEmailConsent = []interface{}{
	1,
	0,
}
var enumValues_NewAccountVirtualNewAccountVirtual = []interface{}{
	1,
}
var enumValues_NewAccountVirtualRespMsgType = []interface{}{
	"new_account_virtual",
}
var enumValues_NewAccountVirtualRespNewAccountVirtualType = []interface{}{
	"trading",
	"wallet",
}
var enumValues_NewAccountVirtualSignupDevice = []interface{}{
	"desktop",
	"mobile",
}
var enumValues_NewAccountVirtualType = []interface{}{
	"trading",
	"wallet",
}
var enumValues_OauthAppsOauthApps = []interface{}{
	1,
}
var enumValues_OauthAppsRespMsgType = []interface{}{
	"oauth_apps",
}
var enumValues_OauthAppsRespOauthAppsElemOfficial = []interface{}{
	1,
	0,
}
var enumValues_P2PAdvertCreateBlockTrade = []interface{}{
	0,
	1,
}
var enumValues_P2PAdvertCreateP2PAdvertCreate = []interface{}{
	1,
}
var enumValues_P2PAdvertCreateRateType = []interface{}{
	"fixed",
	"float",
}
var enumValues_P2PAdvertCreateRespMsgType = []interface{}{
	"p2p_advert_create",
}
var enumValues_P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetailsIsOnline = []interface{}{
	0,
	1,
}
var enumValues_P2PAdvertCreateRespP2PAdvertCreateBlockTrade = []interface{}{
	0,
	1,
}
var enumValues_P2PAdvertCreateRespP2PAdvertCreateCounterpartyType = []interface{}{
	"buy",
	"sell",
}
var enumValues_P2PAdvertCreateRespP2PAdvertCreateIsActive = []interface{}{
	0,
	1,
}
var enumValues_P2PAdvertCreateRespP2PAdvertCreateIsVisible = []interface{}{
	0,
	1,
}
var enumValues_P2PAdvertCreateRespP2PAdvertCreateRateType = []interface{}{
	"fixed",
	"float",
}
var enumValues_P2PAdvertCreateRespP2PAdvertCreateType = []interface{}{
	"buy",
	"sell",
}
var enumValues_P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem = []interface{}{
	"advert_inactive",
	"advert_max_limit",
	"advert_min_limit",
	"advert_remaining",
	"advertiser_ads_paused",
	"advertiser_approval",
	"advertiser_balance",
	"advertiser_block_trade_ineligible",
	"advertiser_daily_limit",
	"advertiser_temp_ban",
}
var enumValues_P2PAdvertCreateType = []interface{}{
	"buy",
	"sell",
}
var enumValues_P2PAdvertInfoP2PAdvertInfo = []interface{}{
	1,
}
var enumValues_P2PAdvertInfoRespMsgType = []interface{}{
	"p2p_advert_info",
}
var enumValues_P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsBlocked = []interface{}{
	0,
	1,
}
var enumValues_P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsFavourite = []interface{}{
	0,
	1,
}
var enumValues_P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsOnline = []interface{}{
	0,
	1,
}
var enumValues_P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsRecommended = []interface{}{
	nil,
	0,
	1,
}
var enumValues_P2PAdvertInfoRespP2PAdvertInfoBlockTrade = []interface{}{
	0,
	1,
}
var enumValues_P2PAdvertInfoRespP2PAdvertInfoCounterpartyType = []interface{}{
	"buy",
	"sell",
}
var enumValues_P2PAdvertInfoRespP2PAdvertInfoDeleted = []interface{}{
	1,
}
var enumValues_P2PAdvertInfoRespP2PAdvertInfoIsActive = []interface{}{
	0,
	1,
}
var enumValues_P2PAdvertInfoRespP2PAdvertInfoIsVisible = []interface{}{
	0,
	1,
}
var enumValues_P2PAdvertInfoRespP2PAdvertInfoRateType = []interface{}{
	"fixed",
	"float",
}
var enumValues_P2PAdvertInfoRespP2PAdvertInfoType = []interface{}{
	"buy",
	"sell",
}
var enumValues_P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem = []interface{}{
	"advert_inactive",
	"advert_max_limit",
	"advert_min_limit",
	"advert_remaining",
	"advertiser_ads_paused",
	"advertiser_approval",
	"advertiser_balance",
	"advertiser_block_trade_ineligible",
	"advertiser_daily_limit",
	"advertiser_temp_ban",
}
var enumValues_P2PAdvertInfoSubscribe = []interface{}{
	1,
}
var enumValues_P2PAdvertInfoUseClientLimits = []interface{}{
	0,
	1,
}
var enumValues_P2PAdvertListBlockTrade = []interface{}{
	0,
	1,
}
var enumValues_P2PAdvertListCounterpartyType = []interface{}{
	"buy",
	"sell",
}
var enumValues_P2PAdvertListFavouritesOnly = []interface{}{
	0,
	1,
}
var enumValues_P2PAdvertListP2PAdvertList = []interface{}{
	1,
}
var enumValues_P2PAdvertListRespMsgType = []interface{}{
	"p2p_advert_list",
}
var enumValues_P2PAdvertListRespP2PAdvertListListElemAdvertiserDetailsIsBlocked = []interface{}{
	0,
}
var enumValues_P2PAdvertListRespP2PAdvertListListElemAdvertiserDetailsIsFavourite = []interface{}{
	0,
	1,
}
var enumValues_P2PAdvertListRespP2PAdvertListListElemAdvertiserDetailsIsOnline = []interface{}{
	0,
	1,
}
var enumValues_P2PAdvertListRespP2PAdvertListListElemAdvertiserDetailsIsRecommended = []interface{}{
	nil,
	0,
	1,
}
var enumValues_P2PAdvertListRespP2PAdvertListListElemBlockTrade = []interface{}{
	0,
	1,
}
var enumValues_P2PAdvertListRespP2PAdvertListListElemCounterpartyType = []interface{}{
	"buy",
	"sell",
}
var enumValues_P2PAdvertListRespP2PAdvertListListElemIsActive = []interface{}{
	0,
	1,
}
var enumValues_P2PAdvertListRespP2PAdvertListListElemIsVisible = []interface{}{
	0,
	1,
}
var enumValues_P2PAdvertListRespP2PAdvertListListElemRateType = []interface{}{
	"fixed",
	"float",
}
var enumValues_P2PAdvertListRespP2PAdvertListListElemType = []interface{}{
	"buy",
	"sell",
}
var enumValues_P2PAdvertListRespP2PAdvertListListElemVisibilityStatusElem = []interface{}{
	"advert_inactive",
	"advert_max_limit",
	"advert_min_limit",
	"advert_remaining",
	"advertiser_ads_paused",
	"advertiser_approval",
	"advertiser_balance",
	"advertiser_block_trade_ineligible",
	"advertiser_daily_limit",
	"advertiser_temp_ban",
}
var enumValues_P2PAdvertListSortBy = []interface{}{
	"completion",
	"rate",
	"rating",
	"recommended",
}
var enumValues_P2PAdvertListUseClientLimits = []interface{}{
	0,
	1,
}
var enumValues_P2PAdvertUpdateDelete = []interface{}{
	0,
	1,
}
var enumValues_P2PAdvertUpdateIsActive = []interface{}{
	0,
	1,
}
var enumValues_P2PAdvertUpdateP2PAdvertUpdate = []interface{}{
	1,
}
var enumValues_P2PAdvertUpdateRateType = []interface{}{
	"fixed",
	"float",
}
var enumValues_P2PAdvertUpdateRespMsgType = []interface{}{
	"p2p_advert_update",
}
var enumValues_P2PAdvertUpdateRespP2PAdvertUpdateAdvertiserDetailsIsOnline = []interface{}{
	0,
	1,
}
var enumValues_P2PAdvertUpdateRespP2PAdvertUpdateBlockTrade = []interface{}{
	0,
	1,
}
var enumValues_P2PAdvertUpdateRespP2PAdvertUpdateCounterpartyType = []interface{}{
	"buy",
	"sell",
}
var enumValues_P2PAdvertUpdateRespP2PAdvertUpdateDeleted = []interface{}{
	1,
}
var enumValues_P2PAdvertUpdateRespP2PAdvertUpdateIsActive = []interface{}{
	0,
	1,
}
var enumValues_P2PAdvertUpdateRespP2PAdvertUpdateIsVisible = []interface{}{
	0,
	1,
}
var enumValues_P2PAdvertUpdateRespP2PAdvertUpdateRateType = []interface{}{
	"fixed",
	"float",
}
var enumValues_P2PAdvertUpdateRespP2PAdvertUpdateType = []interface{}{
	"buy",
	"sell",
}
var enumValues_P2PAdvertUpdateRespP2PAdvertUpdateVisibilityStatusElem = []interface{}{
	"advert_inactive",
	"advert_max_limit",
	"advert_min_limit",
	"advert_remaining",
	"advertiser_ads_paused",
	"advertiser_approval",
	"advertiser_balance",
	"advertiser_block_trade_ineligible",
	"advertiser_daily_limit",
	"advertiser_temp_ban",
}
var enumValues_P2PAdvertiserAdvertsP2PAdvertiserAdverts = []interface{}{
	1,
}
var enumValues_P2PAdvertiserAdvertsRespMsgType = []interface{}{
	"p2p_advertiser_adverts",
}
var enumValues_P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemAdvertiserDetailsIsOnline = []interface{}{
	0,
	1,
}
var enumValues_P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemBlockTrade = []interface{}{
	0,
	1,
}
var enumValues_P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemCounterpartyType = []interface{}{
	"buy",
	"sell",
}
var enumValues_P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemIsActive = []interface{}{
	0,
	1,
}
var enumValues_P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemIsVisible = []interface{}{
	0,
	1,
}
var enumValues_P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemRateType = []interface{}{
	"fixed",
	"float",
}
var enumValues_P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemType = []interface{}{
	"buy",
	"sell",
}
var enumValues_P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemVisibilityStatusElem = []interface{}{
	"advert_inactive",
	"advert_max_limit",
	"advert_min_limit",
	"advert_remaining",
	"advertiser_ads_paused",
	"advertiser_approval",
	"advertiser_balance",
	"advertiser_block_trade_ineligible",
	"advertiser_daily_limit",
	"advertiser_temp_ban",
}
var enumValues_P2PAdvertiserCreateP2PAdvertiserCreate = []interface{}{
	1,
}
var enumValues_P2PAdvertiserCreateRespMsgType = []interface{}{
	"p2p_advertiser_create",
}
var enumValues_P2PAdvertiserCreateRespP2PAdvertiserCreateBasicVerification = []interface{}{
	1,
	0,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PortfolioContractTypeElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PortfolioContractTypeElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PortfolioContractTypeElem, v)
	}
	*j = PortfolioContractTypeElem(v)
	return nil
}

var enumValues_PortfolioContractTypeElem = []interface{}{
	"ASIAND",
	"ASIANU",
	"CALL",
	"CALLE",
	"CALLSPREAD",
	"DIGITDIFF",
	"DIGITEVEN",
	"DIGITMATCH",
	"DIGITODD",
	"DIGITOVER",
	"DIGITUNDER",
	"EXPIRYMISSE",
	"EXPIRYMISS",
	"EXPIRYRANGE",
	"EXPIRYRANGEE",
	"LBFLOATCALL",
	"LBFLOATPUT",
	"LBHIGHLOW",
	"MULTDOWN",
	"MULTUP",
	"NOTOUCH",
	"ONETOUCH",
	"PUT",
	"PUTE",
	"PUTSPREAD",
	"RANGE",
	"RESETCALL",
	"RESETPUT",
	"RUNHIGH",
	"RUNLOW",
	"TICKHIGH",
	"TICKLOW",
	"UPORDOWN",
	"VANILLALONGCALL",
	"VANILLALONGPUT",
	"TURBOSLONG",
	"TURBOSSHORT",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PingResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain PingResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PingResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PingRespPing) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PingRespPing {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PingRespPing, v)
	}
	*j = PingRespPing(v)
	return nil
}

var enumValues_PingRespPing = []interface{}{
	"pong",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PingRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PingRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PingRespMsgType, v)
	}
	*j = PingRespMsgType(v)
	return nil
}

var enumValues_PingRespMsgType = []interface{}{
	"ping",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Ping) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["ping"]; !ok || v == nil {
		return fmt.Errorf("field ping: required")
	}
	type Plain Ping
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Ping(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PingPing) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PingPing {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PingPing, v)
	}
	*j = PingPing(v)
	return nil
}

var enumValues_PingPing = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PayoutCurrenciesResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain PayoutCurrenciesResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PayoutCurrenciesResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PayoutCurrenciesRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PayoutCurrenciesRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PayoutCurrenciesRespMsgType, v)
	}
	*j = PayoutCurrenciesRespMsgType(v)
	return nil
}

var enumValues_PayoutCurrenciesRespMsgType = []interface{}{
	"payout_currencies",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PayoutCurrencies) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["payout_currencies"]; !ok || v == nil {
		return fmt.Errorf("field payout_currencies: required")
	}
	type Plain PayoutCurrencies
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PayoutCurrencies(plain)
	return nil
}

var enumValues_PortfolioPortfolio = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PortfolioPortfolio) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PortfolioPortfolio {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PortfolioPortfolio, v)
	}
	*j = PortfolioPortfolio(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PayoutCurrenciesPayoutCurrencies) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PayoutCurrenciesPayoutCurrencies {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PayoutCurrenciesPayoutCurrencies, v)
	}
	*j = PayoutCurrenciesPayoutCurrencies(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Portfolio) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["portfolio"]; !ok || v == nil {
		return fmt.Errorf("field portfolio: required")
	}
	type Plain Portfolio
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Portfolio(plain)
	return nil
}

var enumValues_PayoutCurrenciesPayoutCurrencies = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentWithdrawResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain PaymentagentWithdrawResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PaymentagentWithdrawResp(plain)
	return nil
}

var enumValues_PortfolioRespMsgType = []interface{}{
	"portfolio",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PortfolioRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PortfolioRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PortfolioRespMsgType, v)
	}
	*j = PortfolioRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentWithdrawRespPaymentagentWithdraw) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PaymentagentWithdrawRespPaymentagentWithdraw {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PaymentagentWithdrawRespPaymentagentWithdraw, v)
	}
	*j = PaymentagentWithdrawRespPaymentagentWithdraw(v)
	return nil
}

var enumValues_PaymentagentWithdrawRespPaymentagentWithdraw = []interface{}{
	1,
	2,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentWithdrawRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PaymentagentWithdrawRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PaymentagentWithdrawRespMsgType, v)
	}
	*j = PaymentagentWithdrawRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PortfolioRespPortfolio) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["contracts"]; !ok || v == nil {
		return fmt.Errorf("field contracts: required")
	}
	type Plain PortfolioRespPortfolio
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PortfolioRespPortfolio(plain)
	return nil
}

var enumValues_PaymentagentWithdrawRespMsgType = []interface{}{
	"paymentagent_withdraw",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PortfolioResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain PortfolioResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PortfolioResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentWithdrawJustificationResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain PaymentagentWithdrawJustificationResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PaymentagentWithdrawJustificationResp(plain)
	return nil
}

var enumValues_ProfitTableContractTypeElem = []interface{}{
	"ACCU",
	"ASIAND",
	"ASIANU",
	"CALL",
	"CALLE",
	"CALLSPREAD",
	"DIGITDIFF",
	"DIGITEVEN",
	"DIGITMATCH",
	"DIGITODD",
	"DIGITOVER",
	"DIGITUNDER",
	"EXPIRYMISSE",
	"EXPIRYMISS",
	"EXPIRYRANGE",
	"EXPIRYRANGEE",
	"LBFLOATCALL",
	"LBFLOATPUT",
	"LBHIGHLOW",
	"MULTDOWN",
	"MULTUP",
	"NOTOUCH",
	"ONETOUCH",
	"PUT",
	"PUTE",
	"PUTSPREAD",
	"RANGE",
	"RESETCALL",
	"RESETPUT",
	"RUNHIGH",
	"RUNLOW",
	"TICKHIGH",
	"TICKLOW",
	"UPORDOWN",
	"VANILLALONGCALL",
	"VANILLALONGPUT",
	"TURBOSLONG",
	"TURBOSSHORT",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProfitTableContractTypeElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProfitTableContractTypeElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProfitTableContractTypeElem, v)
	}
	*j = ProfitTableContractTypeElem(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentWithdrawJustificationRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PaymentagentWithdrawJustificationRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PaymentagentWithdrawJustificationRespMsgType, v)
	}
	*j = PaymentagentWithdrawJustificationRespMsgType(v)
	return nil
}

var enumValues_PaymentagentWithdrawJustificationRespMsgType = []interface{}{
	"paymentagent_withdraw_justification",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentWithdrawJustification) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["paymentagent_withdraw_justification"]; !ok || v == nil {
		return fmt.Errorf("field paymentagent_withdraw_justification: required")
	}
	type Plain PaymentagentWithdrawJustification
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PaymentagentWithdrawJustification(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentWithdrawJustificationPaymentagentWithdrawJustification) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PaymentagentWithdrawJustificationPaymentagentWithdrawJustification {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PaymentagentWithdrawJustificationPaymentagentWithdrawJustification, v)
	}
	*j = PaymentagentWithdrawJustificationPaymentagentWithdrawJustification(v)
	return nil
}

var enumValues_PaymentagentWithdrawJustificationPaymentagentWithdrawJustification = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentWithdraw) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["currency"]; !ok || v == nil {
		return fmt.Errorf("field currency: required")
	}
	if v, ok := raw["paymentagent_loginid"]; !ok || v == nil {
		return fmt.Errorf("field paymentagent_loginid: required")
	}
	if v, ok := raw["paymentagent_withdraw"]; !ok || v == nil {
		return fmt.Errorf("field paymentagent_withdraw: required")
	}
	if v, ok := raw["verification_code"]; !ok || v == nil {
		return fmt.Errorf("field verification_code: required")
	}
	type Plain PaymentagentWithdraw
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PaymentagentWithdraw(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentWithdrawPaymentagentWithdraw) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PaymentagentWithdrawPaymentagentWithdraw {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PaymentagentWithdrawPaymentagentWithdraw, v)
	}
	*j = PaymentagentWithdrawPaymentagentWithdraw(v)
	return nil
}

var enumValues_PaymentagentWithdrawPaymentagentWithdraw = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentWithdrawDryRun) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PaymentagentWithdrawDryRun {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PaymentagentWithdrawDryRun, v)
	}
	*j = PaymentagentWithdrawDryRun(v)
	return nil
}

var enumValues_PaymentagentWithdrawDryRun = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentTransferResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain PaymentagentTransferResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PaymentagentTransferResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentTransferRespPaymentagentTransfer) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PaymentagentTransferRespPaymentagentTransfer {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PaymentagentTransferRespPaymentagentTransfer, v)
	}
	*j = PaymentagentTransferRespPaymentagentTransfer(v)
	return nil
}

var enumValues_PaymentagentTransferRespPaymentagentTransfer = []interface{}{
	1,
	2,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentTransferRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PaymentagentTransferRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PaymentagentTransferRespMsgType, v)
	}
	*j = PaymentagentTransferRespMsgType(v)
	return nil
}

var enumValues_PaymentagentTransferRespMsgType = []interface{}{
	"paymentagent_transfer",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentTransfer) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["currency"]; !ok || v == nil {
		return fmt.Errorf("field currency: required")
	}
	if v, ok := raw["paymentagent_transfer"]; !ok || v == nil {
		return fmt.Errorf("field paymentagent_transfer: required")
	}
	if v, ok := raw["transfer_to"]; !ok || v == nil {
		return fmt.Errorf("field transfer_to: required")
	}
	type Plain PaymentagentTransfer
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PaymentagentTransfer(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentTransferPaymentagentTransfer) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PaymentagentTransferPaymentagentTransfer {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PaymentagentTransferPaymentagentTransfer, v)
	}
	*j = PaymentagentTransferPaymentagentTransfer(v)
	return nil
}

var enumValues_PaymentagentTransferPaymentagentTransfer = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentTransferDryRun) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PaymentagentTransferDryRun {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PaymentagentTransferDryRun, v)
	}
	*j = PaymentagentTransferDryRun(v)
	return nil
}

var enumValues_PaymentagentTransferDryRun = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentListResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain PaymentagentListResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PaymentagentListResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentListRespPaymentagentList) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["list"]; !ok || v == nil {
		return fmt.Errorf("field list: required")
	}
	type Plain PaymentagentListRespPaymentagentList
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PaymentagentListRespPaymentagentList(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentListRespPaymentagentListListElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["currencies"]; !ok || v == nil {
		return fmt.Errorf("field currencies: required")
	}
	if v, ok := raw["deposit_commission"]; !ok || v == nil {
		return fmt.Errorf("field deposit_commission: required")
	}
	if v, ok := raw["email"]; !ok || v == nil {
		return fmt.Errorf("field email: required")
	}
	if v, ok := raw["further_information"]; !ok || v == nil {
		return fmt.Errorf("field further_information: required")
	}
	if v, ok := raw["max_withdrawal"]; !ok || v == nil {
		return fmt.Errorf("field max_withdrawal: required")
	}
	if v, ok := raw["min_withdrawal"]; !ok || v == nil {
		return fmt.Errorf("field min_withdrawal: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["paymentagent_loginid"]; !ok || v == nil {
		return fmt.Errorf("field paymentagent_loginid: required")
	}
	if v, ok := raw["phone_numbers"]; !ok || v == nil {
		return fmt.Errorf("field phone_numbers: required")
	}
	if v, ok := raw["summary"]; !ok || v == nil {
		return fmt.Errorf("field summary: required")
	}
	if v, ok := raw["supported_payment_methods"]; !ok || v == nil {
		return fmt.Errorf("field supported_payment_methods: required")
	}
	if v, ok := raw["urls"]; !ok || v == nil {
		return fmt.Errorf("field urls: required")
	}
	if v, ok := raw["withdrawal_commission"]; !ok || v == nil {
		return fmt.Errorf("field withdrawal_commission: required")
	}
	type Plain PaymentagentListRespPaymentagentListListElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PaymentagentListRespPaymentagentListListElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentListRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PaymentagentListRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PaymentagentListRespMsgType, v)
	}
	*j = PaymentagentListRespMsgType(v)
	return nil
}

var enumValues_PaymentagentListRespMsgType = []interface{}{
	"paymentagent_list",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentList) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["paymentagent_list"]; !ok || v == nil {
		return fmt.Errorf("field paymentagent_list: required")
	}
	type Plain PaymentagentList
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PaymentagentList(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentDetailsResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain PaymentagentDetailsResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PaymentagentDetailsResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentDetailsRespPaymentagentDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["can_apply"]; !ok || v == nil {
		return fmt.Errorf("field can_apply: required")
	}
	type Plain PaymentagentDetailsRespPaymentagentDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PaymentagentDetailsRespPaymentagentDetails(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentDetailsRespPaymentagentDetailsNewlyAuthorized) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PaymentagentDetailsRespPaymentagentDetailsNewlyAuthorized {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PaymentagentDetailsRespPaymentagentDetailsNewlyAuthorized, v)
	}
	*j = PaymentagentDetailsRespPaymentagentDetailsNewlyAuthorized(v)
	return nil
}

var enumValues_PaymentagentDetailsRespPaymentagentDetailsNewlyAuthorized = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentDetailsRespPaymentagentDetailsCodeOfConductApproval) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PaymentagentDetailsRespPaymentagentDetailsCodeOfConductApproval {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PaymentagentDetailsRespPaymentagentDetailsCodeOfConductApproval, v)
	}
	*j = PaymentagentDetailsRespPaymentagentDetailsCodeOfConductApproval(v)
	return nil
}

var enumValues_PaymentagentDetailsRespPaymentagentDetailsCodeOfConductApproval = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentDetailsRespPaymentagentDetailsCanApply) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PaymentagentDetailsRespPaymentagentDetailsCanApply {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PaymentagentDetailsRespPaymentagentDetailsCanApply, v)
	}
	*j = PaymentagentDetailsRespPaymentagentDetailsCanApply(v)
	return nil
}

var enumValues_PaymentagentDetailsRespPaymentagentDetailsCanApply = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentDetailsRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PaymentagentDetailsRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PaymentagentDetailsRespMsgType, v)
	}
	*j = PaymentagentDetailsRespMsgType(v)
	return nil
}

var enumValues_PaymentagentDetailsRespMsgType = []interface{}{
	"paymentagent_details",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["paymentagent_details"]; !ok || v == nil {
		return fmt.Errorf("field paymentagent_details: required")
	}
	type Plain PaymentagentDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PaymentagentDetails(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentDetailsPaymentagentDetails) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PaymentagentDetailsPaymentagentDetails {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PaymentagentDetailsPaymentagentDetails, v)
	}
	*j = PaymentagentDetailsPaymentagentDetails(v)
	return nil
}

var enumValues_PaymentagentDetailsPaymentagentDetails = []interface{}{
	1,
}
var enumValues_ProfitTableDescription = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProfitTableDescription) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProfitTableDescription {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProfitTableDescription, v)
	}
	*j = ProfitTableDescription(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentCreateResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain PaymentagentCreateResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PaymentagentCreateResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentCreateRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PaymentagentCreateRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PaymentagentCreateRespMsgType, v)
	}
	*j = PaymentagentCreateRespMsgType(v)
	return nil
}

var enumValues_ProfitTableProfitTable = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProfitTableProfitTable) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProfitTableProfitTable {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProfitTableProfitTable, v)
	}
	*j = ProfitTableProfitTable(v)
	return nil
}

var enumValues_PaymentagentCreateRespMsgType = []interface{}{
	"paymentagent_create",
}
var enumValues_ProfitTableSort = []interface{}{
	"ASC",
	"DESC",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProfitTableSort) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProfitTableSort {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProfitTableSort, v)
	}
	*j = ProfitTableSort(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentCreate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["code_of_conduct_approval"]; !ok || v == nil {
		return fmt.Errorf("field code_of_conduct_approval: required")
	}
	if v, ok := raw["commission_deposit"]; !ok || v == nil {
		return fmt.Errorf("field commission_deposit: required")
	}
	if v, ok := raw["commission_withdrawal"]; !ok || v == nil {
		return fmt.Errorf("field commission_withdrawal: required")
	}
	if v, ok := raw["email"]; !ok || v == nil {
		return fmt.Errorf("field email: required")
	}
	if v, ok := raw["information"]; !ok || v == nil {
		return fmt.Errorf("field information: required")
	}
	if v, ok := raw["payment_agent_name"]; !ok || v == nil {
		return fmt.Errorf("field payment_agent_name: required")
	}
	if v, ok := raw["paymentagent_create"]; !ok || v == nil {
		return fmt.Errorf("field paymentagent_create: required")
	}
	if v, ok := raw["supported_payment_methods"]; !ok || v == nil {
		return fmt.Errorf("field supported_payment_methods: required")
	}
	if v, ok := raw["urls"]; !ok || v == nil {
		return fmt.Errorf("field urls: required")
	}
	type Plain PaymentagentCreate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PaymentagentCreate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentCreateUrlsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["url"]; !ok || v == nil {
		return fmt.Errorf("field url: required")
	}
	type Plain PaymentagentCreateUrlsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PaymentagentCreateUrlsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentCreateSupportedPaymentMethodsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["payment_method"]; !ok || v == nil {
		return fmt.Errorf("field payment_method: required")
	}
	type Plain PaymentagentCreateSupportedPaymentMethodsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PaymentagentCreateSupportedPaymentMethodsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProfitTable) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["profit_table"]; !ok || v == nil {
		return fmt.Errorf("field profit_table: required")
	}
	type Plain ProfitTable
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["limit"]; !ok || v == nil {
		plain.Limit = 50
	}
	if v, ok := raw["sort"]; !ok || v == nil {
		plain.Sort = "DESC"
	}
	*j = ProfitTable(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentCreatePhoneNumbersElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["phone_number"]; !ok || v == nil {
		return fmt.Errorf("field phone_number: required")
	}
	type Plain PaymentagentCreatePhoneNumbersElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PaymentagentCreatePhoneNumbersElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentCreatePaymentagentCreate) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PaymentagentCreatePaymentagentCreate {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PaymentagentCreatePaymentagentCreate, v)
	}
	*j = PaymentagentCreatePaymentagentCreate(v)
	return nil
}

var enumValues_ProfitTableRespMsgType = []interface{}{
	"profit_table",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProfitTableRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProfitTableRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProfitTableRespMsgType, v)
	}
	*j = ProfitTableRespMsgType(v)
	return nil
}

var enumValues_PaymentagentCreatePaymentagentCreate = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentagentCreateCodeOfConductApproval) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PaymentagentCreateCodeOfConductApproval {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PaymentagentCreateCodeOfConductApproval, v)
	}
	*j = PaymentagentCreateCodeOfConductApproval(v)
	return nil
}

var enumValues_PaymentagentCreateCodeOfConductApproval = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentMethodsResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain PaymentMethodsResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PaymentMethodsResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProfitTableResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain ProfitTableResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ProfitTableResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentMethodsRespPaymentMethodsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["deposit_limits"]; !ok || v == nil {
		return fmt.Errorf("field deposit_limits: required")
	}
	if v, ok := raw["deposit_time"]; !ok || v == nil {
		return fmt.Errorf("field deposit_time: required")
	}
	if v, ok := raw["description"]; !ok || v == nil {
		return fmt.Errorf("field description: required")
	}
	if v, ok := raw["display_name"]; !ok || v == nil {
		return fmt.Errorf("field display_name: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["payment_processor"]; !ok || v == nil {
		return fmt.Errorf("field payment_processor: required")
	}
	if v, ok := raw["predefined_amounts"]; !ok || v == nil {
		return fmt.Errorf("field predefined_amounts: required")
	}
	if v, ok := raw["signup_link"]; !ok || v == nil {
		return fmt.Errorf("field signup_link: required")
	}
	if v, ok := raw["supported_currencies"]; !ok || v == nil {
		return fmt.Errorf("field supported_currencies: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	if v, ok := raw["type_display_name"]; !ok || v == nil {
		return fmt.Errorf("field type_display_name: required")
	}
	if v, ok := raw["withdraw_limits"]; !ok || v == nil {
		return fmt.Errorf("field withdraw_limits: required")
	}
	if v, ok := raw["withdrawal_time"]; !ok || v == nil {
		return fmt.Errorf("field withdrawal_time: required")
	}
	type Plain PaymentMethodsRespPaymentMethodsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PaymentMethodsRespPaymentMethodsElem(plain)
	return nil
}

var enumValues_ProposalBarrierRange = []interface{}{
	"tight",
	"middle",
	"wide",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalBarrierRange) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProposalBarrierRange {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProposalBarrierRange, v)
	}
	*j = ProposalBarrierRange(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentMethodsRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PaymentMethodsRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PaymentMethodsRespMsgType, v)
	}
	*j = PaymentMethodsRespMsgType(v)
	return nil
}

var enumValues_PaymentMethodsRespMsgType = []interface{}{
	"payment_methods",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentMethods) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["payment_methods"]; !ok || v == nil {
		return fmt.Errorf("field payment_methods: required")
	}
	type Plain PaymentMethods
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PaymentMethods(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PaymentMethodsPaymentMethods) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PaymentMethodsPaymentMethods {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PaymentMethodsPaymentMethods, v)
	}
	*j = PaymentMethodsPaymentMethods(v)
	return nil
}

var enumValues_ProposalBasis = []interface{}{
	"payout",
	"stake",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalBasis) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProposalBasis {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProposalBasis, v)
	}
	*j = ProposalBasis(v)
	return nil
}

var enumValues_PaymentMethodsPaymentMethods = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PPingResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain P2PPingResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PPingResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PPingRespP2PPing) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PPingRespP2PPing {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PPingRespP2PPing, v)
	}
	*j = P2PPingRespP2PPing(v)
	return nil
}

var enumValues_ProposalContractType = []interface{}{
	"MULTUP",
	"MULTDOWN",
	"UPORDOWN",
	"EXPIRYRANGE",
	"ONETOUCH",
	"CALLE",
	"LBHIGHLOW",
	"ASIAND",
	"EXPIRYRANGEE",
	"DIGITDIFF",
	"DIGITMATCH",
	"DIGITOVER",
	"PUTE",
	"DIGITUNDER",
	"NOTOUCH",
	"CALL",
	"RANGE",
	"LBFLOATPUT",
	"DIGITODD",
	"PUT",
	"ASIANU",
	"LBFLOATCALL",
	"EXPIRYMISSE",
	"EXPIRYMISS",
	"DIGITEVEN",
	"TICKHIGH",
	"TICKLOW",
	"RESETCALL",
	"RESETPUT",
	"CALLSPREAD",
	"PUTSPREAD",
	"RUNHIGH",
	"RUNLOW",
	"ACCU",
	"VANILLALONGCALL",
	"VANILLALONGPUT",
	"TURBOSLONG",
	"TURBOSSHORT",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalContractType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProposalContractType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProposalContractType, v)
	}
	*j = ProposalContractType(v)
	return nil
}

var enumValues_P2PPingRespP2PPing = []interface{}{
	"pong",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PPingRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PPingRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PPingRespMsgType, v)
	}
	*j = P2PPingRespMsgType(v)
	return nil
}

var enumValues_P2PPingRespMsgType = []interface{}{
	"p2p_ping",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PPing) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["p2p_ping"]; !ok || v == nil {
		return fmt.Errorf("field p2p_ping: required")
	}
	type Plain P2PPing
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PPing(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PPingP2PPing) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PPingP2PPing {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PPingP2PPing, v)
	}
	*j = P2PPingP2PPing(v)
	return nil
}

var enumValues_P2PPingP2PPing = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PPaymentMethodsResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain P2PPaymentMethodsResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PPaymentMethodsResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PPaymentMethodsRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PPaymentMethodsRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PPaymentMethodsRespMsgType, v)
	}
	*j = P2PPaymentMethodsRespMsgType(v)
	return nil
}

var enumValues_P2PPaymentMethodsRespMsgType = []interface{}{
	"p2p_payment_methods",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PPaymentMethods) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["p2p_payment_methods"]; !ok || v == nil {
		return fmt.Errorf("field p2p_payment_methods: required")
	}
	type Plain P2PPaymentMethods
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PPaymentMethods(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PPaymentMethodsP2PPaymentMethods) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PPaymentMethodsP2PPaymentMethods {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PPaymentMethodsP2PPaymentMethods, v)
	}
	*j = P2PPaymentMethodsP2PPaymentMethods(v)
	return nil
}

var enumValues_P2PPaymentMethodsP2PPaymentMethods = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderReviewResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain P2POrderReviewResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderReviewResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderReviewRespP2POrderReview) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["advertiser_id"]; !ok || v == nil {
		return fmt.Errorf("field advertiser_id: required")
	}
	if v, ok := raw["created_time"]; !ok || v == nil {
		return fmt.Errorf("field created_time: required")
	}
	if v, ok := raw["order_id"]; !ok || v == nil {
		return fmt.Errorf("field order_id: required")
	}
	if v, ok := raw["rating"]; !ok || v == nil {
		return fmt.Errorf("field rating: required")
	}
	if v, ok := raw["recommended"]; !ok || v == nil {
		return fmt.Errorf("field recommended: required")
	}
	type Plain P2POrderReviewRespP2POrderReview
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderReviewRespP2POrderReview(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderReviewRespP2POrderReviewRecommended) UnmarshalJSON(b []byte) error {
	var v struct {
		Value interface{}
	}
	if err := json.Unmarshal(b, &v.Value); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderReviewRespP2POrderReviewRecommended {
		if reflect.DeepEqual(v.Value, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderReviewRespP2POrderReviewRecommended, v.Value)
	}
	*j = P2POrderReviewRespP2POrderReviewRecommended(v)
	return nil
}

// MarshalJSON implements json.Marshaler.
func (j *P2POrderReviewRespP2POrderReviewRecommended) MarshalJSON() ([]byte, error) {
	return json.Marshal(j.Value)
}

var enumValues_P2POrderReviewRespP2POrderReviewRecommended = []interface{}{
	nil,
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderReviewRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderReviewRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderReviewRespMsgType, v)
	}
	*j = P2POrderReviewRespMsgType(v)
	return nil
}

var enumValues_P2POrderReviewRespMsgType = []interface{}{
	"p2p_order_review",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderReview) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["order_id"]; !ok || v == nil {
		return fmt.Errorf("field order_id: required")
	}
	if v, ok := raw["p2p_order_review"]; !ok || v == nil {
		return fmt.Errorf("field p2p_order_review: required")
	}
	if v, ok := raw["rating"]; !ok || v == nil {
		return fmt.Errorf("field rating: required")
	}
	type Plain P2POrderReview
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderReview(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderReviewRecommended) UnmarshalJSON(b []byte) error {
	var v struct {
		Value interface{}
	}
	if err := json.Unmarshal(b, &v.Value); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderReviewRecommended {
		if reflect.DeepEqual(v.Value, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderReviewRecommended, v.Value)
	}
	*j = P2POrderReviewRecommended(v)
	return nil
}

// MarshalJSON implements json.Marshaler.
func (j *P2POrderReviewRecommended) MarshalJSON() ([]byte, error) {
	return json.Marshal(j.Value)
}

var enumValues_P2POrderReviewRecommended = []interface{}{
	nil,
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderReviewP2POrderReview) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderReviewP2POrderReview {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderReviewP2POrderReview, v)
	}
	*j = P2POrderReviewP2POrderReview(v)
	return nil
}

var enumValues_P2POrderReviewP2POrderReview = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderListResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain P2POrderListResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderListResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderListRespSubscription) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	type Plain P2POrderListRespSubscription
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderListRespSubscription(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderListRespP2POrderList) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["list"]; !ok || v == nil {
		return fmt.Errorf("field list: required")
	}
	type Plain P2POrderListRespP2POrderList
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderListRespP2POrderList(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderListRespP2POrderListListElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["account_currency"]; !ok || v == nil {
		return fmt.Errorf("field account_currency: required")
	}
	if v, ok := raw["advert_details"]; !ok || v == nil {
		return fmt.Errorf("field advert_details: required")
	}
	if v, ok := raw["advertiser_details"]; !ok || v == nil {
		return fmt.Errorf("field advertiser_details: required")
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["amount_display"]; !ok || v == nil {
		return fmt.Errorf("field amount_display: required")
	}
	if v, ok := raw["chat_channel_url"]; !ok || v == nil {
		return fmt.Errorf("field chat_channel_url: required")
	}
	if v, ok := raw["contact_info"]; !ok || v == nil {
		return fmt.Errorf("field contact_info: required")
	}
	if v, ok := raw["created_time"]; !ok || v == nil {
		return fmt.Errorf("field created_time: required")
	}
	if v, ok := raw["dispute_details"]; !ok || v == nil {
		return fmt.Errorf("field dispute_details: required")
	}
	if v, ok := raw["expiry_time"]; !ok || v == nil {
		return fmt.Errorf("field expiry_time: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["is_incoming"]; !ok || v == nil {
		return fmt.Errorf("field is_incoming: required")
	}
	if v, ok := raw["is_reviewable"]; !ok || v == nil {
		return fmt.Errorf("field is_reviewable: required")
	}
	if v, ok := raw["local_currency"]; !ok || v == nil {
		return fmt.Errorf("field local_currency: required")
	}
	if v, ok := raw["payment_info"]; !ok || v == nil {
		return fmt.Errorf("field payment_info: required")
	}
	if v, ok := raw["price"]; !ok || v == nil {
		return fmt.Errorf("field price: required")
	}
	if v, ok := raw["price_display"]; !ok || v == nil {
		return fmt.Errorf("field price_display: required")
	}
	if v, ok := raw["rate"]; !ok || v == nil {
		return fmt.Errorf("field rate: required")
	}
	if v, ok := raw["rate_display"]; !ok || v == nil {
		return fmt.Errorf("field rate_display: required")
	}
	if v, ok := raw["status"]; !ok || v == nil {
		return fmt.Errorf("field status: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain P2POrderListRespP2POrderListListElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderListRespP2POrderListListElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderListRespP2POrderListListElemVerificationPending) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderListRespP2POrderListListElemVerificationPending {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderListRespP2POrderListListElemVerificationPending, v)
	}
	*j = P2POrderListRespP2POrderListListElemVerificationPending(v)
	return nil
}

var enumValues_P2POrderListRespP2POrderListListElemVerificationPending = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderListRespP2POrderListListElemType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderListRespP2POrderListListElemType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderListRespP2POrderListListElemType, v)
	}
	*j = P2POrderListRespP2POrderListListElemType(v)
	return nil
}

var enumValues_P2POrderListRespP2POrderListListElemType = []interface{}{
	"buy",
	"sell",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderListRespP2POrderListListElemStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderListRespP2POrderListListElemStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderListRespP2POrderListListElemStatus, v)
	}
	*j = P2POrderListRespP2POrderListListElemStatus(v)
	return nil
}

var enumValues_P2POrderListRespP2POrderListListElemStatus = []interface{}{
	"pending",
	"buyer-confirmed",
	"cancelled",
	"timed-out",
	"blocked",
	"refunded",
	"completed",
	"disputed",
	"dispute-refunded",
	"dispute-completed",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderListRespP2POrderListListElemReviewDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["created_time"]; !ok || v == nil {
		return fmt.Errorf("field created_time: required")
	}
	if v, ok := raw["rating"]; !ok || v == nil {
		return fmt.Errorf("field rating: required")
	}
	if v, ok := raw["recommended"]; !ok || v == nil {
		return fmt.Errorf("field recommended: required")
	}
	type Plain P2POrderListRespP2POrderListListElemReviewDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderListRespP2POrderListListElemReviewDetails(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderListRespP2POrderListListElemReviewDetailsRecommended) UnmarshalJSON(b []byte) error {
	var v struct {
		Value interface{}
	}
	if err := json.Unmarshal(b, &v.Value); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderListRespP2POrderListListElemReviewDetailsRecommended {
		if reflect.DeepEqual(v.Value, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderListRespP2POrderListListElemReviewDetailsRecommended, v.Value)
	}
	*j = P2POrderListRespP2POrderListListElemReviewDetailsRecommended(v)
	return nil
}

// MarshalJSON implements json.Marshaler.
func (j *P2POrderListRespP2POrderListListElemReviewDetailsRecommended) MarshalJSON() ([]byte, error) {
	return json.Marshal(j.Value)
}

var enumValues_P2POrderListRespP2POrderListListElemReviewDetailsRecommended = []interface{}{
	nil,
	0,
	1,
}
var enumValues_ProposalDurationUnit = []interface{}{
	"d",
	"m",
	"s",
	"h",
	"t",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalDurationUnit) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProposalDurationUnit {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProposalDurationUnit, v)
	}
	*j = ProposalDurationUnit(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderListRespP2POrderListListElemIsSeen) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderListRespP2POrderListListElemIsSeen {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderListRespP2POrderListListElemIsSeen, v)
	}
	*j = P2POrderListRespP2POrderListListElemIsSeen(v)
	return nil
}

var enumValues_P2POrderListRespP2POrderListListElemIsSeen = []interface{}{
	1,
	0,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderListRespP2POrderListListElemIsReviewable) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderListRespP2POrderListListElemIsReviewable {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderListRespP2POrderListListElemIsReviewable, v)
	}
	*j = P2POrderListRespP2POrderListListElemIsReviewable(v)
	return nil
}

var enumValues_P2POrderListRespP2POrderListListElemIsReviewable = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderListRespP2POrderListListElemIsIncoming) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderListRespP2POrderListListElemIsIncoming {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderListRespP2POrderListListElemIsIncoming, v)
	}
	*j = P2POrderListRespP2POrderListListElemIsIncoming(v)
	return nil
}

var enumValues_P2POrderListRespP2POrderListListElemIsIncoming = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderListRespP2POrderListListElemDisputeDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["dispute_reason"]; !ok || v == nil {
		return fmt.Errorf("field dispute_reason: required")
	}
	if v, ok := raw["disputer_loginid"]; !ok || v == nil {
		return fmt.Errorf("field disputer_loginid: required")
	}
	type Plain P2POrderListRespP2POrderListListElemDisputeDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderListRespP2POrderListListElemDisputeDetails(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderListRespP2POrderListListElemClientDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["is_online"]; !ok || v == nil {
		return fmt.Errorf("field is_online: required")
	}
	if v, ok := raw["last_online_time"]; !ok || v == nil {
		return fmt.Errorf("field last_online_time: required")
	}
	if v, ok := raw["loginid"]; !ok || v == nil {
		return fmt.Errorf("field loginid: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain P2POrderListRespP2POrderListListElemClientDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderListRespP2POrderListListElemClientDetails(plain)
	return nil
}

var enumValues_ProposalProductType = []interface{}{
	"basic",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalProductType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProposalProductType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProposalProductType, v)
	}
	*j = ProposalProductType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderListRespP2POrderListListElemClientDetailsIsRecommended) UnmarshalJSON(b []byte) error {
	var v struct {
		Value interface{}
	}
	if err := json.Unmarshal(b, &v.Value); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderListRespP2POrderListListElemClientDetailsIsRecommended {
		if reflect.DeepEqual(v.Value, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderListRespP2POrderListListElemClientDetailsIsRecommended, v.Value)
	}
	*j = P2POrderListRespP2POrderListListElemClientDetailsIsRecommended(v)
	return nil
}

// MarshalJSON implements json.Marshaler.
func (j *P2POrderListRespP2POrderListListElemClientDetailsIsRecommended) MarshalJSON() ([]byte, error) {
	return json.Marshal(j.Value)
}

var enumValues_ProposalProposal = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalProposal) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProposalProposal {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProposalProposal, v)
	}
	*j = ProposalProposal(v)
	return nil
}

var enumValues_P2POrderListRespP2POrderListListElemClientDetailsIsRecommended = []interface{}{
	nil,
	0,
	1,
}
var enumValues_ProposalSubscribe = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalSubscribe) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProposalSubscribe {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProposalSubscribe, v)
	}
	*j = ProposalSubscribe(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderListRespP2POrderListListElemClientDetailsIsOnline) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderListRespP2POrderListListElemClientDetailsIsOnline {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderListRespP2POrderListListElemClientDetailsIsOnline, v)
	}
	*j = P2POrderListRespP2POrderListListElemClientDetailsIsOnline(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Proposal) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["contract_type"]; !ok || v == nil {
		return fmt.Errorf("field contract_type: required")
	}
	if v, ok := raw["currency"]; !ok || v == nil {
		return fmt.Errorf("field currency: required")
	}
	if v, ok := raw["proposal"]; !ok || v == nil {
		return fmt.Errorf("field proposal: required")
	}
	if v, ok := raw["symbol"]; !ok || v == nil {
		return fmt.Errorf("field symbol: required")
	}
	type Plain Proposal
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["duration_unit"]; !ok || v == nil {
		plain.DurationUnit = "s"
	}
	if v, ok := raw["product_type"]; !ok || v == nil {
		plain.ProductType = "basic"
	}
	*j = Proposal(plain)
	return nil
}

var enumValues_P2POrderListRespP2POrderListListElemClientDetailsIsOnline = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderListRespP2POrderListListElemAdvertiserDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["is_online"]; !ok || v == nil {
		return fmt.Errorf("field is_online: required")
	}
	if v, ok := raw["last_online_time"]; !ok || v == nil {
		return fmt.Errorf("field last_online_time: required")
	}
	if v, ok := raw["loginid"]; !ok || v == nil {
		return fmt.Errorf("field loginid: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain P2POrderListRespP2POrderListListElemAdvertiserDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderListRespP2POrderListListElemAdvertiserDetails(plain)
	return nil
}

var enumValues_ProposalOpenContractProposalOpenContract = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalOpenContractProposalOpenContract) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProposalOpenContractProposalOpenContract {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProposalOpenContractProposalOpenContract, v)
	}
	*j = ProposalOpenContractProposalOpenContract(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderListRespP2POrderListListElemAdvertiserDetailsIsRecommended) UnmarshalJSON(b []byte) error {
	var v struct {
		Value interface{}
	}
	if err := json.Unmarshal(b, &v.Value); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderListRespP2POrderListListElemAdvertiserDetailsIsRecommended {
		if reflect.DeepEqual(v.Value, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderListRespP2POrderListListElemAdvertiserDetailsIsRecommended, v.Value)
	}
	*j = P2POrderListRespP2POrderListListElemAdvertiserDetailsIsRecommended(v)
	return nil
}

var enumValues_ProposalOpenContractSubscribe = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalOpenContractSubscribe) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProposalOpenContractSubscribe {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProposalOpenContractSubscribe, v)
	}
	*j = ProposalOpenContractSubscribe(v)
	return nil
}

// MarshalJSON implements json.Marshaler.
func (j *P2POrderListRespP2POrderListListElemAdvertiserDetailsIsRecommended) MarshalJSON() ([]byte, error) {
	return json.Marshal(j.Value)
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalOpenContract) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["proposal_open_contract"]; !ok || v == nil {
		return fmt.Errorf("field proposal_open_contract: required")
	}
	type Plain ProposalOpenContract
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ProposalOpenContract(plain)
	return nil
}

var enumValues_P2POrderListRespP2POrderListListElemAdvertiserDetailsIsRecommended = []interface{}{
	nil,
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderListRespP2POrderListListElemAdvertiserDetailsIsOnline) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderListRespP2POrderListListElemAdvertiserDetailsIsOnline {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderListRespP2POrderListListElemAdvertiserDetailsIsOnline, v)
	}
	*j = P2POrderListRespP2POrderListListElemAdvertiserDetailsIsOnline(v)
	return nil
}

var enumValues_ProposalOpenContractRespMsgType = []interface{}{
	"proposal_open_contract",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalOpenContractRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProposalOpenContractRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProposalOpenContractRespMsgType, v)
	}
	*j = ProposalOpenContractRespMsgType(v)
	return nil
}

var enumValues_P2POrderListRespP2POrderListListElemAdvertiserDetailsIsOnline = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderListRespP2POrderListListElemAdvertDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["block_trade"]; !ok || v == nil {
		return fmt.Errorf("field block_trade: required")
	}
	if v, ok := raw["description"]; !ok || v == nil {
		return fmt.Errorf("field description: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["payment_method"]; !ok || v == nil {
		return fmt.Errorf("field payment_method: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain P2POrderListRespP2POrderListListElemAdvertDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderListRespP2POrderListListElemAdvertDetails(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderListRespP2POrderListListElemAdvertDetailsType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderListRespP2POrderListListElemAdvertDetailsType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderListRespP2POrderListListElemAdvertDetailsType, v)
	}
	*j = P2POrderListRespP2POrderListListElemAdvertDetailsType(v)
	return nil
}

var enumValues_ProposalOpenContractRespProposalOpenContractIsExpired = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalOpenContractRespProposalOpenContractIsExpired) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProposalOpenContractRespProposalOpenContractIsExpired {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProposalOpenContractRespProposalOpenContractIsExpired, v)
	}
	*j = ProposalOpenContractRespProposalOpenContractIsExpired(v)
	return nil
}

var enumValues_P2POrderListRespP2POrderListListElemAdvertDetailsType = []interface{}{
	"buy",
	"sell",
}
var enumValues_ProposalOpenContractRespProposalOpenContractIsForwardStarting = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalOpenContractRespProposalOpenContractIsForwardStarting) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProposalOpenContractRespProposalOpenContractIsForwardStarting {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProposalOpenContractRespProposalOpenContractIsForwardStarting, v)
	}
	*j = ProposalOpenContractRespProposalOpenContractIsForwardStarting(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderListRespP2POrderListListElemAdvertDetailsBlockTrade) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderListRespP2POrderListListElemAdvertDetailsBlockTrade {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderListRespP2POrderListListElemAdvertDetailsBlockTrade, v)
	}
	*j = P2POrderListRespP2POrderListListElemAdvertDetailsBlockTrade(v)
	return nil
}

var enumValues_ProposalOpenContractRespProposalOpenContractIsIntraday = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalOpenContractRespProposalOpenContractIsIntraday) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProposalOpenContractRespProposalOpenContractIsIntraday {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProposalOpenContractRespProposalOpenContractIsIntraday, v)
	}
	*j = ProposalOpenContractRespProposalOpenContractIsIntraday(v)
	return nil
}

var enumValues_P2POrderListRespP2POrderListListElemAdvertDetailsBlockTrade = []interface{}{
	0,
	1,
}
var enumValues_ProposalOpenContractRespProposalOpenContractIsPathDependent = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalOpenContractRespProposalOpenContractIsPathDependent) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProposalOpenContractRespProposalOpenContractIsPathDependent {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProposalOpenContractRespProposalOpenContractIsPathDependent, v)
	}
	*j = ProposalOpenContractRespProposalOpenContractIsPathDependent(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderListRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderListRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderListRespMsgType, v)
	}
	*j = P2POrderListRespMsgType(v)
	return nil
}

var enumValues_ProposalOpenContractRespProposalOpenContractIsSettleable = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalOpenContractRespProposalOpenContractIsSettleable) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProposalOpenContractRespProposalOpenContractIsSettleable {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProposalOpenContractRespProposalOpenContractIsSettleable, v)
	}
	*j = ProposalOpenContractRespProposalOpenContractIsSettleable(v)
	return nil
}

var enumValues_P2POrderListRespMsgType = []interface{}{
	"p2p_order_list",
}
var enumValues_ProposalOpenContractRespProposalOpenContractIsSold = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalOpenContractRespProposalOpenContractIsSold) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProposalOpenContractRespProposalOpenContractIsSold {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProposalOpenContractRespProposalOpenContractIsSold, v)
	}
	*j = ProposalOpenContractRespProposalOpenContractIsSold(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderList) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["p2p_order_list"]; !ok || v == nil {
		return fmt.Errorf("field p2p_order_list: required")
	}
	type Plain P2POrderList
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["limit"]; !ok || v == nil {
		plain.Limit = 50
	}
	if v, ok := raw["offset"]; !ok || v == nil {
		plain.Offset = 0
	}
	*j = P2POrderList(plain)
	return nil
}

var enumValues_ProposalOpenContractRespProposalOpenContractIsValidToCancel = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalOpenContractRespProposalOpenContractIsValidToCancel) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProposalOpenContractRespProposalOpenContractIsValidToCancel {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProposalOpenContractRespProposalOpenContractIsValidToCancel, v)
	}
	*j = ProposalOpenContractRespProposalOpenContractIsValidToCancel(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderListSubscribe) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderListSubscribe {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderListSubscribe, v)
	}
	*j = P2POrderListSubscribe(v)
	return nil
}

var enumValues_ProposalOpenContractRespProposalOpenContractIsValidToSell = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalOpenContractRespProposalOpenContractIsValidToSell) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProposalOpenContractRespProposalOpenContractIsValidToSell {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProposalOpenContractRespProposalOpenContractIsValidToSell, v)
	}
	*j = ProposalOpenContractRespProposalOpenContractIsValidToSell(v)
	return nil
}

var enumValues_P2POrderListSubscribe = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderListP2POrderList) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderListP2POrderList {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderListP2POrderList, v)
	}
	*j = P2POrderListP2POrderList(v)
	return nil
}

var enumValues_P2POrderListP2POrderList = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderListActive) UnmarshalJSON(b []byte) error {
	var v float64
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderListActive {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderListActive, v)
	}
	*j = P2POrderListActive(v)
	return nil
}

var enumValues_P2POrderListActive = []interface{}{
	0,
	1,
}
var enumValues_ProposalOpenContractRespProposalOpenContractStatus = []interface{}{
	"open",
	"sold",
	"won",
	"lost",
	"cancelled",
	nil,
}

// MarshalJSON implements json.Marshaler.
func (j *ProposalOpenContractRespProposalOpenContractStatus) MarshalJSON() ([]byte, error) {
	return json.Marshal(j.Value)
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalOpenContractRespProposalOpenContractStatus) UnmarshalJSON(b []byte) error {
	var v struct {
		Value interface{}
	}
	if err := json.Unmarshal(b, &v.Value); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProposalOpenContractRespProposalOpenContractStatus {
		if reflect.DeepEqual(v.Value, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProposalOpenContractRespProposalOpenContractStatus, v.Value)
	}
	*j = ProposalOpenContractRespProposalOpenContractStatus(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain P2POrderInfoResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderInfoResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespSubscription) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	type Plain P2POrderInfoRespSubscription
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderInfoRespSubscription(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["account_currency"]; !ok || v == nil {
		return fmt.Errorf("field account_currency: required")
	}
	if v, ok := raw["advert_details"]; !ok || v == nil {
		return fmt.Errorf("field advert_details: required")
	}
	if v, ok := raw["advertiser_details"]; !ok || v == nil {
		return fmt.Errorf("field advertiser_details: required")
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["amount_display"]; !ok || v == nil {
		return fmt.Errorf("field amount_display: required")
	}
	if v, ok := raw["chat_channel_url"]; !ok || v == nil {
		return fmt.Errorf("field chat_channel_url: required")
	}
	if v, ok := raw["client_details"]; !ok || v == nil {
		return fmt.Errorf("field client_details: required")
	}
	if v, ok := raw["contact_info"]; !ok || v == nil {
		return fmt.Errorf("field contact_info: required")
	}
	if v, ok := raw["created_time"]; !ok || v == nil {
		return fmt.Errorf("field created_time: required")
	}
	if v, ok := raw["dispute_details"]; !ok || v == nil {
		return fmt.Errorf("field dispute_details: required")
	}
	if v, ok := raw["expiry_time"]; !ok || v == nil {
		return fmt.Errorf("field expiry_time: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["is_incoming"]; !ok || v == nil {
		return fmt.Errorf("field is_incoming: required")
	}
	if v, ok := raw["is_reviewable"]; !ok || v == nil {
		return fmt.Errorf("field is_reviewable: required")
	}
	if v, ok := raw["local_currency"]; !ok || v == nil {
		return fmt.Errorf("field local_currency: required")
	}
	if v, ok := raw["payment_info"]; !ok || v == nil {
		return fmt.Errorf("field payment_info: required")
	}
	if v, ok := raw["price"]; !ok || v == nil {
		return fmt.Errorf("field price: required")
	}
	if v, ok := raw["price_display"]; !ok || v == nil {
		return fmt.Errorf("field price_display: required")
	}
	if v, ok := raw["rate"]; !ok || v == nil {
		return fmt.Errorf("field rate: required")
	}
	if v, ok := raw["rate_display"]; !ok || v == nil {
		return fmt.Errorf("field rate_display: required")
	}
	if v, ok := raw["status"]; !ok || v == nil {
		return fmt.Errorf("field status: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain P2POrderInfoRespP2POrderInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderInfoRespP2POrderInfo(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoVerificationPending) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderInfoRespP2POrderInfoVerificationPending {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderInfoRespP2POrderInfoVerificationPending, v)
	}
	*j = P2POrderInfoRespP2POrderInfoVerificationPending(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalOpenContractRespSubscription) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	type Plain ProposalOpenContractRespSubscription
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ProposalOpenContractRespSubscription(plain)
	return nil
}

var enumValues_P2POrderInfoRespP2POrderInfoVerificationPending = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalOpenContractResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	type Plain ProposalOpenContractResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ProposalOpenContractResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderInfoRespP2POrderInfoType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderInfoRespP2POrderInfoType, v)
	}
	*j = P2POrderInfoRespP2POrderInfoType(v)
	return nil
}

var enumValues_P2POrderInfoRespP2POrderInfoType = []interface{}{
	"buy",
	"sell",
}
var enumValues_ProposalRespMsgType = []interface{}{
	"proposal",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProposalRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProposalRespMsgType, v)
	}
	*j = ProposalRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderInfoRespP2POrderInfoStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderInfoRespP2POrderInfoStatus, v)
	}
	*j = P2POrderInfoRespP2POrderInfoStatus(v)
	return nil
}

var enumValues_P2POrderInfoRespP2POrderInfoStatus = []interface{}{
	"pending",
	"buyer-confirmed",
	"cancelled",
	"timed-out",
	"blocked",
	"refunded",
	"completed",
	"disputed",
	"dispute-refunded",
	"dispute-completed",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoReviewDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["created_time"]; !ok || v == nil {
		return fmt.Errorf("field created_time: required")
	}
	if v, ok := raw["rating"]; !ok || v == nil {
		return fmt.Errorf("field rating: required")
	}
	if v, ok := raw["recommended"]; !ok || v == nil {
		return fmt.Errorf("field recommended: required")
	}
	type Plain P2POrderInfoRespP2POrderInfoReviewDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderInfoRespP2POrderInfoReviewDetails(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoReviewDetailsRecommended) UnmarshalJSON(b []byte) error {
	var v struct {
		Value interface{}
	}
	if err := json.Unmarshal(b, &v.Value); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderInfoRespP2POrderInfoReviewDetailsRecommended {
		if reflect.DeepEqual(v.Value, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderInfoRespP2POrderInfoReviewDetailsRecommended, v.Value)
	}
	*j = P2POrderInfoRespP2POrderInfoReviewDetailsRecommended(v)
	return nil
}

// MarshalJSON implements json.Marshaler.
func (j *P2POrderInfoRespP2POrderInfoReviewDetailsRecommended) MarshalJSON() ([]byte, error) {
	return json.Marshal(j.Value)
}

var enumValues_P2POrderInfoRespP2POrderInfoReviewDetailsRecommended = []interface{}{
	nil,
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoIsSeen) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderInfoRespP2POrderInfoIsSeen {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderInfoRespP2POrderInfoIsSeen, v)
	}
	*j = P2POrderInfoRespP2POrderInfoIsSeen(v)
	return nil
}

var enumValues_P2POrderInfoRespP2POrderInfoIsSeen = []interface{}{
	1,
	0,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalRespProposal) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["ask_price"]; !ok || v == nil {
		return fmt.Errorf("field ask_price: required")
	}
	if v, ok := raw["date_start"]; !ok || v == nil {
		return fmt.Errorf("field date_start: required")
	}
	if v, ok := raw["display_value"]; !ok || v == nil {
		return fmt.Errorf("field display_value: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["longcode"]; !ok || v == nil {
		return fmt.Errorf("field longcode: required")
	}
	if v, ok := raw["payout"]; !ok || v == nil {
		return fmt.Errorf("field payout: required")
	}
	if v, ok := raw["spot"]; !ok || v == nil {
		return fmt.Errorf("field spot: required")
	}
	if v, ok := raw["spot_time"]; !ok || v == nil {
		return fmt.Errorf("field spot_time: required")
	}
	type Plain ProposalRespProposal
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ProposalRespProposal(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoIsReviewable) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderInfoRespP2POrderInfoIsReviewable {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderInfoRespP2POrderInfoIsReviewable, v)
	}
	*j = P2POrderInfoRespP2POrderInfoIsReviewable(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalRespSubscription) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	type Plain ProposalRespSubscription
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ProposalRespSubscription(plain)
	return nil
}

var enumValues_P2POrderInfoRespP2POrderInfoIsReviewable = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain ProposalResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ProposalResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoIsIncoming) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderInfoRespP2POrderInfoIsIncoming {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderInfoRespP2POrderInfoIsIncoming, v)
	}
	*j = P2POrderInfoRespP2POrderInfoIsIncoming(v)
	return nil
}

var enumValues_P2POrderInfoRespP2POrderInfoIsIncoming = []interface{}{
	0,
	1,
}
var enumValues_RealityCheckRealityCheck = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RealityCheckRealityCheck) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_RealityCheckRealityCheck {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_RealityCheckRealityCheck, v)
	}
	*j = RealityCheckRealityCheck(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoDisputeDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["dispute_reason"]; !ok || v == nil {
		return fmt.Errorf("field dispute_reason: required")
	}
	if v, ok := raw["disputer_loginid"]; !ok || v == nil {
		return fmt.Errorf("field disputer_loginid: required")
	}
	type Plain P2POrderInfoRespP2POrderInfoDisputeDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderInfoRespP2POrderInfoDisputeDetails(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RealityCheck) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["reality_check"]; !ok || v == nil {
		return fmt.Errorf("field reality_check: required")
	}
	type Plain RealityCheck
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RealityCheck(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoClientDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["loginid"]; !ok || v == nil {
		return fmt.Errorf("field loginid: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain P2POrderInfoRespP2POrderInfoClientDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderInfoRespP2POrderInfoClientDetails(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoClientDetailsIsRecommended) UnmarshalJSON(b []byte) error {
	var v struct {
		Value interface{}
	}
	if err := json.Unmarshal(b, &v.Value); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderInfoRespP2POrderInfoClientDetailsIsRecommended {
		if reflect.DeepEqual(v.Value, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderInfoRespP2POrderInfoClientDetailsIsRecommended, v.Value)
	}
	*j = P2POrderInfoRespP2POrderInfoClientDetailsIsRecommended(v)
	return nil
}

var enumValues_RealityCheckRespMsgType = []interface{}{
	"reality_check",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RealityCheckRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_RealityCheckRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_RealityCheckRespMsgType, v)
	}
	*j = RealityCheckRespMsgType(v)
	return nil
}

// MarshalJSON implements json.Marshaler.
func (j *P2POrderInfoRespP2POrderInfoClientDetailsIsRecommended) MarshalJSON() ([]byte, error) {
	return json.Marshal(j.Value)
}

var enumValues_P2POrderInfoRespP2POrderInfoClientDetailsIsRecommended = []interface{}{
	nil,
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoClientDetailsIsOnline) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderInfoRespP2POrderInfoClientDetailsIsOnline {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderInfoRespP2POrderInfoClientDetailsIsOnline, v)
	}
	*j = P2POrderInfoRespP2POrderInfoClientDetailsIsOnline(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RealityCheckResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain RealityCheckResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RealityCheckResp(plain)
	return nil
}

var enumValues_P2POrderInfoRespP2POrderInfoClientDetailsIsOnline = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoAdvertiserDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["is_online"]; !ok || v == nil {
		return fmt.Errorf("field is_online: required")
	}
	if v, ok := raw["last_online_time"]; !ok || v == nil {
		return fmt.Errorf("field last_online_time: required")
	}
	if v, ok := raw["loginid"]; !ok || v == nil {
		return fmt.Errorf("field loginid: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain P2POrderInfoRespP2POrderInfoAdvertiserDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderInfoRespP2POrderInfoAdvertiserDetails(plain)
	return nil
}

var enumValues_ResidenceListResidenceList = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResidenceListResidenceList) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ResidenceListResidenceList {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ResidenceListResidenceList, v)
	}
	*j = ResidenceListResidenceList(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoAdvertiserDetailsIsRecommended) UnmarshalJSON(b []byte) error {
	var v struct {
		Value interface{}
	}
	if err := json.Unmarshal(b, &v.Value); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderInfoRespP2POrderInfoAdvertiserDetailsIsRecommended {
		if reflect.DeepEqual(v.Value, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderInfoRespP2POrderInfoAdvertiserDetailsIsRecommended, v.Value)
	}
	*j = P2POrderInfoRespP2POrderInfoAdvertiserDetailsIsRecommended(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResidenceList) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["residence_list"]; !ok || v == nil {
		return fmt.Errorf("field residence_list: required")
	}
	type Plain ResidenceList
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ResidenceList(plain)
	return nil
}

// MarshalJSON implements json.Marshaler.
func (j *P2POrderInfoRespP2POrderInfoAdvertiserDetailsIsRecommended) MarshalJSON() ([]byte, error) {
	return json.Marshal(j.Value)
}

var enumValues_P2POrderInfoRespP2POrderInfoAdvertiserDetailsIsRecommended = []interface{}{
	nil,
	0,
	1,
}
var enumValues_ResidenceListRespMsgType = []interface{}{
	"residence_list",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResidenceListRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ResidenceListRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ResidenceListRespMsgType, v)
	}
	*j = ResidenceListRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoAdvertiserDetailsIsOnline) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderInfoRespP2POrderInfoAdvertiserDetailsIsOnline {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderInfoRespP2POrderInfoAdvertiserDetailsIsOnline, v)
	}
	*j = P2POrderInfoRespP2POrderInfoAdvertiserDetailsIsOnline(v)
	return nil
}

var enumValues_P2POrderInfoRespP2POrderInfoAdvertiserDetailsIsOnline = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoAdvertDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["block_trade"]; !ok || v == nil {
		return fmt.Errorf("field block_trade: required")
	}
	if v, ok := raw["description"]; !ok || v == nil {
		return fmt.Errorf("field description: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["payment_method"]; !ok || v == nil {
		return fmt.Errorf("field payment_method: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain P2POrderInfoRespP2POrderInfoAdvertDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderInfoRespP2POrderInfoAdvertDetails(plain)
	return nil
}

var enumValues_ResidenceListRespResidenceListElemIdentityServicesIdvHasVisualSample = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResidenceListRespResidenceListElemIdentityServicesIdvHasVisualSample) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ResidenceListRespResidenceListElemIdentityServicesIdvHasVisualSample {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ResidenceListRespResidenceListElemIdentityServicesIdvHasVisualSample, v)
	}
	*j = ResidenceListRespResidenceListElemIdentityServicesIdvHasVisualSample(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoAdvertDetailsType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderInfoRespP2POrderInfoAdvertDetailsType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderInfoRespP2POrderInfoAdvertDetailsType, v)
	}
	*j = P2POrderInfoRespP2POrderInfoAdvertDetailsType(v)
	return nil
}

var enumValues_ResidenceListRespResidenceListElemIdentityServicesIdvIsCountrySupported = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResidenceListRespResidenceListElemIdentityServicesIdvIsCountrySupported) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ResidenceListRespResidenceListElemIdentityServicesIdvIsCountrySupported {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ResidenceListRespResidenceListElemIdentityServicesIdvIsCountrySupported, v)
	}
	*j = ResidenceListRespResidenceListElemIdentityServicesIdvIsCountrySupported(v)
	return nil
}

var enumValues_P2POrderInfoRespP2POrderInfoAdvertDetailsType = []interface{}{
	"buy",
	"sell",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespP2POrderInfoAdvertDetailsBlockTrade) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderInfoRespP2POrderInfoAdvertDetailsBlockTrade {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderInfoRespP2POrderInfoAdvertDetailsBlockTrade, v)
	}
	*j = P2POrderInfoRespP2POrderInfoAdvertDetailsBlockTrade(v)
	return nil
}

var enumValues_P2POrderInfoRespP2POrderInfoAdvertDetailsBlockTrade = []interface{}{
	0,
	1,
}
var enumValues_ResidenceListRespResidenceListElemIdentityServicesOnfidoIsCountrySupported = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResidenceListRespResidenceListElemIdentityServicesOnfidoIsCountrySupported) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ResidenceListRespResidenceListElemIdentityServicesOnfidoIsCountrySupported {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ResidenceListRespResidenceListElemIdentityServicesOnfidoIsCountrySupported, v)
	}
	*j = ResidenceListRespResidenceListElemIdentityServicesOnfidoIsCountrySupported(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderInfoRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderInfoRespMsgType, v)
	}
	*j = P2POrderInfoRespMsgType(v)
	return nil
}

var enumValues_P2POrderInfoRespMsgType = []interface{}{
	"p2p_order_info",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["p2p_order_info"]; !ok || v == nil {
		return fmt.Errorf("field p2p_order_info: required")
	}
	type Plain P2POrderInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderInfo(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoSubscribe) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderInfoSubscribe {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderInfoSubscribe, v)
	}
	*j = P2POrderInfoSubscribe(v)
	return nil
}

var enumValues_P2POrderInfoSubscribe = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResidenceListResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain ResidenceListResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ResidenceListResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderInfoP2POrderInfo) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderInfoP2POrderInfo {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderInfoP2POrderInfo, v)
	}
	*j = P2POrderInfoP2POrderInfo(v)
	return nil
}

var enumValues_P2POrderInfoP2POrderInfo = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RevokeOauthApp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["revoke_oauth_app"]; !ok || v == nil {
		return fmt.Errorf("field revoke_oauth_app: required")
	}
	type Plain RevokeOauthApp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RevokeOauthApp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderDisputeResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain P2POrderDisputeResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderDisputeResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderDisputeRespP2POrderDispute) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["account_currency"]; !ok || v == nil {
		return fmt.Errorf("field account_currency: required")
	}
	if v, ok := raw["advert_details"]; !ok || v == nil {
		return fmt.Errorf("field advert_details: required")
	}
	if v, ok := raw["advertiser_details"]; !ok || v == nil {
		return fmt.Errorf("field advertiser_details: required")
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["amount_display"]; !ok || v == nil {
		return fmt.Errorf("field amount_display: required")
	}
	if v, ok := raw["chat_channel_url"]; !ok || v == nil {
		return fmt.Errorf("field chat_channel_url: required")
	}
	if v, ok := raw["client_details"]; !ok || v == nil {
		return fmt.Errorf("field client_details: required")
	}
	if v, ok := raw["contact_info"]; !ok || v == nil {
		return fmt.Errorf("field contact_info: required")
	}
	if v, ok := raw["created_time"]; !ok || v == nil {
		return fmt.Errorf("field created_time: required")
	}
	if v, ok := raw["dispute_details"]; !ok || v == nil {
		return fmt.Errorf("field dispute_details: required")
	}
	if v, ok := raw["expiry_time"]; !ok || v == nil {
		return fmt.Errorf("field expiry_time: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["is_incoming"]; !ok || v == nil {
		return fmt.Errorf("field is_incoming: required")
	}
	if v, ok := raw["is_reviewable"]; !ok || v == nil {
		return fmt.Errorf("field is_reviewable: required")
	}
	if v, ok := raw["is_seen"]; !ok || v == nil {
		return fmt.Errorf("field is_seen: required")
	}
	if v, ok := raw["local_currency"]; !ok || v == nil {
		return fmt.Errorf("field local_currency: required")
	}
	if v, ok := raw["payment_info"]; !ok || v == nil {
		return fmt.Errorf("field payment_info: required")
	}
	if v, ok := raw["price"]; !ok || v == nil {
		return fmt.Errorf("field price: required")
	}
	if v, ok := raw["price_display"]; !ok || v == nil {
		return fmt.Errorf("field price_display: required")
	}
	if v, ok := raw["rate"]; !ok || v == nil {
		return fmt.Errorf("field rate: required")
	}
	if v, ok := raw["rate_display"]; !ok || v == nil {
		return fmt.Errorf("field rate_display: required")
	}
	if v, ok := raw["status"]; !ok || v == nil {
		return fmt.Errorf("field status: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain P2POrderDisputeRespP2POrderDispute
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderDisputeRespP2POrderDispute(plain)
	return nil
}

var enumValues_RevokeOauthAppRespMsgType = []interface{}{
	"revoke_oauth_app",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RevokeOauthAppRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_RevokeOauthAppRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_RevokeOauthAppRespMsgType, v)
	}
	*j = RevokeOauthAppRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderDisputeRespP2POrderDisputeVerificationPending) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderDisputeRespP2POrderDisputeVerificationPending {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderDisputeRespP2POrderDisputeVerificationPending, v)
	}
	*j = P2POrderDisputeRespP2POrderDisputeVerificationPending(v)
	return nil
}

var enumValues_P2POrderDisputeRespP2POrderDisputeVerificationPending = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RevokeOauthAppResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain RevokeOauthAppResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RevokeOauthAppResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderDisputeRespP2POrderDisputeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderDisputeRespP2POrderDisputeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderDisputeRespP2POrderDisputeType, v)
	}
	*j = P2POrderDisputeRespP2POrderDisputeType(v)
	return nil
}

var enumValues_P2POrderDisputeRespP2POrderDisputeType = []interface{}{
	"buy",
	"sell",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Sell) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["price"]; !ok || v == nil {
		return fmt.Errorf("field price: required")
	}
	if v, ok := raw["sell"]; !ok || v == nil {
		return fmt.Errorf("field sell: required")
	}
	type Plain Sell
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Sell(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderDisputeRespP2POrderDisputeStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderDisputeRespP2POrderDisputeStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderDisputeRespP2POrderDisputeStatus, v)
	}
	*j = P2POrderDisputeRespP2POrderDisputeStatus(v)
	return nil
}

var enumValues_P2POrderDisputeRespP2POrderDisputeStatus = []interface{}{
	"pending",
	"buyer-confirmed",
	"cancelled",
	"timed-out",
	"blocked",
	"refunded",
	"completed",
	"disputed",
	"dispute-refunded",
	"dispute-completed",
}
var enumValues_SellContractForMultipleAccountsSellContractForMultipleAccounts = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SellContractForMultipleAccountsSellContractForMultipleAccounts) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SellContractForMultipleAccountsSellContractForMultipleAccounts {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SellContractForMultipleAccountsSellContractForMultipleAccounts, v)
	}
	*j = SellContractForMultipleAccountsSellContractForMultipleAccounts(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderDisputeRespP2POrderDisputeIsSeen) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderDisputeRespP2POrderDisputeIsSeen {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderDisputeRespP2POrderDisputeIsSeen, v)
	}
	*j = P2POrderDisputeRespP2POrderDisputeIsSeen(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SellContractForMultipleAccounts) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["price"]; !ok || v == nil {
		return fmt.Errorf("field price: required")
	}
	if v, ok := raw["sell_contract_for_multiple_accounts"]; !ok || v == nil {
		return fmt.Errorf("field sell_contract_for_multiple_accounts: required")
	}
	if v, ok := raw["shortcode"]; !ok || v == nil {
		return fmt.Errorf("field shortcode: required")
	}
	if v, ok := raw["tokens"]; !ok || v == nil {
		return fmt.Errorf("field tokens: required")
	}
	type Plain SellContractForMultipleAccounts
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SellContractForMultipleAccounts(plain)
	return nil
}

var enumValues_P2POrderDisputeRespP2POrderDisputeIsSeen = []interface{}{
	1,
	0,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderDisputeRespP2POrderDisputeIsReviewable) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderDisputeRespP2POrderDisputeIsReviewable {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderDisputeRespP2POrderDisputeIsReviewable, v)
	}
	*j = P2POrderDisputeRespP2POrderDisputeIsReviewable(v)
	return nil
}

var enumValues_SellContractForMultipleAccountsRespMsgType = []interface{}{
	"sell_contract_for_multiple_accounts",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SellContractForMultipleAccountsRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SellContractForMultipleAccountsRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SellContractForMultipleAccountsRespMsgType, v)
	}
	*j = SellContractForMultipleAccountsRespMsgType(v)
	return nil
}

var enumValues_P2POrderDisputeRespP2POrderDisputeIsReviewable = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderDisputeRespP2POrderDisputeIsIncoming) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderDisputeRespP2POrderDisputeIsIncoming {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderDisputeRespP2POrderDisputeIsIncoming, v)
	}
	*j = P2POrderDisputeRespP2POrderDisputeIsIncoming(v)
	return nil
}

var enumValues_P2POrderDisputeRespP2POrderDisputeIsIncoming = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SellContractForMultipleAccountsResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain SellContractForMultipleAccountsResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SellContractForMultipleAccountsResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderDisputeRespP2POrderDisputeDisputeDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["dispute_reason"]; !ok || v == nil {
		return fmt.Errorf("field dispute_reason: required")
	}
	if v, ok := raw["disputer_loginid"]; !ok || v == nil {
		return fmt.Errorf("field disputer_loginid: required")
	}
	type Plain P2POrderDisputeRespP2POrderDisputeDisputeDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderDisputeRespP2POrderDisputeDisputeDetails(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderDisputeRespP2POrderDisputeClientDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["is_online"]; !ok || v == nil {
		return fmt.Errorf("field is_online: required")
	}
	if v, ok := raw["last_online_time"]; !ok || v == nil {
		return fmt.Errorf("field last_online_time: required")
	}
	if v, ok := raw["loginid"]; !ok || v == nil {
		return fmt.Errorf("field loginid: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain P2POrderDisputeRespP2POrderDisputeClientDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderDisputeRespP2POrderDisputeClientDetails(plain)
	return nil
}

var enumValues_SellExpiredSellExpired = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SellExpiredSellExpired) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SellExpiredSellExpired {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SellExpiredSellExpired, v)
	}
	*j = SellExpiredSellExpired(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderDisputeRespP2POrderDisputeClientDetailsIsOnline) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderDisputeRespP2POrderDisputeClientDetailsIsOnline {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderDisputeRespP2POrderDisputeClientDetailsIsOnline, v)
	}
	*j = P2POrderDisputeRespP2POrderDisputeClientDetailsIsOnline(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SellExpired) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["sell_expired"]; !ok || v == nil {
		return fmt.Errorf("field sell_expired: required")
	}
	type Plain SellExpired
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SellExpired(plain)
	return nil
}

var enumValues_P2POrderDisputeRespP2POrderDisputeClientDetailsIsOnline = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderDisputeRespP2POrderDisputeAdvertiserDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["is_online"]; !ok || v == nil {
		return fmt.Errorf("field is_online: required")
	}
	if v, ok := raw["last_online_time"]; !ok || v == nil {
		return fmt.Errorf("field last_online_time: required")
	}
	if v, ok := raw["loginid"]; !ok || v == nil {
		return fmt.Errorf("field loginid: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain P2POrderDisputeRespP2POrderDisputeAdvertiserDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderDisputeRespP2POrderDisputeAdvertiserDetails(plain)
	return nil
}

var enumValues_SellExpiredRespMsgType = []interface{}{
	"sell_expired",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SellExpiredRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SellExpiredRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SellExpiredRespMsgType, v)
	}
	*j = SellExpiredRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderDisputeRespP2POrderDisputeAdvertiserDetailsIsOnline) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderDisputeRespP2POrderDisputeAdvertiserDetailsIsOnline {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderDisputeRespP2POrderDisputeAdvertiserDetailsIsOnline, v)
	}
	*j = P2POrderDisputeRespP2POrderDisputeAdvertiserDetailsIsOnline(v)
	return nil
}

var enumValues_P2POrderDisputeRespP2POrderDisputeAdvertiserDetailsIsOnline = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderDisputeRespP2POrderDisputeAdvertDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["block_trade"]; !ok || v == nil {
		return fmt.Errorf("field block_trade: required")
	}
	if v, ok := raw["description"]; !ok || v == nil {
		return fmt.Errorf("field description: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["payment_method"]; !ok || v == nil {
		return fmt.Errorf("field payment_method: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain P2POrderDisputeRespP2POrderDisputeAdvertDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderDisputeRespP2POrderDisputeAdvertDetails(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SellExpiredResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain SellExpiredResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SellExpiredResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderDisputeRespP2POrderDisputeAdvertDetailsType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderDisputeRespP2POrderDisputeAdvertDetailsType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderDisputeRespP2POrderDisputeAdvertDetailsType, v)
	}
	*j = P2POrderDisputeRespP2POrderDisputeAdvertDetailsType(v)
	return nil
}

var enumValues_P2POrderDisputeRespP2POrderDisputeAdvertDetailsType = []interface{}{
	"buy",
	"sell",
}
var enumValues_SellRespMsgType = []interface{}{
	"sell",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SellRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SellRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SellRespMsgType, v)
	}
	*j = SellRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderDisputeRespP2POrderDisputeAdvertDetailsBlockTrade) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderDisputeRespP2POrderDisputeAdvertDetailsBlockTrade {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderDisputeRespP2POrderDisputeAdvertDetailsBlockTrade, v)
	}
	*j = P2POrderDisputeRespP2POrderDisputeAdvertDetailsBlockTrade(v)
	return nil
}

var enumValues_P2POrderDisputeRespP2POrderDisputeAdvertDetailsBlockTrade = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderDisputeRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderDisputeRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderDisputeRespMsgType, v)
	}
	*j = P2POrderDisputeRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SellResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain SellResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SellResp(plain)
	return nil
}

var enumValues_P2POrderDisputeRespMsgType = []interface{}{
	"p2p_order_dispute",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderDispute) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["dispute_reason"]; !ok || v == nil {
		return fmt.Errorf("field dispute_reason: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["p2p_order_dispute"]; !ok || v == nil {
		return fmt.Errorf("field p2p_order_dispute: required")
	}
	type Plain P2POrderDispute
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderDispute(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetAccountCurrency) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["set_account_currency"]; !ok || v == nil {
		return fmt.Errorf("field set_account_currency: required")
	}
	type Plain SetAccountCurrency
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SetAccountCurrency(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderDisputeP2POrderDispute) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderDisputeP2POrderDispute {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderDisputeP2POrderDispute, v)
	}
	*j = P2POrderDisputeP2POrderDispute(v)
	return nil
}

var enumValues_P2POrderDisputeP2POrderDispute = []interface{}{
	1,
}
var enumValues_SetAccountCurrencyRespMsgType = []interface{}{
	"set_account_currency",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetAccountCurrencyRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetAccountCurrencyRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetAccountCurrencyRespMsgType, v)
	}
	*j = SetAccountCurrencyRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderDisputeDisputeReason) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderDisputeDisputeReason {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderDisputeDisputeReason, v)
	}
	*j = P2POrderDisputeDisputeReason(v)
	return nil
}

var enumValues_P2POrderDisputeDisputeReason = []interface{}{
	"seller_not_released",
	"buyer_underpaid",
	"buyer_overpaid",
	"buyer_not_paid",
	"buyer_third_party_payment_method",
}
var enumValues_SetAccountCurrencyRespSetAccountCurrency = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetAccountCurrencyRespSetAccountCurrency) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetAccountCurrencyRespSetAccountCurrency {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetAccountCurrencyRespSetAccountCurrency, v)
	}
	*j = SetAccountCurrencyRespSetAccountCurrency(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderCreateResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain P2POrderCreateResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderCreateResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetAccountCurrencyResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain SetAccountCurrencyResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SetAccountCurrencyResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderCreateRespSubscription) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	type Plain P2POrderCreateRespSubscription
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderCreateRespSubscription(plain)
	return nil
}

var enumValues_SetFinancialAssessmentAccountTurnover = []interface{}{
	"Less than $25,000",
	"$25,000 - $50,000",
	"$50,001 - $100,000",
	"$100,001 - $500,000",
	"Over $500,000",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentAccountTurnover) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentAccountTurnover {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentAccountTurnover, v)
	}
	*j = SetFinancialAssessmentAccountTurnover(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderCreateRespP2POrderCreate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["account_currency"]; !ok || v == nil {
		return fmt.Errorf("field account_currency: required")
	}
	if v, ok := raw["advert_details"]; !ok || v == nil {
		return fmt.Errorf("field advert_details: required")
	}
	if v, ok := raw["advertiser_details"]; !ok || v == nil {
		return fmt.Errorf("field advertiser_details: required")
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["amount_display"]; !ok || v == nil {
		return fmt.Errorf("field amount_display: required")
	}
	if v, ok := raw["chat_channel_url"]; !ok || v == nil {
		return fmt.Errorf("field chat_channel_url: required")
	}
	if v, ok := raw["client_details"]; !ok || v == nil {
		return fmt.Errorf("field client_details: required")
	}
	if v, ok := raw["contact_info"]; !ok || v == nil {
		return fmt.Errorf("field contact_info: required")
	}
	if v, ok := raw["created_time"]; !ok || v == nil {
		return fmt.Errorf("field created_time: required")
	}
	if v, ok := raw["dispute_details"]; !ok || v == nil {
		return fmt.Errorf("field dispute_details: required")
	}
	if v, ok := raw["expiry_time"]; !ok || v == nil {
		return fmt.Errorf("field expiry_time: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["is_incoming"]; !ok || v == nil {
		return fmt.Errorf("field is_incoming: required")
	}
	if v, ok := raw["is_reviewable"]; !ok || v == nil {
		return fmt.Errorf("field is_reviewable: required")
	}
	if v, ok := raw["is_seen"]; !ok || v == nil {
		return fmt.Errorf("field is_seen: required")
	}
	if v, ok := raw["local_currency"]; !ok || v == nil {
		return fmt.Errorf("field local_currency: required")
	}
	if v, ok := raw["payment_info"]; !ok || v == nil {
		return fmt.Errorf("field payment_info: required")
	}
	if v, ok := raw["price"]; !ok || v == nil {
		return fmt.Errorf("field price: required")
	}
	if v, ok := raw["price_display"]; !ok || v == nil {
		return fmt.Errorf("field price_display: required")
	}
	if v, ok := raw["rate"]; !ok || v == nil {
		return fmt.Errorf("field rate: required")
	}
	if v, ok := raw["rate_display"]; !ok || v == nil {
		return fmt.Errorf("field rate_display: required")
	}
	if v, ok := raw["status"]; !ok || v == nil {
		return fmt.Errorf("field status: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain P2POrderCreateRespP2POrderCreate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderCreateRespP2POrderCreate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderCreateRespP2POrderCreateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderCreateRespP2POrderCreateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderCreateRespP2POrderCreateType, v)
	}
	*j = P2POrderCreateRespP2POrderCreateType(v)
	return nil
}

var enumValues_P2POrderCreateRespP2POrderCreateType = []interface{}{
	"buy",
	"sell",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderCreateRespP2POrderCreateStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderCreateRespP2POrderCreateStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderCreateRespP2POrderCreateStatus, v)
	}
	*j = P2POrderCreateRespP2POrderCreateStatus(v)
	return nil
}

var enumValues_P2POrderCreateRespP2POrderCreateStatus = []interface{}{
	"pending",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderCreateRespP2POrderCreateIsSeen) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderCreateRespP2POrderCreateIsSeen {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderCreateRespP2POrderCreateIsSeen, v)
	}
	*j = P2POrderCreateRespP2POrderCreateIsSeen(v)
	return nil
}

var enumValues_SetFinancialAssessmentBinaryOptionsTradingExperience = []interface{}{
	"0-1 year",
	"1-2 years",
	"Over 3 years",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentBinaryOptionsTradingExperience) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentBinaryOptionsTradingExperience {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentBinaryOptionsTradingExperience, v)
	}
	*j = SetFinancialAssessmentBinaryOptionsTradingExperience(v)
	return nil
}

var enumValues_P2POrderCreateRespP2POrderCreateIsSeen = []interface{}{
	1,
	0,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderCreateRespP2POrderCreateIsReviewable) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderCreateRespP2POrderCreateIsReviewable {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderCreateRespP2POrderCreateIsReviewable, v)
	}
	*j = P2POrderCreateRespP2POrderCreateIsReviewable(v)
	return nil
}

var enumValues_P2POrderCreateRespP2POrderCreateIsReviewable = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderCreateRespP2POrderCreateIsIncoming) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderCreateRespP2POrderCreateIsIncoming {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderCreateRespP2POrderCreateIsIncoming, v)
	}
	*j = P2POrderCreateRespP2POrderCreateIsIncoming(v)
	return nil
}

var enumValues_SetFinancialAssessmentBinaryOptionsTradingFrequency = []interface{}{
	"0-5 transactions in the past 12 months",
	"6-10 transactions in the past 12 months",
	"11-39 transactions in the past 12 months",
	"40 transactions or more in the past 12 months",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentBinaryOptionsTradingFrequency) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentBinaryOptionsTradingFrequency {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentBinaryOptionsTradingFrequency, v)
	}
	*j = SetFinancialAssessmentBinaryOptionsTradingFrequency(v)
	return nil
}

var enumValues_P2POrderCreateRespP2POrderCreateIsIncoming = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderCreateRespP2POrderCreateDisputeDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["dispute_reason"]; !ok || v == nil {
		return fmt.Errorf("field dispute_reason: required")
	}
	if v, ok := raw["disputer_loginid"]; !ok || v == nil {
		return fmt.Errorf("field disputer_loginid: required")
	}
	type Plain P2POrderCreateRespP2POrderCreateDisputeDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderCreateRespP2POrderCreateDisputeDetails(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderCreateRespP2POrderCreateClientDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["is_online"]; !ok || v == nil {
		return fmt.Errorf("field is_online: required")
	}
	if v, ok := raw["last_online_time"]; !ok || v == nil {
		return fmt.Errorf("field last_online_time: required")
	}
	if v, ok := raw["loginid"]; !ok || v == nil {
		return fmt.Errorf("field loginid: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain P2POrderCreateRespP2POrderCreateClientDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderCreateRespP2POrderCreateClientDetails(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderCreateRespP2POrderCreateClientDetailsIsOnline) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderCreateRespP2POrderCreateClientDetailsIsOnline {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderCreateRespP2POrderCreateClientDetailsIsOnline, v)
	}
	*j = P2POrderCreateRespP2POrderCreateClientDetailsIsOnline(v)
	return nil
}

var enumValues_P2POrderCreateRespP2POrderCreateClientDetailsIsOnline = []interface{}{
	0,
	1,
}
var enumValues_SetFinancialAssessmentCfdTradingExperience = []interface{}{
	"0-1 year",
	"1-2 years",
	"Over 3 years",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentCfdTradingExperience) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentCfdTradingExperience {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentCfdTradingExperience, v)
	}
	*j = SetFinancialAssessmentCfdTradingExperience(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderCreateRespP2POrderCreateAdvertiserDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["is_online"]; !ok || v == nil {
		return fmt.Errorf("field is_online: required")
	}
	if v, ok := raw["last_online_time"]; !ok || v == nil {
		return fmt.Errorf("field last_online_time: required")
	}
	if v, ok := raw["loginid"]; !ok || v == nil {
		return fmt.Errorf("field loginid: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain P2POrderCreateRespP2POrderCreateAdvertiserDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderCreateRespP2POrderCreateAdvertiserDetails(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderCreateRespP2POrderCreateAdvertiserDetailsIsOnline) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderCreateRespP2POrderCreateAdvertiserDetailsIsOnline {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderCreateRespP2POrderCreateAdvertiserDetailsIsOnline, v)
	}
	*j = P2POrderCreateRespP2POrderCreateAdvertiserDetailsIsOnline(v)
	return nil
}

var enumValues_P2POrderCreateRespP2POrderCreateAdvertiserDetailsIsOnline = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderCreateRespP2POrderCreateAdvertDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["block_trade"]; !ok || v == nil {
		return fmt.Errorf("field block_trade: required")
	}
	if v, ok := raw["description"]; !ok || v == nil {
		return fmt.Errorf("field description: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["payment_method"]; !ok || v == nil {
		return fmt.Errorf("field payment_method: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain P2POrderCreateRespP2POrderCreateAdvertDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderCreateRespP2POrderCreateAdvertDetails(plain)
	return nil
}

var enumValues_SetFinancialAssessmentCfdTradingFrequency = []interface{}{
	"0-5 transactions in the past 12 months",
	"6-10 transactions in the past 12 months",
	"11-39 transactions in the past 12 months",
	"40 transactions or more in the past 12 months",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentCfdTradingFrequency) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentCfdTradingFrequency {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentCfdTradingFrequency, v)
	}
	*j = SetFinancialAssessmentCfdTradingFrequency(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderCreateRespP2POrderCreateAdvertDetailsType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderCreateRespP2POrderCreateAdvertDetailsType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderCreateRespP2POrderCreateAdvertDetailsType, v)
	}
	*j = P2POrderCreateRespP2POrderCreateAdvertDetailsType(v)
	return nil
}

var enumValues_P2POrderCreateRespP2POrderCreateAdvertDetailsType = []interface{}{
	"buy",
	"sell",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderCreateRespP2POrderCreateAdvertDetailsBlockTrade) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderCreateRespP2POrderCreateAdvertDetailsBlockTrade {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderCreateRespP2POrderCreateAdvertDetailsBlockTrade, v)
	}
	*j = P2POrderCreateRespP2POrderCreateAdvertDetailsBlockTrade(v)
	return nil
}

var enumValues_P2POrderCreateRespP2POrderCreateAdvertDetailsBlockTrade = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderCreateRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderCreateRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderCreateRespMsgType, v)
	}
	*j = P2POrderCreateRespMsgType(v)
	return nil
}

var enumValues_SetFinancialAssessmentEducationLevel = []interface{}{
	"Primary",
	"Secondary",
	"Tertiary",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentEducationLevel) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentEducationLevel {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentEducationLevel, v)
	}
	*j = SetFinancialAssessmentEducationLevel(v)
	return nil
}

var enumValues_P2POrderCreateRespMsgType = []interface{}{
	"p2p_order_create",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderCreate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["advert_id"]; !ok || v == nil {
		return fmt.Errorf("field advert_id: required")
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["p2p_order_create"]; !ok || v == nil {
		return fmt.Errorf("field p2p_order_create: required")
	}
	type Plain P2POrderCreate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderCreate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderCreateSubscribe) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderCreateSubscribe {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderCreateSubscribe, v)
	}
	*j = P2POrderCreateSubscribe(v)
	return nil
}

var enumValues_P2POrderCreateSubscribe = []interface{}{
	1,
}
var enumValues_SetFinancialAssessmentEmploymentIndustry = []interface{}{
	"Construction",
	"Education",
	"Finance",
	"Health",
	"Tourism",
	"Information & Communications Technology",
	"Science & Engineering",
	"Legal",
	"Social & Cultural",
	"Agriculture",
	"Real Estate",
	"Food Services",
	"Manufacturing",
	"Unemployed",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentEmploymentIndustry) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentEmploymentIndustry {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentEmploymentIndustry, v)
	}
	*j = SetFinancialAssessmentEmploymentIndustry(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderCreateP2POrderCreate) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderCreateP2POrderCreate {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderCreateP2POrderCreate, v)
	}
	*j = P2POrderCreateP2POrderCreate(v)
	return nil
}

var enumValues_P2POrderCreateP2POrderCreate = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderConfirmResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain P2POrderConfirmResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderConfirmResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderConfirmRespP2POrderConfirm) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	type Plain P2POrderConfirmRespP2POrderConfirm
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderConfirmRespP2POrderConfirm(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderConfirmRespP2POrderConfirmStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderConfirmRespP2POrderConfirmStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderConfirmRespP2POrderConfirmStatus, v)
	}
	*j = P2POrderConfirmRespP2POrderConfirmStatus(v)
	return nil
}

var enumValues_P2POrderConfirmRespP2POrderConfirmStatus = []interface{}{
	"buyer-confirmed",
	"completed",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderConfirmRespP2POrderConfirmDryRun) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderConfirmRespP2POrderConfirmDryRun {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderConfirmRespP2POrderConfirmDryRun, v)
	}
	*j = P2POrderConfirmRespP2POrderConfirmDryRun(v)
	return nil
}

var enumValues_P2POrderConfirmRespP2POrderConfirmDryRun = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderConfirmRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderConfirmRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderConfirmRespMsgType, v)
	}
	*j = P2POrderConfirmRespMsgType(v)
	return nil
}

var enumValues_P2POrderConfirmRespMsgType = []interface{}{
	"p2p_order_confirm",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderConfirm) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["p2p_order_confirm"]; !ok || v == nil {
		return fmt.Errorf("field p2p_order_confirm: required")
	}
	type Plain P2POrderConfirm
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["dry_run"]; !ok || v == nil {
		plain.DryRun = 0
	}
	*j = P2POrderConfirm(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderConfirmP2POrderConfirm) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderConfirmP2POrderConfirm {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderConfirmP2POrderConfirm, v)
	}
	*j = P2POrderConfirmP2POrderConfirm(v)
	return nil
}

var enumValues_P2POrderConfirmP2POrderConfirm = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderConfirmDryRun) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderConfirmDryRun {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderConfirmDryRun, v)
	}
	*j = P2POrderConfirmDryRun(v)
	return nil
}

var enumValues_P2POrderConfirmDryRun = []interface{}{
	0,
	1,
}
var enumValues_SetFinancialAssessmentEmploymentStatus = []interface{}{
	"Employed",
	"Pensioner",
	"Self-Employed",
	"Student",
	"Unemployed",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentEmploymentStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentEmploymentStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentEmploymentStatus, v)
	}
	*j = SetFinancialAssessmentEmploymentStatus(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderCancelResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain P2POrderCancelResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderCancelResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderCancelRespP2POrderCancel) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["status"]; !ok || v == nil {
		return fmt.Errorf("field status: required")
	}
	type Plain P2POrderCancelRespP2POrderCancel
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderCancelRespP2POrderCancel(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderCancelRespP2POrderCancelStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderCancelRespP2POrderCancelStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderCancelRespP2POrderCancelStatus, v)
	}
	*j = P2POrderCancelRespP2POrderCancelStatus(v)
	return nil
}

var enumValues_P2POrderCancelRespP2POrderCancelStatus = []interface{}{
	"cancelled",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderCancelRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderCancelRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderCancelRespMsgType, v)
	}
	*j = P2POrderCancelRespMsgType(v)
	return nil
}

var enumValues_P2POrderCancelRespMsgType = []interface{}{
	"p2p_order_cancel",
}
var enumValues_SetFinancialAssessmentEstimatedWorth = []interface{}{
	"Less than $100,000",
	"$100,000 - $250,000",
	"$250,001 - $500,000",
	"$500,001 - $1,000,000",
	"Over $1,000,000",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentEstimatedWorth) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentEstimatedWorth {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentEstimatedWorth, v)
	}
	*j = SetFinancialAssessmentEstimatedWorth(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderCancel) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["p2p_order_cancel"]; !ok || v == nil {
		return fmt.Errorf("field p2p_order_cancel: required")
	}
	type Plain P2POrderCancel
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2POrderCancel(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2POrderCancelP2POrderCancel) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2POrderCancelP2POrderCancel {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2POrderCancelP2POrderCancel, v)
	}
	*j = P2POrderCancelP2POrderCancel(v)
	return nil
}

var enumValues_P2POrderCancelP2POrderCancel = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PChatCreateResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain P2PChatCreateResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PChatCreateResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PChatCreateRespP2PChatCreate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["channel_url"]; !ok || v == nil {
		return fmt.Errorf("field channel_url: required")
	}
	if v, ok := raw["order_id"]; !ok || v == nil {
		return fmt.Errorf("field order_id: required")
	}
	type Plain P2PChatCreateRespP2PChatCreate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PChatCreateRespP2PChatCreate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PChatCreateRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PChatCreateRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PChatCreateRespMsgType, v)
	}
	*j = P2PChatCreateRespMsgType(v)
	return nil
}

var enumValues_SetFinancialAssessmentFinancialInformationAccountTurnover = []interface{}{
	"Less than $25,000",
	"$25,000 - $50,000",
	"$50,001 - $100,000",
	"$100,001 - $500,000",
	"Over $500,000",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentFinancialInformationAccountTurnover) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentFinancialInformationAccountTurnover {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentFinancialInformationAccountTurnover, v)
	}
	*j = SetFinancialAssessmentFinancialInformationAccountTurnover(v)
	return nil
}

var enumValues_P2PChatCreateRespMsgType = []interface{}{
	"p2p_chat_create",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PChatCreate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["order_id"]; !ok || v == nil {
		return fmt.Errorf("field order_id: required")
	}
	if v, ok := raw["p2p_chat_create"]; !ok || v == nil {
		return fmt.Errorf("field p2p_chat_create: required")
	}
	type Plain P2PChatCreate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PChatCreate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PChatCreateP2PChatCreate) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PChatCreateP2PChatCreate {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PChatCreateP2PChatCreate, v)
	}
	*j = P2PChatCreateP2PChatCreate(v)
	return nil
}

var enumValues_P2PChatCreateP2PChatCreate = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserUpdateResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain P2PAdvertiserUpdateResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertiserUpdateResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserUpdateRespP2PAdvertiserUpdate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["advert_rates"]; !ok || v == nil {
		return fmt.Errorf("field advert_rates: required")
	}
	if v, ok := raw["balance_available"]; !ok || v == nil {
		return fmt.Errorf("field balance_available: required")
	}
	if v, ok := raw["basic_verification"]; !ok || v == nil {
		return fmt.Errorf("field basic_verification: required")
	}
	if v, ok := raw["blocked_by_count"]; !ok || v == nil {
		return fmt.Errorf("field blocked_by_count: required")
	}
	if v, ok := raw["buy_completion_rate"]; !ok || v == nil {
		return fmt.Errorf("field buy_completion_rate: required")
	}
	if v, ok := raw["buy_orders_amount"]; !ok || v == nil {
		return fmt.Errorf("field buy_orders_amount: required")
	}
	if v, ok := raw["buy_orders_count"]; !ok || v == nil {
		return fmt.Errorf("field buy_orders_count: required")
	}
	if v, ok := raw["buy_time_avg"]; !ok || v == nil {
		return fmt.Errorf("field buy_time_avg: required")
	}
	if v, ok := raw["cancel_time_avg"]; !ok || v == nil {
		return fmt.Errorf("field cancel_time_avg: required")
	}
	if v, ok := raw["cancels_remaining"]; !ok || v == nil {
		return fmt.Errorf("field cancels_remaining: required")
	}
	if v, ok := raw["chat_token"]; !ok || v == nil {
		return fmt.Errorf("field chat_token: required")
	}
	if v, ok := raw["chat_user_id"]; !ok || v == nil {
		return fmt.Errorf("field chat_user_id: required")
	}
	if v, ok := raw["contact_info"]; !ok || v == nil {
		return fmt.Errorf("field contact_info: required")
	}
	if v, ok := raw["created_time"]; !ok || v == nil {
		return fmt.Errorf("field created_time: required")
	}
	if v, ok := raw["default_advert_description"]; !ok || v == nil {
		return fmt.Errorf("field default_advert_description: required")
	}
	if v, ok := raw["full_verification"]; !ok || v == nil {
		return fmt.Errorf("field full_verification: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["is_approved"]; !ok || v == nil {
		return fmt.Errorf("field is_approved: required")
	}
	if v, ok := raw["is_listed"]; !ok || v == nil {
		return fmt.Errorf("field is_listed: required")
	}
	if v, ok := raw["is_online"]; !ok || v == nil {
		return fmt.Errorf("field is_online: required")
	}
	if v, ok := raw["last_online_time"]; !ok || v == nil {
		return fmt.Errorf("field last_online_time: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["partner_count"]; !ok || v == nil {
		return fmt.Errorf("field partner_count: required")
	}
	if v, ok := raw["payment_info"]; !ok || v == nil {
		return fmt.Errorf("field payment_info: required")
	}
	if v, ok := raw["rating_average"]; !ok || v == nil {
		return fmt.Errorf("field rating_average: required")
	}
	if v, ok := raw["rating_count"]; !ok || v == nil {
		return fmt.Errorf("field rating_count: required")
	}
	if v, ok := raw["recommended_average"]; !ok || v == nil {
		return fmt.Errorf("field recommended_average: required")
	}
	if v, ok := raw["recommended_count"]; !ok || v == nil {
		return fmt.Errorf("field recommended_count: required")
	}
	if v, ok := raw["release_time_avg"]; !ok || v == nil {
		return fmt.Errorf("field release_time_avg: required")
	}
	if v, ok := raw["sell_completion_rate"]; !ok || v == nil {
		return fmt.Errorf("field sell_completion_rate: required")
	}
	if v, ok := raw["sell_orders_amount"]; !ok || v == nil {
		return fmt.Errorf("field sell_orders_amount: required")
	}
	if v, ok := raw["sell_orders_count"]; !ok || v == nil {
		return fmt.Errorf("field sell_orders_count: required")
	}
	if v, ok := raw["show_name"]; !ok || v == nil {
		return fmt.Errorf("field show_name: required")
	}
	if v, ok := raw["total_completion_rate"]; !ok || v == nil {
		return fmt.Errorf("field total_completion_rate: required")
	}
	if v, ok := raw["total_orders_count"]; !ok || v == nil {
		return fmt.Errorf("field total_orders_count: required")
	}
	if v, ok := raw["total_turnover"]; !ok || v == nil {
		return fmt.Errorf("field total_turnover: required")
	}
	type Plain P2PAdvertiserUpdateRespP2PAdvertiserUpdate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertiserUpdateRespP2PAdvertiserUpdate(plain)
	return nil
}

var enumValues_SetFinancialAssessmentFinancialInformationEducationLevel = []interface{}{
	"Primary",
	"Secondary",
	"Tertiary",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentFinancialInformationEducationLevel) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentFinancialInformationEducationLevel {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentFinancialInformationEducationLevel, v)
	}
	*j = SetFinancialAssessmentFinancialInformationEducationLevel(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserUpdateRespP2PAdvertiserUpdateUpgradableDailyLimits) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["max_daily_buy"]; !ok || v == nil {
		return fmt.Errorf("field max_daily_buy: required")
	}
	if v, ok := raw["max_daily_sell"]; !ok || v == nil {
		return fmt.Errorf("field max_daily_sell: required")
	}
	type Plain P2PAdvertiserUpdateRespP2PAdvertiserUpdateUpgradableDailyLimits
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertiserUpdateRespP2PAdvertiserUpdateUpgradableDailyLimits(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserUpdateRespP2PAdvertiserUpdateUpgradableDailyLimitsBlockTrade) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserUpdateRespP2PAdvertiserUpdateUpgradableDailyLimitsBlockTrade {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserUpdateRespP2PAdvertiserUpdateUpgradableDailyLimitsBlockTrade, v)
	}
	*j = P2PAdvertiserUpdateRespP2PAdvertiserUpdateUpgradableDailyLimitsBlockTrade(v)
	return nil
}

var enumValues_P2PAdvertiserUpdateRespP2PAdvertiserUpdateUpgradableDailyLimitsBlockTrade = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserUpdateRespP2PAdvertiserUpdateShowName) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserUpdateRespP2PAdvertiserUpdateShowName {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserUpdateRespP2PAdvertiserUpdateShowName, v)
	}
	*j = P2PAdvertiserUpdateRespP2PAdvertiserUpdateShowName(v)
	return nil
}

var enumValues_SetFinancialAssessmentFinancialInformationEmploymentIndustry = []interface{}{
	"Construction",
	"Education",
	"Finance",
	"Health",
	"Tourism",
	"Information & Communications Technology",
	"Science & Engineering",
	"Legal",
	"Social & Cultural",
	"Agriculture",
	"Real Estate",
	"Food Services",
	"Manufacturing",
	"Unemployed",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentFinancialInformationEmploymentIndustry) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentFinancialInformationEmploymentIndustry {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentFinancialInformationEmploymentIndustry, v)
	}
	*j = SetFinancialAssessmentFinancialInformationEmploymentIndustry(v)
	return nil
}

var enumValues_P2PAdvertiserUpdateRespP2PAdvertiserUpdateShowName = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserUpdateRespP2PAdvertiserUpdateIsOnline) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserUpdateRespP2PAdvertiserUpdateIsOnline {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserUpdateRespP2PAdvertiserUpdateIsOnline, v)
	}
	*j = P2PAdvertiserUpdateRespP2PAdvertiserUpdateIsOnline(v)
	return nil
}

var enumValues_P2PAdvertiserUpdateRespP2PAdvertiserUpdateIsOnline = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserUpdateRespP2PAdvertiserUpdateIsListed) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserUpdateRespP2PAdvertiserUpdateIsListed {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserUpdateRespP2PAdvertiserUpdateIsListed, v)
	}
	*j = P2PAdvertiserUpdateRespP2PAdvertiserUpdateIsListed(v)
	return nil
}

var enumValues_P2PAdvertiserUpdateRespP2PAdvertiserUpdateIsListed = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserUpdateRespP2PAdvertiserUpdateIsApproved) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserUpdateRespP2PAdvertiserUpdateIsApproved {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserUpdateRespP2PAdvertiserUpdateIsApproved, v)
	}
	*j = P2PAdvertiserUpdateRespP2PAdvertiserUpdateIsApproved(v)
	return nil
}

var enumValues_P2PAdvertiserUpdateRespP2PAdvertiserUpdateIsApproved = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserUpdateRespP2PAdvertiserUpdateFullVerification) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserUpdateRespP2PAdvertiserUpdateFullVerification {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserUpdateRespP2PAdvertiserUpdateFullVerification, v)
	}
	*j = P2PAdvertiserUpdateRespP2PAdvertiserUpdateFullVerification(v)
	return nil
}

var enumValues_P2PAdvertiserUpdateRespP2PAdvertiserUpdateFullVerification = []interface{}{
	1,
	0,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserUpdateRespP2PAdvertiserUpdateBlockTrade) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["max_order_amount"]; !ok || v == nil {
		return fmt.Errorf("field max_order_amount: required")
	}
	if v, ok := raw["min_order_amount"]; !ok || v == nil {
		return fmt.Errorf("field min_order_amount: required")
	}
	type Plain P2PAdvertiserUpdateRespP2PAdvertiserUpdateBlockTrade
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertiserUpdateRespP2PAdvertiserUpdateBlockTrade(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserUpdateRespP2PAdvertiserUpdateBasicVerification) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserUpdateRespP2PAdvertiserUpdateBasicVerification {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserUpdateRespP2PAdvertiserUpdateBasicVerification, v)
	}
	*j = P2PAdvertiserUpdateRespP2PAdvertiserUpdateBasicVerification(v)
	return nil
}

var enumValues_P2PAdvertiserUpdateRespP2PAdvertiserUpdateBasicVerification = []interface{}{
	1,
	0,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserUpdateRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserUpdateRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserUpdateRespMsgType, v)
	}
	*j = P2PAdvertiserUpdateRespMsgType(v)
	return nil
}

var enumValues_P2PAdvertiserUpdateRespMsgType = []interface{}{
	"p2p_advertiser_update",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserUpdate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["p2p_advertiser_update"]; !ok || v == nil {
		return fmt.Errorf("field p2p_advertiser_update: required")
	}
	type Plain P2PAdvertiserUpdate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertiserUpdate(plain)
	return nil
}

var enumValues_SetFinancialAssessmentFinancialInformationEmploymentStatus = []interface{}{
	"Employed",
	"Pensioner",
	"Self-Employed",
	"Student",
	"Unemployed",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentFinancialInformationEmploymentStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentFinancialInformationEmploymentStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentFinancialInformationEmploymentStatus, v)
	}
	*j = SetFinancialAssessmentFinancialInformationEmploymentStatus(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserUpdateUpgradeLimits) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserUpdateUpgradeLimits {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserUpdateUpgradeLimits, v)
	}
	*j = P2PAdvertiserUpdateUpgradeLimits(v)
	return nil
}

var enumValues_P2PAdvertiserUpdateUpgradeLimits = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserUpdateShowName) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserUpdateShowName {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserUpdateShowName, v)
	}
	*j = P2PAdvertiserUpdateShowName(v)
	return nil
}

var enumValues_P2PAdvertiserUpdateShowName = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserUpdateP2PAdvertiserUpdate) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserUpdateP2PAdvertiserUpdate {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserUpdateP2PAdvertiserUpdate, v)
	}
	*j = P2PAdvertiserUpdateP2PAdvertiserUpdate(v)
	return nil
}

var enumValues_P2PAdvertiserUpdateP2PAdvertiserUpdate = []interface{}{
	1,
}
var enumValues_SetFinancialAssessmentFinancialInformationEstimatedWorth = []interface{}{
	"Less than $100,000",
	"$100,000 - $250,000",
	"$250,001 - $500,000",
	"$500,001 - $1,000,000",
	"Over $1,000,000",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentFinancialInformationEstimatedWorth) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentFinancialInformationEstimatedWorth {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentFinancialInformationEstimatedWorth, v)
	}
	*j = SetFinancialAssessmentFinancialInformationEstimatedWorth(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserUpdateIsListed) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserUpdateIsListed {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserUpdateIsListed, v)
	}
	*j = P2PAdvertiserUpdateIsListed(v)
	return nil
}

var enumValues_P2PAdvertiserUpdateIsListed = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserRelationsResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain P2PAdvertiserRelationsResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertiserRelationsResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserRelationsRespP2PAdvertiserRelations) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["blocked_advertisers"]; !ok || v == nil {
		return fmt.Errorf("field blocked_advertisers: required")
	}
	if v, ok := raw["favourite_advertisers"]; !ok || v == nil {
		return fmt.Errorf("field favourite_advertisers: required")
	}
	type Plain P2PAdvertiserRelationsRespP2PAdvertiserRelations
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertiserRelationsRespP2PAdvertiserRelations(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserRelationsRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserRelationsRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserRelationsRespMsgType, v)
	}
	*j = P2PAdvertiserRelationsRespMsgType(v)
	return nil
}

var enumValues_P2PAdvertiserRelationsRespMsgType = []interface{}{
	"p2p_advertiser_relations",
}
var enumValues_SetFinancialAssessmentFinancialInformationIncomeSource = []interface{}{
	"Salaried Employee",
	"Self-Employed",
	"Investments & Dividends",
	"Pension",
	"State Benefits",
	"Savings & Inheritance",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentFinancialInformationIncomeSource) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentFinancialInformationIncomeSource {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentFinancialInformationIncomeSource, v)
	}
	*j = SetFinancialAssessmentFinancialInformationIncomeSource(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserRelations) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["p2p_advertiser_relations"]; !ok || v == nil {
		return fmt.Errorf("field p2p_advertiser_relations: required")
	}
	type Plain P2PAdvertiserRelations
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertiserRelations(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserRelationsP2PAdvertiserRelations) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserRelationsP2PAdvertiserRelations {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserRelationsP2PAdvertiserRelations, v)
	}
	*j = P2PAdvertiserRelationsP2PAdvertiserRelations(v)
	return nil
}

var enumValues_P2PAdvertiserRelationsP2PAdvertiserRelations = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserPaymentMethodsResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain P2PAdvertiserPaymentMethodsResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertiserPaymentMethodsResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserPaymentMethodsRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserPaymentMethodsRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserPaymentMethodsRespMsgType, v)
	}
	*j = P2PAdvertiserPaymentMethodsRespMsgType(v)
	return nil
}

var enumValues_P2PAdvertiserPaymentMethodsRespMsgType = []interface{}{
	"p2p_advertiser_payment_methods",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserPaymentMethods) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["p2p_advertiser_payment_methods"]; !ok || v == nil {
		return fmt.Errorf("field p2p_advertiser_payment_methods: required")
	}
	type Plain P2PAdvertiserPaymentMethods
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertiserPaymentMethods(plain)
	return nil
}

var enumValues_SetFinancialAssessmentFinancialInformationNetIncome = []interface{}{
	"Less than $25,000",
	"$25,000 - $50,000",
	"$50,001 - $100,000",
	"$100,001 - $500,000",
	"Over $500,000",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentFinancialInformationNetIncome) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentFinancialInformationNetIncome {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentFinancialInformationNetIncome, v)
	}
	*j = SetFinancialAssessmentFinancialInformationNetIncome(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserPaymentMethodsP2PAdvertiserPaymentMethods) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserPaymentMethodsP2PAdvertiserPaymentMethods {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserPaymentMethodsP2PAdvertiserPaymentMethods, v)
	}
	*j = P2PAdvertiserPaymentMethodsP2PAdvertiserPaymentMethods(v)
	return nil
}

var enumValues_P2PAdvertiserPaymentMethodsP2PAdvertiserPaymentMethods = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserPaymentMethodsCreateElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["method"]; !ok || v == nil {
		return fmt.Errorf("field method: required")
	}
	type Plain P2PAdvertiserPaymentMethodsCreateElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertiserPaymentMethodsCreateElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserListResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain P2PAdvertiserListResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertiserListResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserListRespP2PAdvertiserList) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["list"]; !ok || v == nil {
		return fmt.Errorf("field list: required")
	}
	type Plain P2PAdvertiserListRespP2PAdvertiserList
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertiserListRespP2PAdvertiserList(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserListRespP2PAdvertiserListListElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["advert_rates"]; !ok || v == nil {
		return fmt.Errorf("field advert_rates: required")
	}
	if v, ok := raw["basic_verification"]; !ok || v == nil {
		return fmt.Errorf("field basic_verification: required")
	}
	if v, ok := raw["buy_completion_rate"]; !ok || v == nil {
		return fmt.Errorf("field buy_completion_rate: required")
	}
	if v, ok := raw["buy_orders_amount"]; !ok || v == nil {
		return fmt.Errorf("field buy_orders_amount: required")
	}
	if v, ok := raw["buy_orders_count"]; !ok || v == nil {
		return fmt.Errorf("field buy_orders_count: required")
	}
	if v, ok := raw["buy_time_avg"]; !ok || v == nil {
		return fmt.Errorf("field buy_time_avg: required")
	}
	if v, ok := raw["cancel_time_avg"]; !ok || v == nil {
		return fmt.Errorf("field cancel_time_avg: required")
	}
	if v, ok := raw["created_time"]; !ok || v == nil {
		return fmt.Errorf("field created_time: required")
	}
	if v, ok := raw["default_advert_description"]; !ok || v == nil {
		return fmt.Errorf("field default_advert_description: required")
	}
	if v, ok := raw["full_verification"]; !ok || v == nil {
		return fmt.Errorf("field full_verification: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["is_approved"]; !ok || v == nil {
		return fmt.Errorf("field is_approved: required")
	}
	if v, ok := raw["is_blocked"]; !ok || v == nil {
		return fmt.Errorf("field is_blocked: required")
	}
	if v, ok := raw["is_listed"]; !ok || v == nil {
		return fmt.Errorf("field is_listed: required")
	}
	if v, ok := raw["is_online"]; !ok || v == nil {
		return fmt.Errorf("field is_online: required")
	}
	if v, ok := raw["last_online_time"]; !ok || v == nil {
		return fmt.Errorf("field last_online_time: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["partner_count"]; !ok || v == nil {
		return fmt.Errorf("field partner_count: required")
	}
	if v, ok := raw["rating_average"]; !ok || v == nil {
		return fmt.Errorf("field rating_average: required")
	}
	if v, ok := raw["rating_count"]; !ok || v == nil {
		return fmt.Errorf("field rating_count: required")
	}
	if v, ok := raw["recommended_average"]; !ok || v == nil {
		return fmt.Errorf("field recommended_average: required")
	}
	if v, ok := raw["recommended_count"]; !ok || v == nil {
		return fmt.Errorf("field recommended_count: required")
	}
	if v, ok := raw["release_time_avg"]; !ok || v == nil {
		return fmt.Errorf("field release_time_avg: required")
	}
	if v, ok := raw["sell_completion_rate"]; !ok || v == nil {
		return fmt.Errorf("field sell_completion_rate: required")
	}
	if v, ok := raw["sell_orders_amount"]; !ok || v == nil {
		return fmt.Errorf("field sell_orders_amount: required")
	}
	if v, ok := raw["sell_orders_count"]; !ok || v == nil {
		return fmt.Errorf("field sell_orders_count: required")
	}
	if v, ok := raw["total_completion_rate"]; !ok || v == nil {
		return fmt.Errorf("field total_completion_rate: required")
	}
	if v, ok := raw["total_orders_count"]; !ok || v == nil {
		return fmt.Errorf("field total_orders_count: required")
	}
	if v, ok := raw["total_turnover"]; !ok || v == nil {
		return fmt.Errorf("field total_turnover: required")
	}
	type Plain P2PAdvertiserListRespP2PAdvertiserListListElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertiserListRespP2PAdvertiserListListElem(plain)
	return nil
}

var enumValues_SetFinancialAssessmentFinancialInformationOccupation = []interface{}{
	"Chief Executives, Senior Officials and Legislators",
	"Managers",
	"Professionals",
	"Clerks",
	"Personal Care, Sales and Service Workers",
	"Agricultural, Forestry and Fishery Workers",
	"Craft, Metal, Electrical and Electronics Workers",
	"Plant and Machine Operators and Assemblers",
	"Cleaners and Helpers",
	"Mining, Construction, Manufacturing and Transport Workers",
	"Armed Forces",
	"Government Officers",
	"Students",
	"Unemployed",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentFinancialInformationOccupation) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentFinancialInformationOccupation {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentFinancialInformationOccupation, v)
	}
	*j = SetFinancialAssessmentFinancialInformationOccupation(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserListRespP2PAdvertiserListListElemIsRecommended) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserListRespP2PAdvertiserListListElemIsRecommended {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserListRespP2PAdvertiserListListElemIsRecommended, v)
	}
	*j = P2PAdvertiserListRespP2PAdvertiserListListElemIsRecommended(v)
	return nil
}

var enumValues_P2PAdvertiserListRespP2PAdvertiserListListElemIsRecommended = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserListRespP2PAdvertiserListListElemIsOnline) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserListRespP2PAdvertiserListListElemIsOnline {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserListRespP2PAdvertiserListListElemIsOnline, v)
	}
	*j = P2PAdvertiserListRespP2PAdvertiserListListElemIsOnline(v)
	return nil
}

var enumValues_P2PAdvertiserListRespP2PAdvertiserListListElemIsOnline = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserListRespP2PAdvertiserListListElemIsListed) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserListRespP2PAdvertiserListListElemIsListed {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserListRespP2PAdvertiserListListElemIsListed, v)
	}
	*j = P2PAdvertiserListRespP2PAdvertiserListListElemIsListed(v)
	return nil
}

var enumValues_P2PAdvertiserListRespP2PAdvertiserListListElemIsListed = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserListRespP2PAdvertiserListListElemIsFavourite) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserListRespP2PAdvertiserListListElemIsFavourite {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserListRespP2PAdvertiserListListElemIsFavourite, v)
	}
	*j = P2PAdvertiserListRespP2PAdvertiserListListElemIsFavourite(v)
	return nil
}

var enumValues_P2PAdvertiserListRespP2PAdvertiserListListElemIsFavourite = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserListRespP2PAdvertiserListListElemIsBlocked) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserListRespP2PAdvertiserListListElemIsBlocked {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserListRespP2PAdvertiserListListElemIsBlocked, v)
	}
	*j = P2PAdvertiserListRespP2PAdvertiserListListElemIsBlocked(v)
	return nil
}

var enumValues_P2PAdvertiserListRespP2PAdvertiserListListElemIsBlocked = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserListRespP2PAdvertiserListListElemIsApproved) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserListRespP2PAdvertiserListListElemIsApproved {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserListRespP2PAdvertiserListListElemIsApproved, v)
	}
	*j = P2PAdvertiserListRespP2PAdvertiserListListElemIsApproved(v)
	return nil
}

var enumValues_P2PAdvertiserListRespP2PAdvertiserListListElemIsApproved = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserListRespP2PAdvertiserListListElemFullVerification) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserListRespP2PAdvertiserListListElemFullVerification {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserListRespP2PAdvertiserListListElemFullVerification, v)
	}
	*j = P2PAdvertiserListRespP2PAdvertiserListListElemFullVerification(v)
	return nil
}

var enumValues_P2PAdvertiserListRespP2PAdvertiserListListElemFullVerification = []interface{}{
	1,
	0,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserListRespP2PAdvertiserListListElemBasicVerification) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserListRespP2PAdvertiserListListElemBasicVerification {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserListRespP2PAdvertiserListListElemBasicVerification, v)
	}
	*j = P2PAdvertiserListRespP2PAdvertiserListListElemBasicVerification(v)
	return nil
}

var enumValues_SetFinancialAssessmentFinancialInformationSourceOfWealth = []interface{}{
	"Accumulation of Income/Savings",
	"Cash Business",
	"Company Ownership",
	"Divorce Settlement",
	"Inheritance",
	"Investment Income",
	"Sale of Property",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentFinancialInformationSourceOfWealth) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentFinancialInformationSourceOfWealth {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentFinancialInformationSourceOfWealth, v)
	}
	*j = SetFinancialAssessmentFinancialInformationSourceOfWealth(v)
	return nil
}

var enumValues_P2PAdvertiserListRespP2PAdvertiserListListElemBasicVerification = []interface{}{
	1,
	0,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserListRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserListRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserListRespMsgType, v)
	}
	*j = P2PAdvertiserListRespMsgType(v)
	return nil
}

var enumValues_P2PAdvertiserListRespMsgType = []interface{}{
	"p2p_advertiser_list",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserList) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["p2p_advertiser_list"]; !ok || v == nil {
		return fmt.Errorf("field p2p_advertiser_list: required")
	}
	type Plain P2PAdvertiserList
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["limit"]; !ok || v == nil {
		plain.Limit = 50
	}
	if v, ok := raw["offset"]; !ok || v == nil {
		plain.Offset = 0
	}
	if v, ok := raw["sort_by"]; !ok || v == nil {
		plain.SortBy = "last_interaction_time"
	}
	*j = P2PAdvertiserList(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserListTradePartners) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserListTradePartners {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserListTradePartners, v)
	}
	*j = P2PAdvertiserListTradePartners(v)
	return nil
}

var enumValues_P2PAdvertiserListTradePartners = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserListSortBy) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserListSortBy {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserListSortBy, v)
	}
	*j = P2PAdvertiserListSortBy(v)
	return nil
}

var enumValues_P2PAdvertiserListSortBy = []interface{}{
	"name",
	"created_time",
	"last_interaction_time",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentFinancialInformation) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["education_level"]; !ok || v == nil {
		return fmt.Errorf("field education_level: required")
	}
	if v, ok := raw["employment_industry"]; !ok || v == nil {
		return fmt.Errorf("field employment_industry: required")
	}
	if v, ok := raw["estimated_worth"]; !ok || v == nil {
		return fmt.Errorf("field estimated_worth: required")
	}
	if v, ok := raw["income_source"]; !ok || v == nil {
		return fmt.Errorf("field income_source: required")
	}
	if v, ok := raw["net_income"]; !ok || v == nil {
		return fmt.Errorf("field net_income: required")
	}
	if v, ok := raw["occupation"]; !ok || v == nil {
		return fmt.Errorf("field occupation: required")
	}
	type Plain SetFinancialAssessmentFinancialInformation
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SetFinancialAssessmentFinancialInformation(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserListP2PAdvertiserList) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserListP2PAdvertiserList {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserListP2PAdvertiserList, v)
	}
	*j = P2PAdvertiserListP2PAdvertiserList(v)
	return nil
}

var enumValues_SetFinancialAssessmentForexTradingExperience = []interface{}{
	"0-1 year",
	"1-2 years",
	"Over 3 years",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentForexTradingExperience) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentForexTradingExperience {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentForexTradingExperience, v)
	}
	*j = SetFinancialAssessmentForexTradingExperience(v)
	return nil
}

var enumValues_P2PAdvertiserListP2PAdvertiserList = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserListIsBlocked) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserListIsBlocked {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserListIsBlocked, v)
	}
	*j = P2PAdvertiserListIsBlocked(v)
	return nil
}

var enumValues_P2PAdvertiserListIsBlocked = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserInfoResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain P2PAdvertiserInfoResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertiserInfoResp(plain)
	return nil
}

var enumValues_SetFinancialAssessmentForexTradingFrequency = []interface{}{
	"0-5 transactions in the past 12 months",
	"6-10 transactions in the past 12 months",
	"11-39 transactions in the past 12 months",
	"40 transactions or more in the past 12 months",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentForexTradingFrequency) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentForexTradingFrequency {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentForexTradingFrequency, v)
	}
	*j = SetFinancialAssessmentForexTradingFrequency(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserInfoRespSubscription) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	type Plain P2PAdvertiserInfoRespSubscription
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertiserInfoRespSubscription(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserInfoRespP2PAdvertiserInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["advert_rates"]; !ok || v == nil {
		return fmt.Errorf("field advert_rates: required")
	}
	if v, ok := raw["basic_verification"]; !ok || v == nil {
		return fmt.Errorf("field basic_verification: required")
	}
	if v, ok := raw["buy_completion_rate"]; !ok || v == nil {
		return fmt.Errorf("field buy_completion_rate: required")
	}
	if v, ok := raw["buy_orders_amount"]; !ok || v == nil {
		return fmt.Errorf("field buy_orders_amount: required")
	}
	if v, ok := raw["buy_orders_count"]; !ok || v == nil {
		return fmt.Errorf("field buy_orders_count: required")
	}
	if v, ok := raw["buy_time_avg"]; !ok || v == nil {
		return fmt.Errorf("field buy_time_avg: required")
	}
	if v, ok := raw["cancel_time_avg"]; !ok || v == nil {
		return fmt.Errorf("field cancel_time_avg: required")
	}
	if v, ok := raw["created_time"]; !ok || v == nil {
		return fmt.Errorf("field created_time: required")
	}
	if v, ok := raw["default_advert_description"]; !ok || v == nil {
		return fmt.Errorf("field default_advert_description: required")
	}
	if v, ok := raw["full_verification"]; !ok || v == nil {
		return fmt.Errorf("field full_verification: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["is_approved"]; !ok || v == nil {
		return fmt.Errorf("field is_approved: required")
	}
	if v, ok := raw["is_listed"]; !ok || v == nil {
		return fmt.Errorf("field is_listed: required")
	}
	if v, ok := raw["is_online"]; !ok || v == nil {
		return fmt.Errorf("field is_online: required")
	}
	if v, ok := raw["last_online_time"]; !ok || v == nil {
		return fmt.Errorf("field last_online_time: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["partner_count"]; !ok || v == nil {
		return fmt.Errorf("field partner_count: required")
	}
	if v, ok := raw["rating_average"]; !ok || v == nil {
		return fmt.Errorf("field rating_average: required")
	}
	if v, ok := raw["rating_count"]; !ok || v == nil {
		return fmt.Errorf("field rating_count: required")
	}
	if v, ok := raw["recommended_average"]; !ok || v == nil {
		return fmt.Errorf("field recommended_average: required")
	}
	if v, ok := raw["recommended_count"]; !ok || v == nil {
		return fmt.Errorf("field recommended_count: required")
	}
	if v, ok := raw["release_time_avg"]; !ok || v == nil {
		return fmt.Errorf("field release_time_avg: required")
	}
	if v, ok := raw["sell_completion_rate"]; !ok || v == nil {
		return fmt.Errorf("field sell_completion_rate: required")
	}
	if v, ok := raw["sell_orders_amount"]; !ok || v == nil {
		return fmt.Errorf("field sell_orders_amount: required")
	}
	if v, ok := raw["sell_orders_count"]; !ok || v == nil {
		return fmt.Errorf("field sell_orders_count: required")
	}
	if v, ok := raw["total_completion_rate"]; !ok || v == nil {
		return fmt.Errorf("field total_completion_rate: required")
	}
	if v, ok := raw["total_orders_count"]; !ok || v == nil {
		return fmt.Errorf("field total_orders_count: required")
	}
	if v, ok := raw["total_turnover"]; !ok || v == nil {
		return fmt.Errorf("field total_turnover: required")
	}
	type Plain P2PAdvertiserInfoRespP2PAdvertiserInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertiserInfoRespP2PAdvertiserInfo(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserInfoRespP2PAdvertiserInfoUpgradableDailyLimits) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["max_daily_buy"]; !ok || v == nil {
		return fmt.Errorf("field max_daily_buy: required")
	}
	if v, ok := raw["max_daily_sell"]; !ok || v == nil {
		return fmt.Errorf("field max_daily_sell: required")
	}
	type Plain P2PAdvertiserInfoRespP2PAdvertiserInfoUpgradableDailyLimits
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertiserInfoRespP2PAdvertiserInfoUpgradableDailyLimits(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserInfoRespP2PAdvertiserInfoUpgradableDailyLimitsBlockTrade) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserInfoRespP2PAdvertiserInfoUpgradableDailyLimitsBlockTrade {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserInfoRespP2PAdvertiserInfoUpgradableDailyLimitsBlockTrade, v)
	}
	*j = P2PAdvertiserInfoRespP2PAdvertiserInfoUpgradableDailyLimitsBlockTrade(v)
	return nil
}

var enumValues_P2PAdvertiserInfoRespP2PAdvertiserInfoUpgradableDailyLimitsBlockTrade = []interface{}{
	0,
	1,
}
var enumValues_SetFinancialAssessmentIncomeSource = []interface{}{
	"Salaried Employee",
	"Self-Employed",
	"Investments & Dividends",
	"Pension",
	"State Benefits",
	"Savings & Inheritance",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentIncomeSource) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentIncomeSource {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentIncomeSource, v)
	}
	*j = SetFinancialAssessmentIncomeSource(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserInfoRespP2PAdvertiserInfoShowName) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserInfoRespP2PAdvertiserInfoShowName {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserInfoRespP2PAdvertiserInfoShowName, v)
	}
	*j = P2PAdvertiserInfoRespP2PAdvertiserInfoShowName(v)
	return nil
}

var enumValues_P2PAdvertiserInfoRespP2PAdvertiserInfoShowName = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserInfoRespP2PAdvertiserInfoIsRecommended) UnmarshalJSON(b []byte) error {
	var v struct {
		Value interface{}
	}
	if err := json.Unmarshal(b, &v.Value); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserInfoRespP2PAdvertiserInfoIsRecommended {
		if reflect.DeepEqual(v.Value, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserInfoRespP2PAdvertiserInfoIsRecommended, v.Value)
	}
	*j = P2PAdvertiserInfoRespP2PAdvertiserInfoIsRecommended(v)
	return nil
}

// MarshalJSON implements json.Marshaler.
func (j *P2PAdvertiserInfoRespP2PAdvertiserInfoIsRecommended) MarshalJSON() ([]byte, error) {
	return json.Marshal(j.Value)
}

var enumValues_P2PAdvertiserInfoRespP2PAdvertiserInfoIsRecommended = []interface{}{
	nil,
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserInfoRespP2PAdvertiserInfoIsOnline) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserInfoRespP2PAdvertiserInfoIsOnline {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserInfoRespP2PAdvertiserInfoIsOnline, v)
	}
	*j = P2PAdvertiserInfoRespP2PAdvertiserInfoIsOnline(v)
	return nil
}

var enumValues_P2PAdvertiserInfoRespP2PAdvertiserInfoIsOnline = []interface{}{
	0,
	1,
}
var enumValues_SetFinancialAssessmentNetIncome = []interface{}{
	"Less than $25,000",
	"$25,000 - $50,000",
	"$50,001 - $100,000",
	"$100,001 - $500,000",
	"Over $500,000",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentNetIncome) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentNetIncome {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentNetIncome, v)
	}
	*j = SetFinancialAssessmentNetIncome(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserInfoRespP2PAdvertiserInfoIsListed) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserInfoRespP2PAdvertiserInfoIsListed {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserInfoRespP2PAdvertiserInfoIsListed, v)
	}
	*j = P2PAdvertiserInfoRespP2PAdvertiserInfoIsListed(v)
	return nil
}

var enumValues_P2PAdvertiserInfoRespP2PAdvertiserInfoIsListed = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserInfoRespP2PAdvertiserInfoIsFavourite) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserInfoRespP2PAdvertiserInfoIsFavourite {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserInfoRespP2PAdvertiserInfoIsFavourite, v)
	}
	*j = P2PAdvertiserInfoRespP2PAdvertiserInfoIsFavourite(v)
	return nil
}

var enumValues_P2PAdvertiserInfoRespP2PAdvertiserInfoIsFavourite = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserInfoRespP2PAdvertiserInfoIsBlocked) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserInfoRespP2PAdvertiserInfoIsBlocked {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserInfoRespP2PAdvertiserInfoIsBlocked, v)
	}
	*j = P2PAdvertiserInfoRespP2PAdvertiserInfoIsBlocked(v)
	return nil
}

var enumValues_P2PAdvertiserInfoRespP2PAdvertiserInfoIsBlocked = []interface{}{
	0,
	1,
}
var enumValues_SetFinancialAssessmentOccupation = []interface{}{
	"Chief Executives, Senior Officials and Legislators",
	"Managers",
	"Professionals",
	"Clerks",
	"Personal Care, Sales and Service Workers",
	"Agricultural, Forestry and Fishery Workers",
	"Craft, Metal, Electrical and Electronics Workers",
	"Plant and Machine Operators and Assemblers",
	"Cleaners and Helpers",
	"Mining, Construction, Manufacturing and Transport Workers",
	"Armed Forces",
	"Government Officers",
	"Students",
	"Unemployed",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentOccupation) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentOccupation {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentOccupation, v)
	}
	*j = SetFinancialAssessmentOccupation(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserInfoRespP2PAdvertiserInfoIsApproved) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserInfoRespP2PAdvertiserInfoIsApproved {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserInfoRespP2PAdvertiserInfoIsApproved, v)
	}
	*j = P2PAdvertiserInfoRespP2PAdvertiserInfoIsApproved(v)
	return nil
}

var enumValues_P2PAdvertiserInfoRespP2PAdvertiserInfoIsApproved = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserInfoRespP2PAdvertiserInfoFullVerification) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserInfoRespP2PAdvertiserInfoFullVerification {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserInfoRespP2PAdvertiserInfoFullVerification, v)
	}
	*j = P2PAdvertiserInfoRespP2PAdvertiserInfoFullVerification(v)
	return nil
}

var enumValues_P2PAdvertiserInfoRespP2PAdvertiserInfoFullVerification = []interface{}{
	1,
	0,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserInfoRespP2PAdvertiserInfoBlockTrade) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["max_order_amount"]; !ok || v == nil {
		return fmt.Errorf("field max_order_amount: required")
	}
	if v, ok := raw["min_order_amount"]; !ok || v == nil {
		return fmt.Errorf("field min_order_amount: required")
	}
	type Plain P2PAdvertiserInfoRespP2PAdvertiserInfoBlockTrade
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertiserInfoRespP2PAdvertiserInfoBlockTrade(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserInfoRespP2PAdvertiserInfoBasicVerification) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserInfoRespP2PAdvertiserInfoBasicVerification {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserInfoRespP2PAdvertiserInfoBasicVerification, v)
	}
	*j = P2PAdvertiserInfoRespP2PAdvertiserInfoBasicVerification(v)
	return nil
}

var enumValues_P2PAdvertiserInfoRespP2PAdvertiserInfoBasicVerification = []interface{}{
	1,
	0,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserInfoRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserInfoRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserInfoRespMsgType, v)
	}
	*j = P2PAdvertiserInfoRespMsgType(v)
	return nil
}

var enumValues_P2PAdvertiserInfoRespMsgType = []interface{}{
	"p2p_advertiser_info",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["p2p_advertiser_info"]; !ok || v == nil {
		return fmt.Errorf("field p2p_advertiser_info: required")
	}
	type Plain P2PAdvertiserInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertiserInfo(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserInfoSubscribe) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserInfoSubscribe {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserInfoSubscribe, v)
	}
	*j = P2PAdvertiserInfoSubscribe(v)
	return nil
}

var enumValues_P2PAdvertiserInfoSubscribe = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserInfoP2PAdvertiserInfo) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserInfoP2PAdvertiserInfo {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserInfoP2PAdvertiserInfo, v)
	}
	*j = P2PAdvertiserInfoP2PAdvertiserInfo(v)
	return nil
}

var enumValues_P2PAdvertiserInfoP2PAdvertiserInfo = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserCreateResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain P2PAdvertiserCreateResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertiserCreateResp(plain)
	return nil
}

var enumValues_SetFinancialAssessmentOtherInstrumentsTradingExperience = []interface{}{
	"0-1 year",
	"1-2 years",
	"Over 3 years",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentOtherInstrumentsTradingExperience) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentOtherInstrumentsTradingExperience {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentOtherInstrumentsTradingExperience, v)
	}
	*j = SetFinancialAssessmentOtherInstrumentsTradingExperience(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserCreateRespSubscription) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	type Plain P2PAdvertiserCreateRespSubscription
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertiserCreateRespSubscription(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserCreateRespP2PAdvertiserCreate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["advert_rates"]; !ok || v == nil {
		return fmt.Errorf("field advert_rates: required")
	}
	if v, ok := raw["balance_available"]; !ok || v == nil {
		return fmt.Errorf("field balance_available: required")
	}
	if v, ok := raw["basic_verification"]; !ok || v == nil {
		return fmt.Errorf("field basic_verification: required")
	}
	if v, ok := raw["blocked_by_count"]; !ok || v == nil {
		return fmt.Errorf("field blocked_by_count: required")
	}
	if v, ok := raw["buy_completion_rate"]; !ok || v == nil {
		return fmt.Errorf("field buy_completion_rate: required")
	}
	if v, ok := raw["buy_orders_amount"]; !ok || v == nil {
		return fmt.Errorf("field buy_orders_amount: required")
	}
	if v, ok := raw["buy_orders_count"]; !ok || v == nil {
		return fmt.Errorf("field buy_orders_count: required")
	}
	if v, ok := raw["buy_time_avg"]; !ok || v == nil {
		return fmt.Errorf("field buy_time_avg: required")
	}
	if v, ok := raw["cancel_time_avg"]; !ok || v == nil {
		return fmt.Errorf("field cancel_time_avg: required")
	}
	if v, ok := raw["cancels_remaining"]; !ok || v == nil {
		return fmt.Errorf("field cancels_remaining: required")
	}
	if v, ok := raw["chat_token"]; !ok || v == nil {
		return fmt.Errorf("field chat_token: required")
	}
	if v, ok := raw["chat_user_id"]; !ok || v == nil {
		return fmt.Errorf("field chat_user_id: required")
	}
	if v, ok := raw["contact_info"]; !ok || v == nil {
		return fmt.Errorf("field contact_info: required")
	}
	if v, ok := raw["created_time"]; !ok || v == nil {
		return fmt.Errorf("field created_time: required")
	}
	if v, ok := raw["default_advert_description"]; !ok || v == nil {
		return fmt.Errorf("field default_advert_description: required")
	}
	if v, ok := raw["full_verification"]; !ok || v == nil {
		return fmt.Errorf("field full_verification: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["is_approved"]; !ok || v == nil {
		return fmt.Errorf("field is_approved: required")
	}
	if v, ok := raw["is_listed"]; !ok || v == nil {
		return fmt.Errorf("field is_listed: required")
	}
	if v, ok := raw["is_online"]; !ok || v == nil {
		return fmt.Errorf("field is_online: required")
	}
	if v, ok := raw["last_online_time"]; !ok || v == nil {
		return fmt.Errorf("field last_online_time: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["partner_count"]; !ok || v == nil {
		return fmt.Errorf("field partner_count: required")
	}
	if v, ok := raw["payment_info"]; !ok || v == nil {
		return fmt.Errorf("field payment_info: required")
	}
	if v, ok := raw["rating_average"]; !ok || v == nil {
		return fmt.Errorf("field rating_average: required")
	}
	if v, ok := raw["rating_count"]; !ok || v == nil {
		return fmt.Errorf("field rating_count: required")
	}
	if v, ok := raw["recommended_average"]; !ok || v == nil {
		return fmt.Errorf("field recommended_average: required")
	}
	if v, ok := raw["recommended_count"]; !ok || v == nil {
		return fmt.Errorf("field recommended_count: required")
	}
	if v, ok := raw["release_time_avg"]; !ok || v == nil {
		return fmt.Errorf("field release_time_avg: required")
	}
	if v, ok := raw["sell_completion_rate"]; !ok || v == nil {
		return fmt.Errorf("field sell_completion_rate: required")
	}
	if v, ok := raw["sell_orders_amount"]; !ok || v == nil {
		return fmt.Errorf("field sell_orders_amount: required")
	}
	if v, ok := raw["sell_orders_count"]; !ok || v == nil {
		return fmt.Errorf("field sell_orders_count: required")
	}
	if v, ok := raw["show_name"]; !ok || v == nil {
		return fmt.Errorf("field show_name: required")
	}
	if v, ok := raw["total_completion_rate"]; !ok || v == nil {
		return fmt.Errorf("field total_completion_rate: required")
	}
	if v, ok := raw["total_orders_count"]; !ok || v == nil {
		return fmt.Errorf("field total_orders_count: required")
	}
	if v, ok := raw["total_turnover"]; !ok || v == nil {
		return fmt.Errorf("field total_turnover: required")
	}
	type Plain P2PAdvertiserCreateRespP2PAdvertiserCreate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertiserCreateRespP2PAdvertiserCreate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserCreateRespP2PAdvertiserCreateShowName) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserCreateRespP2PAdvertiserCreateShowName {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserCreateRespP2PAdvertiserCreateShowName, v)
	}
	*j = P2PAdvertiserCreateRespP2PAdvertiserCreateShowName(v)
	return nil
}

var enumValues_P2PAdvertiserCreateRespP2PAdvertiserCreateShowName = []interface{}{
	0,
	1,
}
var enumValues_SetFinancialAssessmentOtherInstrumentsTradingFrequency = []interface{}{
	"0-5 transactions in the past 12 months",
	"6-10 transactions in the past 12 months",
	"11-39 transactions in the past 12 months",
	"40 transactions or more in the past 12 months",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentOtherInstrumentsTradingFrequency) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentOtherInstrumentsTradingFrequency {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentOtherInstrumentsTradingFrequency, v)
	}
	*j = SetFinancialAssessmentOtherInstrumentsTradingFrequency(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserCreateRespP2PAdvertiserCreateIsOnline) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserCreateRespP2PAdvertiserCreateIsOnline {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserCreateRespP2PAdvertiserCreateIsOnline, v)
	}
	*j = P2PAdvertiserCreateRespP2PAdvertiserCreateIsOnline(v)
	return nil
}

var enumValues_P2PAdvertiserCreateRespP2PAdvertiserCreateIsOnline = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserCreateRespP2PAdvertiserCreateIsListed) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserCreateRespP2PAdvertiserCreateIsListed {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserCreateRespP2PAdvertiserCreateIsListed, v)
	}
	*j = P2PAdvertiserCreateRespP2PAdvertiserCreateIsListed(v)
	return nil
}

var enumValues_P2PAdvertiserCreateRespP2PAdvertiserCreateIsListed = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserCreateRespP2PAdvertiserCreateIsApproved) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserCreateRespP2PAdvertiserCreateIsApproved {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserCreateRespP2PAdvertiserCreateIsApproved, v)
	}
	*j = P2PAdvertiserCreateRespP2PAdvertiserCreateIsApproved(v)
	return nil
}

var enumValues_P2PAdvertiserCreateRespP2PAdvertiserCreateIsApproved = []interface{}{
	0,
	1,
}
var enumValues_SetFinancialAssessmentSetFinancialAssessment = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentSetFinancialAssessment) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentSetFinancialAssessment {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentSetFinancialAssessment, v)
	}
	*j = SetFinancialAssessmentSetFinancialAssessment(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserCreateRespP2PAdvertiserCreateFullVerification) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserCreateRespP2PAdvertiserCreateFullVerification {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserCreateRespP2PAdvertiserCreateFullVerification, v)
	}
	*j = P2PAdvertiserCreateRespP2PAdvertiserCreateFullVerification(v)
	return nil
}

var enumValues_SetFinancialAssessmentSourceOfWealth = []interface{}{
	"Accumulation of Income/Savings",
	"Cash Business",
	"Company Ownership",
	"Divorce Settlement",
	"Inheritance",
	"Investment Income",
	"Sale of Property",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentSourceOfWealth) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentSourceOfWealth {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentSourceOfWealth, v)
	}
	*j = SetFinancialAssessmentSourceOfWealth(v)
	return nil
}

var enumValues_P2PAdvertiserCreateRespP2PAdvertiserCreateFullVerification = []interface{}{
	1,
	0,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserCreateRespP2PAdvertiserCreateBasicVerification) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserCreateRespP2PAdvertiserCreateBasicVerification {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserCreateRespP2PAdvertiserCreateBasicVerification, v)
	}
	*j = P2PAdvertiserCreateRespP2PAdvertiserCreateBasicVerification(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserCreateRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserCreateRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserCreateRespMsgType, v)
	}
	*j = P2PAdvertiserCreateRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserCreate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["p2p_advertiser_create"]; !ok || v == nil {
		return fmt.Errorf("field p2p_advertiser_create: required")
	}
	type Plain P2PAdvertiserCreate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertiserCreate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserCreateSubscribe) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserCreateSubscribe {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserCreateSubscribe, v)
	}
	*j = P2PAdvertiserCreateSubscribe(v)
	return nil
}

var enumValues_P2PAdvertiserCreateSubscribe = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserCreateP2PAdvertiserCreate) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserCreateP2PAdvertiserCreate {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserCreateP2PAdvertiserCreate, v)
	}
	*j = P2PAdvertiserCreateP2PAdvertiserCreate(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserAdvertsResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain P2PAdvertiserAdvertsResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertiserAdvertsResp(plain)
	return nil
}

var enumValues_SetFinancialAssessmentTradingExperienceBinaryOptionsTradingExperience = []interface{}{
	"0-1 year",
	"1-2 years",
	"Over 3 years",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentTradingExperienceBinaryOptionsTradingExperience) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentTradingExperienceBinaryOptionsTradingExperience {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentTradingExperienceBinaryOptionsTradingExperience, v)
	}
	*j = SetFinancialAssessmentTradingExperienceBinaryOptionsTradingExperience(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserAdvertsRespP2PAdvertiserAdverts) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["list"]; !ok || v == nil {
		return fmt.Errorf("field list: required")
	}
	type Plain P2PAdvertiserAdvertsRespP2PAdvertiserAdverts
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertiserAdvertsRespP2PAdvertiserAdverts(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["account_currency"]; !ok || v == nil {
		return fmt.Errorf("field account_currency: required")
	}
	if v, ok := raw["active_orders"]; !ok || v == nil {
		return fmt.Errorf("field active_orders: required")
	}
	if v, ok := raw["advertiser_details"]; !ok || v == nil {
		return fmt.Errorf("field advertiser_details: required")
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["amount_display"]; !ok || v == nil {
		return fmt.Errorf("field amount_display: required")
	}
	if v, ok := raw["block_trade"]; !ok || v == nil {
		return fmt.Errorf("field block_trade: required")
	}
	if v, ok := raw["contact_info"]; !ok || v == nil {
		return fmt.Errorf("field contact_info: required")
	}
	if v, ok := raw["counterparty_type"]; !ok || v == nil {
		return fmt.Errorf("field counterparty_type: required")
	}
	if v, ok := raw["country"]; !ok || v == nil {
		return fmt.Errorf("field country: required")
	}
	if v, ok := raw["created_time"]; !ok || v == nil {
		return fmt.Errorf("field created_time: required")
	}
	if v, ok := raw["description"]; !ok || v == nil {
		return fmt.Errorf("field description: required")
	}
	if v, ok := raw["effective_rate"]; !ok || v == nil {
		return fmt.Errorf("field effective_rate: required")
	}
	if v, ok := raw["effective_rate_display"]; !ok || v == nil {
		return fmt.Errorf("field effective_rate_display: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["is_active"]; !ok || v == nil {
		return fmt.Errorf("field is_active: required")
	}
	if v, ok := raw["local_currency"]; !ok || v == nil {
		return fmt.Errorf("field local_currency: required")
	}
	if v, ok := raw["max_order_amount"]; !ok || v == nil {
		return fmt.Errorf("field max_order_amount: required")
	}
	if v, ok := raw["max_order_amount_display"]; !ok || v == nil {
		return fmt.Errorf("field max_order_amount_display: required")
	}
	if v, ok := raw["max_order_amount_limit"]; !ok || v == nil {
		return fmt.Errorf("field max_order_amount_limit: required")
	}
	if v, ok := raw["max_order_amount_limit_display"]; !ok || v == nil {
		return fmt.Errorf("field max_order_amount_limit_display: required")
	}
	if v, ok := raw["min_order_amount"]; !ok || v == nil {
		return fmt.Errorf("field min_order_amount: required")
	}
	if v, ok := raw["min_order_amount_display"]; !ok || v == nil {
		return fmt.Errorf("field min_order_amount_display: required")
	}
	if v, ok := raw["min_order_amount_limit"]; !ok || v == nil {
		return fmt.Errorf("field min_order_amount_limit: required")
	}
	if v, ok := raw["min_order_amount_limit_display"]; !ok || v == nil {
		return fmt.Errorf("field min_order_amount_limit_display: required")
	}
	if v, ok := raw["payment_info"]; !ok || v == nil {
		return fmt.Errorf("field payment_info: required")
	}
	if v, ok := raw["payment_method"]; !ok || v == nil {
		return fmt.Errorf("field payment_method: required")
	}
	if v, ok := raw["price"]; !ok || v == nil {
		return fmt.Errorf("field price: required")
	}
	if v, ok := raw["price_display"]; !ok || v == nil {
		return fmt.Errorf("field price_display: required")
	}
	if v, ok := raw["rate"]; !ok || v == nil {
		return fmt.Errorf("field rate: required")
	}
	if v, ok := raw["rate_display"]; !ok || v == nil {
		return fmt.Errorf("field rate_display: required")
	}
	if v, ok := raw["rate_type"]; !ok || v == nil {
		return fmt.Errorf("field rate_type: required")
	}
	if v, ok := raw["remaining_amount"]; !ok || v == nil {
		return fmt.Errorf("field remaining_amount: required")
	}
	if v, ok := raw["remaining_amount_display"]; !ok || v == nil {
		return fmt.Errorf("field remaining_amount_display: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["is_visible"]; !ok || v == nil {
		plain.IsVisible = 0
	}
	*j = P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemVisibilityStatusElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemVisibilityStatusElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemVisibilityStatusElem, v)
	}
	*j = P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemVisibilityStatusElem(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemType, v)
	}
	*j = P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemType(v)
	return nil
}

var enumValues_SetFinancialAssessmentTradingExperienceBinaryOptionsTradingFrequency = []interface{}{
	"0-5 transactions in the past 12 months",
	"6-10 transactions in the past 12 months",
	"11-39 transactions in the past 12 months",
	"40 transactions or more in the past 12 months",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentTradingExperienceBinaryOptionsTradingFrequency) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentTradingExperienceBinaryOptionsTradingFrequency {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentTradingExperienceBinaryOptionsTradingFrequency, v)
	}
	*j = SetFinancialAssessmentTradingExperienceBinaryOptionsTradingFrequency(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemRateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemRateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemRateType, v)
	}
	*j = P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemRateType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemIsVisible) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemIsVisible {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemIsVisible, v)
	}
	*j = P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemIsVisible(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemIsActive) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemIsActive {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemIsActive, v)
	}
	*j = P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemIsActive(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemCounterpartyType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemCounterpartyType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemCounterpartyType, v)
	}
	*j = P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemCounterpartyType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemBlockTrade) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemBlockTrade {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemBlockTrade, v)
	}
	*j = P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemBlockTrade(v)
	return nil
}

var enumValues_SetFinancialAssessmentTradingExperienceCfdTradingExperience = []interface{}{
	"0-1 year",
	"1-2 years",
	"Over 3 years",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentTradingExperienceCfdTradingExperience) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentTradingExperienceCfdTradingExperience {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentTradingExperienceCfdTradingExperience, v)
	}
	*j = SetFinancialAssessmentTradingExperienceCfdTradingExperience(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemAdvertiserDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["completed_orders_count"]; !ok || v == nil {
		return fmt.Errorf("field completed_orders_count: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["is_online"]; !ok || v == nil {
		return fmt.Errorf("field is_online: required")
	}
	if v, ok := raw["last_online_time"]; !ok || v == nil {
		return fmt.Errorf("field last_online_time: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["rating_average"]; !ok || v == nil {
		return fmt.Errorf("field rating_average: required")
	}
	if v, ok := raw["rating_count"]; !ok || v == nil {
		return fmt.Errorf("field rating_count: required")
	}
	if v, ok := raw["recommended_average"]; !ok || v == nil {
		return fmt.Errorf("field recommended_average: required")
	}
	if v, ok := raw["recommended_count"]; !ok || v == nil {
		return fmt.Errorf("field recommended_count: required")
	}
	if v, ok := raw["total_completion_rate"]; !ok || v == nil {
		return fmt.Errorf("field total_completion_rate: required")
	}
	type Plain P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemAdvertiserDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemAdvertiserDetails(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemAdvertiserDetailsIsOnline) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemAdvertiserDetailsIsOnline {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemAdvertiserDetailsIsOnline, v)
	}
	*j = P2PAdvertiserAdvertsRespP2PAdvertiserAdvertsListElemAdvertiserDetailsIsOnline(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserAdvertsRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserAdvertsRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserAdvertsRespMsgType, v)
	}
	*j = P2PAdvertiserAdvertsRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserAdverts) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["p2p_advertiser_adverts"]; !ok || v == nil {
		return fmt.Errorf("field p2p_advertiser_adverts: required")
	}
	type Plain P2PAdvertiserAdverts
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["limit"]; !ok || v == nil {
		plain.Limit = 50
	}
	if v, ok := raw["offset"]; !ok || v == nil {
		plain.Offset = 0
	}
	*j = P2PAdvertiserAdverts(plain)
	return nil
}

var enumValues_SetFinancialAssessmentTradingExperienceCfdTradingFrequency = []interface{}{
	"0-5 transactions in the past 12 months",
	"6-10 transactions in the past 12 months",
	"11-39 transactions in the past 12 months",
	"40 transactions or more in the past 12 months",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentTradingExperienceCfdTradingFrequency) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentTradingExperienceCfdTradingFrequency {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentTradingExperienceCfdTradingFrequency, v)
	}
	*j = SetFinancialAssessmentTradingExperienceCfdTradingFrequency(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertiserAdvertsP2PAdvertiserAdverts) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertiserAdvertsP2PAdvertiserAdverts {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertiserAdvertsP2PAdvertiserAdverts, v)
	}
	*j = P2PAdvertiserAdvertsP2PAdvertiserAdverts(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertUpdateResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain P2PAdvertUpdateResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertUpdateResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertUpdateRespP2PAdvertUpdate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	type Plain P2PAdvertUpdateRespP2PAdvertUpdate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["is_visible"]; !ok || v == nil {
		plain.IsVisible = 0
	}
	*j = P2PAdvertUpdateRespP2PAdvertUpdate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertUpdateRespP2PAdvertUpdateVisibilityStatusElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertUpdateRespP2PAdvertUpdateVisibilityStatusElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertUpdateRespP2PAdvertUpdateVisibilityStatusElem, v)
	}
	*j = P2PAdvertUpdateRespP2PAdvertUpdateVisibilityStatusElem(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertUpdateRespP2PAdvertUpdateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertUpdateRespP2PAdvertUpdateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertUpdateRespP2PAdvertUpdateType, v)
	}
	*j = P2PAdvertUpdateRespP2PAdvertUpdateType(v)
	return nil
}

var enumValues_SetFinancialAssessmentTradingExperienceForexTradingExperience = []interface{}{
	"0-1 year",
	"1-2 years",
	"Over 3 years",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentTradingExperienceForexTradingExperience) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentTradingExperienceForexTradingExperience {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentTradingExperienceForexTradingExperience, v)
	}
	*j = SetFinancialAssessmentTradingExperienceForexTradingExperience(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertUpdateRespP2PAdvertUpdateRateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertUpdateRespP2PAdvertUpdateRateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertUpdateRespP2PAdvertUpdateRateType, v)
	}
	*j = P2PAdvertUpdateRespP2PAdvertUpdateRateType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertUpdateRespP2PAdvertUpdateIsVisible) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertUpdateRespP2PAdvertUpdateIsVisible {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertUpdateRespP2PAdvertUpdateIsVisible, v)
	}
	*j = P2PAdvertUpdateRespP2PAdvertUpdateIsVisible(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertUpdateRespP2PAdvertUpdateIsActive) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertUpdateRespP2PAdvertUpdateIsActive {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertUpdateRespP2PAdvertUpdateIsActive, v)
	}
	*j = P2PAdvertUpdateRespP2PAdvertUpdateIsActive(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertUpdateRespP2PAdvertUpdateDeleted) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertUpdateRespP2PAdvertUpdateDeleted {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertUpdateRespP2PAdvertUpdateDeleted, v)
	}
	*j = P2PAdvertUpdateRespP2PAdvertUpdateDeleted(v)
	return nil
}

var enumValues_SetFinancialAssessmentTradingExperienceForexTradingFrequency = []interface{}{
	"0-5 transactions in the past 12 months",
	"6-10 transactions in the past 12 months",
	"11-39 transactions in the past 12 months",
	"40 transactions or more in the past 12 months",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentTradingExperienceForexTradingFrequency) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentTradingExperienceForexTradingFrequency {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentTradingExperienceForexTradingFrequency, v)
	}
	*j = SetFinancialAssessmentTradingExperienceForexTradingFrequency(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertUpdateRespP2PAdvertUpdateCounterpartyType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertUpdateRespP2PAdvertUpdateCounterpartyType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertUpdateRespP2PAdvertUpdateCounterpartyType, v)
	}
	*j = P2PAdvertUpdateRespP2PAdvertUpdateCounterpartyType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertUpdateRespP2PAdvertUpdateBlockTrade) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertUpdateRespP2PAdvertUpdateBlockTrade {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertUpdateRespP2PAdvertUpdateBlockTrade, v)
	}
	*j = P2PAdvertUpdateRespP2PAdvertUpdateBlockTrade(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertUpdateRespP2PAdvertUpdateAdvertiserDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["completed_orders_count"]; !ok || v == nil {
		return fmt.Errorf("field completed_orders_count: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["is_online"]; !ok || v == nil {
		return fmt.Errorf("field is_online: required")
	}
	if v, ok := raw["last_online_time"]; !ok || v == nil {
		return fmt.Errorf("field last_online_time: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["rating_average"]; !ok || v == nil {
		return fmt.Errorf("field rating_average: required")
	}
	if v, ok := raw["rating_count"]; !ok || v == nil {
		return fmt.Errorf("field rating_count: required")
	}
	if v, ok := raw["recommended_average"]; !ok || v == nil {
		return fmt.Errorf("field recommended_average: required")
	}
	if v, ok := raw["recommended_count"]; !ok || v == nil {
		return fmt.Errorf("field recommended_count: required")
	}
	if v, ok := raw["total_completion_rate"]; !ok || v == nil {
		return fmt.Errorf("field total_completion_rate: required")
	}
	type Plain P2PAdvertUpdateRespP2PAdvertUpdateAdvertiserDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertUpdateRespP2PAdvertUpdateAdvertiserDetails(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertUpdateRespP2PAdvertUpdateAdvertiserDetailsIsOnline) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertUpdateRespP2PAdvertUpdateAdvertiserDetailsIsOnline {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertUpdateRespP2PAdvertUpdateAdvertiserDetailsIsOnline, v)
	}
	*j = P2PAdvertUpdateRespP2PAdvertUpdateAdvertiserDetailsIsOnline(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertUpdateRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertUpdateRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertUpdateRespMsgType, v)
	}
	*j = P2PAdvertUpdateRespMsgType(v)
	return nil
}

var enumValues_SetFinancialAssessmentTradingExperienceOtherInstrumentsTradingExperience = []interface{}{
	"0-1 year",
	"1-2 years",
	"Over 3 years",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentTradingExperienceOtherInstrumentsTradingExperience) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentTradingExperienceOtherInstrumentsTradingExperience {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentTradingExperienceOtherInstrumentsTradingExperience, v)
	}
	*j = SetFinancialAssessmentTradingExperienceOtherInstrumentsTradingExperience(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertUpdate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["p2p_advert_update"]; !ok || v == nil {
		return fmt.Errorf("field p2p_advert_update: required")
	}
	type Plain P2PAdvertUpdate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertUpdate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertUpdateRateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertUpdateRateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertUpdateRateType, v)
	}
	*j = P2PAdvertUpdateRateType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertUpdateP2PAdvertUpdate) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertUpdateP2PAdvertUpdate {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertUpdateP2PAdvertUpdate, v)
	}
	*j = P2PAdvertUpdateP2PAdvertUpdate(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertUpdateIsActive) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertUpdateIsActive {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertUpdateIsActive, v)
	}
	*j = P2PAdvertUpdateIsActive(v)
	return nil
}

var enumValues_SetFinancialAssessmentTradingExperienceOtherInstrumentsTradingFrequency = []interface{}{
	"0-5 transactions in the past 12 months",
	"6-10 transactions in the past 12 months",
	"11-39 transactions in the past 12 months",
	"40 transactions or more in the past 12 months",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentTradingExperienceOtherInstrumentsTradingFrequency) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentTradingExperienceOtherInstrumentsTradingFrequency {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentTradingExperienceOtherInstrumentsTradingFrequency, v)
	}
	*j = SetFinancialAssessmentTradingExperienceOtherInstrumentsTradingFrequency(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertUpdateDelete) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertUpdateDelete {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertUpdateDelete, v)
	}
	*j = P2PAdvertUpdateDelete(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertListResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain P2PAdvertListResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertListResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertListRespP2PAdvertList) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["list"]; !ok || v == nil {
		return fmt.Errorf("field list: required")
	}
	type Plain P2PAdvertListRespP2PAdvertList
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertListRespP2PAdvertList(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertListRespP2PAdvertListListElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["account_currency"]; !ok || v == nil {
		return fmt.Errorf("field account_currency: required")
	}
	if v, ok := raw["advertiser_details"]; !ok || v == nil {
		return fmt.Errorf("field advertiser_details: required")
	}
	if v, ok := raw["block_trade"]; !ok || v == nil {
		return fmt.Errorf("field block_trade: required")
	}
	if v, ok := raw["counterparty_type"]; !ok || v == nil {
		return fmt.Errorf("field counterparty_type: required")
	}
	if v, ok := raw["country"]; !ok || v == nil {
		return fmt.Errorf("field country: required")
	}
	if v, ok := raw["created_time"]; !ok || v == nil {
		return fmt.Errorf("field created_time: required")
	}
	if v, ok := raw["description"]; !ok || v == nil {
		return fmt.Errorf("field description: required")
	}
	if v, ok := raw["effective_rate"]; !ok || v == nil {
		return fmt.Errorf("field effective_rate: required")
	}
	if v, ok := raw["effective_rate_display"]; !ok || v == nil {
		return fmt.Errorf("field effective_rate_display: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["is_active"]; !ok || v == nil {
		return fmt.Errorf("field is_active: required")
	}
	if v, ok := raw["local_currency"]; !ok || v == nil {
		return fmt.Errorf("field local_currency: required")
	}
	if v, ok := raw["max_order_amount_limit"]; !ok || v == nil {
		return fmt.Errorf("field max_order_amount_limit: required")
	}
	if v, ok := raw["max_order_amount_limit_display"]; !ok || v == nil {
		return fmt.Errorf("field max_order_amount_limit_display: required")
	}
	if v, ok := raw["min_order_amount_limit"]; !ok || v == nil {
		return fmt.Errorf("field min_order_amount_limit: required")
	}
	if v, ok := raw["min_order_amount_limit_display"]; !ok || v == nil {
		return fmt.Errorf("field min_order_amount_limit_display: required")
	}
	if v, ok := raw["payment_method"]; !ok || v == nil {
		return fmt.Errorf("field payment_method: required")
	}
	if v, ok := raw["price"]; !ok || v == nil {
		return fmt.Errorf("field price: required")
	}
	if v, ok := raw["price_display"]; !ok || v == nil {
		return fmt.Errorf("field price_display: required")
	}
	if v, ok := raw["rate"]; !ok || v == nil {
		return fmt.Errorf("field rate: required")
	}
	if v, ok := raw["rate_display"]; !ok || v == nil {
		return fmt.Errorf("field rate_display: required")
	}
	if v, ok := raw["rate_type"]; !ok || v == nil {
		return fmt.Errorf("field rate_type: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain P2PAdvertListRespP2PAdvertListListElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["is_visible"]; !ok || v == nil {
		plain.IsVisible = 0
	}
	*j = P2PAdvertListRespP2PAdvertListListElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertListRespP2PAdvertListListElemVisibilityStatusElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertListRespP2PAdvertListListElemVisibilityStatusElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertListRespP2PAdvertListListElemVisibilityStatusElem, v)
	}
	*j = P2PAdvertListRespP2PAdvertListListElemVisibilityStatusElem(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertListRespP2PAdvertListListElemType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertListRespP2PAdvertListListElemType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertListRespP2PAdvertListListElemType, v)
	}
	*j = P2PAdvertListRespP2PAdvertListListElemType(v)
	return nil
}

var enumValues_SetFinancialAssessmentTradingExperienceRegulatedCfdExperience = []interface{}{
	"No experience",
	"Less than a year",
	"1 - 2 years",
	"Over 3 years",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentTradingExperienceRegulatedCfdExperience) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentTradingExperienceRegulatedCfdExperience {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentTradingExperienceRegulatedCfdExperience, v)
	}
	*j = SetFinancialAssessmentTradingExperienceRegulatedCfdExperience(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertListRespP2PAdvertListListElemRateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertListRespP2PAdvertListListElemRateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertListRespP2PAdvertListListElemRateType, v)
	}
	*j = P2PAdvertListRespP2PAdvertListListElemRateType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertListRespP2PAdvertListListElemIsVisible) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertListRespP2PAdvertListListElemIsVisible {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertListRespP2PAdvertListListElemIsVisible, v)
	}
	*j = P2PAdvertListRespP2PAdvertListListElemIsVisible(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertListRespP2PAdvertListListElemIsActive) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertListRespP2PAdvertListListElemIsActive {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertListRespP2PAdvertListListElemIsActive, v)
	}
	*j = P2PAdvertListRespP2PAdvertListListElemIsActive(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertListRespP2PAdvertListListElemCounterpartyType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertListRespP2PAdvertListListElemCounterpartyType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertListRespP2PAdvertListListElemCounterpartyType, v)
	}
	*j = P2PAdvertListRespP2PAdvertListListElemCounterpartyType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertListRespP2PAdvertListListElemBlockTrade) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertListRespP2PAdvertListListElemBlockTrade {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertListRespP2PAdvertListListElemBlockTrade, v)
	}
	*j = P2PAdvertListRespP2PAdvertListListElemBlockTrade(v)
	return nil
}

var enumValues_SetFinancialAssessmentTradingExperienceRegulatedCfdFrequency = []interface{}{
	"No transactions in the past 12 months",
	"1 - 5 transactions in the past 12 months",
	"6 - 10 transactions in the past 12 months",
	"11 - 39 transactions in the past 12 months",
	"40 transactions or more in the past 12 months",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentTradingExperienceRegulatedCfdFrequency) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentTradingExperienceRegulatedCfdFrequency {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentTradingExperienceRegulatedCfdFrequency, v)
	}
	*j = SetFinancialAssessmentTradingExperienceRegulatedCfdFrequency(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertListRespP2PAdvertListListElemAdvertiserDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["completed_orders_count"]; !ok || v == nil {
		return fmt.Errorf("field completed_orders_count: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["is_online"]; !ok || v == nil {
		return fmt.Errorf("field is_online: required")
	}
	if v, ok := raw["last_online_time"]; !ok || v == nil {
		return fmt.Errorf("field last_online_time: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["rating_average"]; !ok || v == nil {
		return fmt.Errorf("field rating_average: required")
	}
	if v, ok := raw["rating_count"]; !ok || v == nil {
		return fmt.Errorf("field rating_count: required")
	}
	if v, ok := raw["recommended_average"]; !ok || v == nil {
		return fmt.Errorf("field recommended_average: required")
	}
	if v, ok := raw["recommended_count"]; !ok || v == nil {
		return fmt.Errorf("field recommended_count: required")
	}
	if v, ok := raw["total_completion_rate"]; !ok || v == nil {
		return fmt.Errorf("field total_completion_rate: required")
	}
	type Plain P2PAdvertListRespP2PAdvertListListElemAdvertiserDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertListRespP2PAdvertListListElemAdvertiserDetails(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertListRespP2PAdvertListListElemAdvertiserDetailsIsRecommended) UnmarshalJSON(b []byte) error {
	var v struct {
		Value interface{}
	}
	if err := json.Unmarshal(b, &v.Value); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertListRespP2PAdvertListListElemAdvertiserDetailsIsRecommended {
		if reflect.DeepEqual(v.Value, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertListRespP2PAdvertListListElemAdvertiserDetailsIsRecommended, v.Value)
	}
	*j = P2PAdvertListRespP2PAdvertListListElemAdvertiserDetailsIsRecommended(v)
	return nil
}

// MarshalJSON implements json.Marshaler.
func (j *P2PAdvertListRespP2PAdvertListListElemAdvertiserDetailsIsRecommended) MarshalJSON() ([]byte, error) {
	return json.Marshal(j.Value)
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertListRespP2PAdvertListListElemAdvertiserDetailsIsOnline) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertListRespP2PAdvertListListElemAdvertiserDetailsIsOnline {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertListRespP2PAdvertListListElemAdvertiserDetailsIsOnline, v)
	}
	*j = P2PAdvertListRespP2PAdvertListListElemAdvertiserDetailsIsOnline(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertListRespP2PAdvertListListElemAdvertiserDetailsIsFavourite) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertListRespP2PAdvertListListElemAdvertiserDetailsIsFavourite {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertListRespP2PAdvertListListElemAdvertiserDetailsIsFavourite, v)
	}
	*j = P2PAdvertListRespP2PAdvertListListElemAdvertiserDetailsIsFavourite(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertListRespP2PAdvertListListElemAdvertiserDetailsIsBlocked) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertListRespP2PAdvertListListElemAdvertiserDetailsIsBlocked {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertListRespP2PAdvertListListElemAdvertiserDetailsIsBlocked, v)
	}
	*j = P2PAdvertListRespP2PAdvertListListElemAdvertiserDetailsIsBlocked(v)
	return nil
}

var enumValues_SetFinancialAssessmentTradingExperienceRegulatedCfdTradingDefinition = []interface{}{
	"Purchase shares of a company or physical commodities.",
	"Place a bet on the price movement.",
	"Speculate on the price movement.",
	"Make a long-term investment.",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentTradingExperienceRegulatedCfdTradingDefinition) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentTradingExperienceRegulatedCfdTradingDefinition {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentTradingExperienceRegulatedCfdTradingDefinition, v)
	}
	*j = SetFinancialAssessmentTradingExperienceRegulatedCfdTradingDefinition(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertListRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertListRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertListRespMsgType, v)
	}
	*j = P2PAdvertListRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertList) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["p2p_advert_list"]; !ok || v == nil {
		return fmt.Errorf("field p2p_advert_list: required")
	}
	type Plain P2PAdvertList
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["block_trade"]; !ok || v == nil {
		plain.BlockTrade = 0
	}
	if v, ok := raw["limit"]; !ok || v == nil {
		plain.Limit = 50
	}
	if v, ok := raw["offset"]; !ok || v == nil {
		plain.Offset = 0
	}
	if v, ok := raw["sort_by"]; !ok || v == nil {
		plain.SortBy = "rate"
	}
	if v, ok := raw["use_client_limits"]; !ok || v == nil {
		plain.UseClientLimits = 0
	}
	*j = P2PAdvertList(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertListUseClientLimits) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertListUseClientLimits {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertListUseClientLimits, v)
	}
	*j = P2PAdvertListUseClientLimits(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertListSortBy) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertListSortBy {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertListSortBy, v)
	}
	*j = P2PAdvertListSortBy(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertListP2PAdvertList) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertListP2PAdvertList {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertListP2PAdvertList, v)
	}
	*j = P2PAdvertListP2PAdvertList(v)
	return nil
}

var enumValues_SetFinancialAssessmentTradingExperienceRegulatedLeverageImpactTrading = []interface{}{
	"Leverage is a risk mitigation technique.",
	"Leverage prevents you from opening large positions.",
	"Leverage guarantees profits.",
	"Leverage lets you open larger positions for a fraction of the trade's value.",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentTradingExperienceRegulatedLeverageImpactTrading) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentTradingExperienceRegulatedLeverageImpactTrading {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentTradingExperienceRegulatedLeverageImpactTrading, v)
	}
	*j = SetFinancialAssessmentTradingExperienceRegulatedLeverageImpactTrading(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertListFavouritesOnly) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertListFavouritesOnly {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertListFavouritesOnly, v)
	}
	*j = P2PAdvertListFavouritesOnly(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertListCounterpartyType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertListCounterpartyType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertListCounterpartyType, v)
	}
	*j = P2PAdvertListCounterpartyType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertListBlockTrade) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertListBlockTrade {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertListBlockTrade, v)
	}
	*j = P2PAdvertListBlockTrade(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain P2PAdvertInfoResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertInfoResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespSubscription) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	type Plain P2PAdvertInfoRespSubscription
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertInfoRespSubscription(plain)
	return nil
}

var enumValues_SetFinancialAssessmentTradingExperienceRegulatedLeverageTradingHighRiskStopLoss = []interface{}{
	"Cancel your trade at any time within a chosen timeframe.",
	"Close your trade automatically when the loss is more than or equal to a specific amount.",
	"Close your trade automatically when the profit is more than or equal to a specific amount.",
	"Make a guaranteed profit on your trade.",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentTradingExperienceRegulatedLeverageTradingHighRiskStopLoss) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentTradingExperienceRegulatedLeverageTradingHighRiskStopLoss {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentTradingExperienceRegulatedLeverageTradingHighRiskStopLoss, v)
	}
	*j = SetFinancialAssessmentTradingExperienceRegulatedLeverageTradingHighRiskStopLoss(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespP2PAdvertInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain P2PAdvertInfoRespP2PAdvertInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["is_visible"]; !ok || v == nil {
		plain.IsVisible = 0
	}
	*j = P2PAdvertInfoRespP2PAdvertInfo(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem, v)
	}
	*j = P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespP2PAdvertInfoType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertInfoRespP2PAdvertInfoType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertInfoRespP2PAdvertInfoType, v)
	}
	*j = P2PAdvertInfoRespP2PAdvertInfoType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespP2PAdvertInfoRateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertInfoRespP2PAdvertInfoRateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertInfoRespP2PAdvertInfoRateType, v)
	}
	*j = P2PAdvertInfoRespP2PAdvertInfoRateType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespP2PAdvertInfoIsVisible) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertInfoRespP2PAdvertInfoIsVisible {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertInfoRespP2PAdvertInfoIsVisible, v)
	}
	*j = P2PAdvertInfoRespP2PAdvertInfoIsVisible(v)
	return nil
}

var enumValues_SetFinancialAssessmentTradingExperienceRegulatedRequiredInitialMargin = []interface{}{
	"When opening a Leveraged CFD trade.",
	"When trading Multipliers.",
	"When buying shares of a company.",
	"All of the above.",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentTradingExperienceRegulatedRequiredInitialMargin) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentTradingExperienceRegulatedRequiredInitialMargin {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentTradingExperienceRegulatedRequiredInitialMargin, v)
	}
	*j = SetFinancialAssessmentTradingExperienceRegulatedRequiredInitialMargin(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespP2PAdvertInfoIsActive) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertInfoRespP2PAdvertInfoIsActive {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertInfoRespP2PAdvertInfoIsActive, v)
	}
	*j = P2PAdvertInfoRespP2PAdvertInfoIsActive(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespP2PAdvertInfoDeleted) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertInfoRespP2PAdvertInfoDeleted {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertInfoRespP2PAdvertInfoDeleted, v)
	}
	*j = P2PAdvertInfoRespP2PAdvertInfoDeleted(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespP2PAdvertInfoCounterpartyType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertInfoRespP2PAdvertInfoCounterpartyType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertInfoRespP2PAdvertInfoCounterpartyType, v)
	}
	*j = P2PAdvertInfoRespP2PAdvertInfoCounterpartyType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespP2PAdvertInfoBlockTrade) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertInfoRespP2PAdvertInfoBlockTrade {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertInfoRespP2PAdvertInfoBlockTrade, v)
	}
	*j = P2PAdvertInfoRespP2PAdvertInfoBlockTrade(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["completed_orders_count"]; !ok || v == nil {
		return fmt.Errorf("field completed_orders_count: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["is_online"]; !ok || v == nil {
		return fmt.Errorf("field is_online: required")
	}
	if v, ok := raw["last_online_time"]; !ok || v == nil {
		return fmt.Errorf("field last_online_time: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["rating_average"]; !ok || v == nil {
		return fmt.Errorf("field rating_average: required")
	}
	if v, ok := raw["rating_count"]; !ok || v == nil {
		return fmt.Errorf("field rating_count: required")
	}
	if v, ok := raw["recommended_average"]; !ok || v == nil {
		return fmt.Errorf("field recommended_average: required")
	}
	if v, ok := raw["recommended_count"]; !ok || v == nil {
		return fmt.Errorf("field recommended_count: required")
	}
	if v, ok := raw["total_completion_rate"]; !ok || v == nil {
		return fmt.Errorf("field total_completion_rate: required")
	}
	type Plain P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetails(plain)
	return nil
}

var enumValues_SetFinancialAssessmentTradingExperienceRegulatedRiskTolerance = []interface{}{
	"Yes",
	"No",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentTradingExperienceRegulatedRiskTolerance) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentTradingExperienceRegulatedRiskTolerance {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentTradingExperienceRegulatedRiskTolerance, v)
	}
	*j = SetFinancialAssessmentTradingExperienceRegulatedRiskTolerance(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsRecommended) UnmarshalJSON(b []byte) error {
	var v struct {
		Value interface{}
	}
	if err := json.Unmarshal(b, &v.Value); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsRecommended {
		if reflect.DeepEqual(v.Value, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsRecommended, v.Value)
	}
	*j = P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsRecommended(v)
	return nil
}

// MarshalJSON implements json.Marshaler.
func (j *P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsRecommended) MarshalJSON() ([]byte, error) {
	return json.Marshal(j.Value)
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsOnline) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsOnline {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsOnline, v)
	}
	*j = P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsOnline(v)
	return nil
}

var enumValues_SetFinancialAssessmentTradingExperienceRegulatedSourceOfExperience = []interface{}{
	"I have an academic degree, professional certification, and/or work experience.",
	"I trade forex CFDs and other complex financial instruments.",
	"I have attended seminars, training, and/or workshops.",
	"I have little experience.",
	"I have no knowledge.",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentTradingExperienceRegulatedSourceOfExperience) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentTradingExperienceRegulatedSourceOfExperience {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentTradingExperienceRegulatedSourceOfExperience, v)
	}
	*j = SetFinancialAssessmentTradingExperienceRegulatedSourceOfExperience(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsFavourite) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsFavourite {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsFavourite, v)
	}
	*j = P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsFavourite(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsBlocked) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsBlocked {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsBlocked, v)
	}
	*j = P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsBlocked(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertInfoRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertInfoRespMsgType, v)
	}
	*j = P2PAdvertInfoRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["p2p_advert_info"]; !ok || v == nil {
		return fmt.Errorf("field p2p_advert_info: required")
	}
	type Plain P2PAdvertInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["use_client_limits"]; !ok || v == nil {
		plain.UseClientLimits = 0
	}
	*j = P2PAdvertInfo(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoUseClientLimits) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertInfoUseClientLimits {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertInfoUseClientLimits, v)
	}
	*j = P2PAdvertInfoUseClientLimits(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoSubscribe) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertInfoSubscribe {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertInfoSubscribe, v)
	}
	*j = P2PAdvertInfoSubscribe(v)
	return nil
}

var enumValues_SetFinancialAssessmentTradingExperienceRegulatedTradingExperienceFinancialInstruments = []interface{}{
	"No experience",
	"Less than a year",
	"1 - 2 years",
	"Over 3 years",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentTradingExperienceRegulatedTradingExperienceFinancialInstruments) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentTradingExperienceRegulatedTradingExperienceFinancialInstruments {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentTradingExperienceRegulatedTradingExperienceFinancialInstruments, v)
	}
	*j = SetFinancialAssessmentTradingExperienceRegulatedTradingExperienceFinancialInstruments(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoP2PAdvertInfo) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertInfoP2PAdvertInfo {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertInfoP2PAdvertInfo, v)
	}
	*j = P2PAdvertInfoP2PAdvertInfo(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreateResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain P2PAdvertCreateResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertCreateResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreateRespP2PAdvertCreate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["account_currency"]; !ok || v == nil {
		return fmt.Errorf("field account_currency: required")
	}
	if v, ok := raw["active_orders"]; !ok || v == nil {
		return fmt.Errorf("field active_orders: required")
	}
	if v, ok := raw["advertiser_details"]; !ok || v == nil {
		return fmt.Errorf("field advertiser_details: required")
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["amount_display"]; !ok || v == nil {
		return fmt.Errorf("field amount_display: required")
	}
	if v, ok := raw["block_trade"]; !ok || v == nil {
		return fmt.Errorf("field block_trade: required")
	}
	if v, ok := raw["counterparty_type"]; !ok || v == nil {
		return fmt.Errorf("field counterparty_type: required")
	}
	if v, ok := raw["country"]; !ok || v == nil {
		return fmt.Errorf("field country: required")
	}
	if v, ok := raw["created_time"]; !ok || v == nil {
		return fmt.Errorf("field created_time: required")
	}
	if v, ok := raw["description"]; !ok || v == nil {
		return fmt.Errorf("field description: required")
	}
	if v, ok := raw["effective_rate"]; !ok || v == nil {
		return fmt.Errorf("field effective_rate: required")
	}
	if v, ok := raw["effective_rate_display"]; !ok || v == nil {
		return fmt.Errorf("field effective_rate_display: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["is_active"]; !ok || v == nil {
		return fmt.Errorf("field is_active: required")
	}
	if v, ok := raw["local_currency"]; !ok || v == nil {
		return fmt.Errorf("field local_currency: required")
	}
	if v, ok := raw["max_order_amount"]; !ok || v == nil {
		return fmt.Errorf("field max_order_amount: required")
	}
	if v, ok := raw["max_order_amount_display"]; !ok || v == nil {
		return fmt.Errorf("field max_order_amount_display: required")
	}
	if v, ok := raw["max_order_amount_limit"]; !ok || v == nil {
		return fmt.Errorf("field max_order_amount_limit: required")
	}
	if v, ok := raw["max_order_amount_limit_display"]; !ok || v == nil {
		return fmt.Errorf("field max_order_amount_limit_display: required")
	}
	if v, ok := raw["min_order_amount"]; !ok || v == nil {
		return fmt.Errorf("field min_order_amount: required")
	}
	if v, ok := raw["min_order_amount_display"]; !ok || v == nil {
		return fmt.Errorf("field min_order_amount_display: required")
	}
	if v, ok := raw["min_order_amount_limit"]; !ok || v == nil {
		return fmt.Errorf("field min_order_amount_limit: required")
	}
	if v, ok := raw["min_order_amount_limit_display"]; !ok || v == nil {
		return fmt.Errorf("field min_order_amount_limit_display: required")
	}
	if v, ok := raw["payment_method"]; !ok || v == nil {
		return fmt.Errorf("field payment_method: required")
	}
	if v, ok := raw["price"]; !ok || v == nil {
		return fmt.Errorf("field price: required")
	}
	if v, ok := raw["price_display"]; !ok || v == nil {
		return fmt.Errorf("field price_display: required")
	}
	if v, ok := raw["rate"]; !ok || v == nil {
		return fmt.Errorf("field rate: required")
	}
	if v, ok := raw["rate_display"]; !ok || v == nil {
		return fmt.Errorf("field rate_display: required")
	}
	if v, ok := raw["rate_type"]; !ok || v == nil {
		return fmt.Errorf("field rate_type: required")
	}
	if v, ok := raw["remaining_amount"]; !ok || v == nil {
		return fmt.Errorf("field remaining_amount: required")
	}
	if v, ok := raw["remaining_amount_display"]; !ok || v == nil {
		return fmt.Errorf("field remaining_amount_display: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain P2PAdvertCreateRespP2PAdvertCreate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["is_visible"]; !ok || v == nil {
		plain.IsVisible = 0
	}
	*j = P2PAdvertCreateRespP2PAdvertCreate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem, v)
	}
	*j = P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreateRespP2PAdvertCreateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertCreateRespP2PAdvertCreateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertCreateRespP2PAdvertCreateType, v)
	}
	*j = P2PAdvertCreateRespP2PAdvertCreateType(v)
	return nil
}

var enumValues_SetFinancialAssessmentTradingExperienceRegulatedTradingFrequencyFinancialInstruments = []interface{}{
	"No transactions in the past 12 months",
	"1 - 5 transactions in the past 12 months",
	"6 - 10 transactions in the past 12 months",
	"11 - 39 transactions in the past 12 months",
	"40 transactions or more in the past 12 months",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentTradingExperienceRegulatedTradingFrequencyFinancialInstruments) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentTradingExperienceRegulatedTradingFrequencyFinancialInstruments {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentTradingExperienceRegulatedTradingFrequencyFinancialInstruments, v)
	}
	*j = SetFinancialAssessmentTradingExperienceRegulatedTradingFrequencyFinancialInstruments(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreateRespP2PAdvertCreateRateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertCreateRespP2PAdvertCreateRateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertCreateRespP2PAdvertCreateRateType, v)
	}
	*j = P2PAdvertCreateRespP2PAdvertCreateRateType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreateRespP2PAdvertCreateIsVisible) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertCreateRespP2PAdvertCreateIsVisible {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertCreateRespP2PAdvertCreateIsVisible, v)
	}
	*j = P2PAdvertCreateRespP2PAdvertCreateIsVisible(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreateRespP2PAdvertCreateIsActive) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertCreateRespP2PAdvertCreateIsActive {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertCreateRespP2PAdvertCreateIsActive, v)
	}
	*j = P2PAdvertCreateRespP2PAdvertCreateIsActive(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreateRespP2PAdvertCreateCounterpartyType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertCreateRespP2PAdvertCreateCounterpartyType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertCreateRespP2PAdvertCreateCounterpartyType, v)
	}
	*j = P2PAdvertCreateRespP2PAdvertCreateCounterpartyType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreateRespP2PAdvertCreateBlockTrade) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertCreateRespP2PAdvertCreateBlockTrade {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertCreateRespP2PAdvertCreateBlockTrade, v)
	}
	*j = P2PAdvertCreateRespP2PAdvertCreateBlockTrade(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["completed_orders_count"]; !ok || v == nil {
		return fmt.Errorf("field completed_orders_count: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["is_online"]; !ok || v == nil {
		return fmt.Errorf("field is_online: required")
	}
	if v, ok := raw["last_online_time"]; !ok || v == nil {
		return fmt.Errorf("field last_online_time: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["rating_average"]; !ok || v == nil {
		return fmt.Errorf("field rating_average: required")
	}
	if v, ok := raw["rating_count"]; !ok || v == nil {
		return fmt.Errorf("field rating_count: required")
	}
	if v, ok := raw["recommended_average"]; !ok || v == nil {
		return fmt.Errorf("field recommended_average: required")
	}
	if v, ok := raw["recommended_count"]; !ok || v == nil {
		return fmt.Errorf("field recommended_count: required")
	}
	if v, ok := raw["total_completion_rate"]; !ok || v == nil {
		return fmt.Errorf("field total_completion_rate: required")
	}
	type Plain P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetails(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentTradingExperienceRegulated) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["cfd_experience"]; !ok || v == nil {
		return fmt.Errorf("field cfd_experience: required")
	}
	if v, ok := raw["cfd_frequency"]; !ok || v == nil {
		return fmt.Errorf("field cfd_frequency: required")
	}
	if v, ok := raw["cfd_trading_definition"]; !ok || v == nil {
		return fmt.Errorf("field cfd_trading_definition: required")
	}
	if v, ok := raw["leverage_impact_trading"]; !ok || v == nil {
		return fmt.Errorf("field leverage_impact_trading: required")
	}
	if v, ok := raw["leverage_trading_high_risk_stop_loss"]; !ok || v == nil {
		return fmt.Errorf("field leverage_trading_high_risk_stop_loss: required")
	}
	if v, ok := raw["required_initial_margin"]; !ok || v == nil {
		return fmt.Errorf("field required_initial_margin: required")
	}
	if v, ok := raw["risk_tolerance"]; !ok || v == nil {
		return fmt.Errorf("field risk_tolerance: required")
	}
	if v, ok := raw["source_of_experience"]; !ok || v == nil {
		return fmt.Errorf("field source_of_experience: required")
	}
	if v, ok := raw["trading_experience_financial_instruments"]; !ok || v == nil {
		return fmt.Errorf("field trading_experience_financial_instruments: required")
	}
	if v, ok := raw["trading_frequency_financial_instruments"]; !ok || v == nil {
		return fmt.Errorf("field trading_frequency_financial_instruments: required")
	}
	type Plain SetFinancialAssessmentTradingExperienceRegulated
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SetFinancialAssessmentTradingExperienceRegulated(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetailsIsOnline) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetailsIsOnline {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetailsIsOnline, v)
	}
	*j = P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetailsIsOnline(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessment) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["set_financial_assessment"]; !ok || v == nil {
		return fmt.Errorf("field set_financial_assessment: required")
	}
	type Plain SetFinancialAssessment
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SetFinancialAssessment(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreateRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertCreateRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertCreateRespMsgType, v)
	}
	*j = P2PAdvertCreateRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["max_order_amount"]; !ok || v == nil {
		return fmt.Errorf("field max_order_amount: required")
	}
	if v, ok := raw["min_order_amount"]; !ok || v == nil {
		return fmt.Errorf("field min_order_amount: required")
	}
	if v, ok := raw["p2p_advert_create"]; !ok || v == nil {
		return fmt.Errorf("field p2p_advert_create: required")
	}
	if v, ok := raw["rate"]; !ok || v == nil {
		return fmt.Errorf("field rate: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	type Plain P2PAdvertCreate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["block_trade"]; !ok || v == nil {
		plain.BlockTrade = 0
	}
	if v, ok := raw["rate_type"]; !ok || v == nil {
		plain.RateType = "fixed"
	}
	*j = P2PAdvertCreate(plain)
	return nil
}

var enumValues_SetFinancialAssessmentRespMsgType = []interface{}{
	"set_financial_assessment",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetFinancialAssessmentRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetFinancialAssessmentRespMsgType, v)
	}
	*j = SetFinancialAssessmentRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertCreateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertCreateType, v)
	}
	*j = P2PAdvertCreateType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreateRateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertCreateRateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertCreateRateType, v)
	}
	*j = P2PAdvertCreateRateType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreateP2PAdvertCreate) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertCreateP2PAdvertCreate {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertCreateP2PAdvertCreate, v)
	}
	*j = P2PAdvertCreateP2PAdvertCreate(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetFinancialAssessmentResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain SetFinancialAssessmentResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SetFinancialAssessmentResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreateBlockTrade) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertCreateBlockTrade {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertCreateBlockTrade, v)
	}
	*j = P2PAdvertCreateBlockTrade(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OauthAppsResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain OauthAppsResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = OauthAppsResp(plain)
	return nil
}

var enumValues_SetSelfExclusionSetSelfExclusion = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetSelfExclusionSetSelfExclusion) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetSelfExclusionSetSelfExclusion {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetSelfExclusionSetSelfExclusion, v)
	}
	*j = SetSelfExclusionSetSelfExclusion(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OauthAppsRespOauthAppsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["app_id"]; !ok || v == nil {
		return fmt.Errorf("field app_id: required")
	}
	if v, ok := raw["app_markup_percentage"]; !ok || v == nil {
		return fmt.Errorf("field app_markup_percentage: required")
	}
	if v, ok := raw["last_used"]; !ok || v == nil {
		return fmt.Errorf("field last_used: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["official"]; !ok || v == nil {
		return fmt.Errorf("field official: required")
	}
	if v, ok := raw["scopes"]; !ok || v == nil {
		return fmt.Errorf("field scopes: required")
	}
	type Plain OauthAppsRespOauthAppsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = OauthAppsRespOauthAppsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetSelfExclusion) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["set_self_exclusion"]; !ok || v == nil {
		return fmt.Errorf("field set_self_exclusion: required")
	}
	type Plain SetSelfExclusion
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SetSelfExclusion(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OauthAppsRespOauthAppsElemOfficial) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_OauthAppsRespOauthAppsElemOfficial {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_OauthAppsRespOauthAppsElemOfficial, v)
	}
	*j = OauthAppsRespOauthAppsElemOfficial(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OauthAppsRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_OauthAppsRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_OauthAppsRespMsgType, v)
	}
	*j = OauthAppsRespMsgType(v)
	return nil
}

var enumValues_SetSelfExclusionRespMsgType = []interface{}{
	"set_self_exclusion",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetSelfExclusionRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetSelfExclusionRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetSelfExclusionRespMsgType, v)
	}
	*j = SetSelfExclusionRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OauthApps) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["oauth_apps"]; !ok || v == nil {
		return fmt.Errorf("field oauth_apps: required")
	}
	type Plain OauthApps
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = OauthApps(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *OauthAppsOauthApps) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_OauthAppsOauthApps {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_OauthAppsOauthApps, v)
	}
	*j = OauthAppsOauthApps(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetSelfExclusionResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain SetSelfExclusionResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SetSelfExclusionResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountVirtualResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain NewAccountVirtualResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NewAccountVirtualResp(plain)
	return nil
}

var enumValues_SetSettingsAccountOpeningReason = []interface{}{
	"Speculative",
	"Income Earning",
	"Hedging",
	"Peer-to-peer exchange",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetSettingsAccountOpeningReason) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetSettingsAccountOpeningReason {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetSettingsAccountOpeningReason, v)
	}
	*j = SetSettingsAccountOpeningReason(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountVirtualRespNewAccountVirtual) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["balance"]; !ok || v == nil {
		return fmt.Errorf("field balance: required")
	}
	if v, ok := raw["client_id"]; !ok || v == nil {
		return fmt.Errorf("field client_id: required")
	}
	if v, ok := raw["currency"]; !ok || v == nil {
		return fmt.Errorf("field currency: required")
	}
	if v, ok := raw["email"]; !ok || v == nil {
		return fmt.Errorf("field email: required")
	}
	if v, ok := raw["oauth_token"]; !ok || v == nil {
		return fmt.Errorf("field oauth_token: required")
	}
	type Plain NewAccountVirtualRespNewAccountVirtual
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NewAccountVirtualRespNewAccountVirtual(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountVirtualRespNewAccountVirtualType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountVirtualRespNewAccountVirtualType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountVirtualRespNewAccountVirtualType, v)
	}
	*j = NewAccountVirtualRespNewAccountVirtualType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountVirtualRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountVirtualRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountVirtualRespMsgType, v)
	}
	*j = NewAccountVirtualRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountVirtual) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["new_account_virtual"]; !ok || v == nil {
		return fmt.Errorf("field new_account_virtual: required")
	}
	type Plain NewAccountVirtual
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		plain.Type = "trading"
	}
	*j = NewAccountVirtual(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountVirtualType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountVirtualType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountVirtualType, v)
	}
	*j = NewAccountVirtualType(v)
	return nil
}

var enumValues_SetSettingsAllowCopiers = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetSettingsAllowCopiers) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetSettingsAllowCopiers {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetSettingsAllowCopiers, v)
	}
	*j = SetSettingsAllowCopiers(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountVirtualSignupDevice) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountVirtualSignupDevice {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountVirtualSignupDevice, v)
	}
	*j = NewAccountVirtualSignupDevice(v)
	return nil
}

var enumValues_SetSettingsDxtradeUserException = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetSettingsDxtradeUserException) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetSettingsDxtradeUserException {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetSettingsDxtradeUserException, v)
	}
	*j = SetSettingsDxtradeUserException(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountVirtualNewAccountVirtual) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountVirtualNewAccountVirtual {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountVirtualNewAccountVirtual, v)
	}
	*j = NewAccountVirtualNewAccountVirtual(v)
	return nil
}

var enumValues_SetSettingsEmailConsent = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetSettingsEmailConsent) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetSettingsEmailConsent {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetSettingsEmailConsent, v)
	}
	*j = SetSettingsEmailConsent(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountVirtualEmailConsent) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountVirtualEmailConsent {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountVirtualEmailConsent, v)
	}
	*j = NewAccountVirtualEmailConsent(v)
	return nil
}

var enumValues_SetSettingsEmploymentStatus = []interface{}{
	"Employed",
	"Pensioner",
	"Self-Employed",
	"Student",
	"Unemployed",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetSettingsEmploymentStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetSettingsEmploymentStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetSettingsEmploymentStatus, v)
	}
	*j = SetSettingsEmploymentStatus(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountRealResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain NewAccountRealResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NewAccountRealResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountRealRespNewAccountReal) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["client_id"]; !ok || v == nil {
		return fmt.Errorf("field client_id: required")
	}
	if v, ok := raw["landing_company"]; !ok || v == nil {
		return fmt.Errorf("field landing_company: required")
	}
	if v, ok := raw["oauth_token"]; !ok || v == nil {
		return fmt.Errorf("field oauth_token: required")
	}
	type Plain NewAccountRealRespNewAccountReal
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NewAccountRealRespNewAccountReal(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountRealRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountRealRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountRealRespMsgType, v)
	}
	*j = NewAccountRealRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountReal) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["new_account_real"]; !ok || v == nil {
		return fmt.Errorf("field new_account_real: required")
	}
	type Plain NewAccountReal
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["client_type"]; !ok || v == nil {
		plain.ClientType = "retail"
	}
	*j = NewAccountReal(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountRealSecretQuestion) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountRealSecretQuestion {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountRealSecretQuestion, v)
	}
	*j = NewAccountRealSecretQuestion(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountRealSalutation) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountRealSalutation {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountRealSalutation, v)
	}
	*j = NewAccountRealSalutation(v)
	return nil
}

var enumValues_SetSettingsFeatureFlagWallet = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetSettingsFeatureFlagWallet) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetSettingsFeatureFlagWallet {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetSettingsFeatureFlagWallet, v)
	}
	*j = SetSettingsFeatureFlagWallet(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountRealNewAccountReal) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountRealNewAccountReal {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountRealNewAccountReal, v)
	}
	*j = NewAccountRealNewAccountReal(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountRealClientType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountRealClientType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountRealClientType, v)
	}
	*j = NewAccountRealClientType(v)
	return nil
}

var enumValues_SetSettingsNonPepDeclaration = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetSettingsNonPepDeclaration) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetSettingsNonPepDeclaration {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetSettingsNonPepDeclaration, v)
	}
	*j = SetSettingsNonPepDeclaration(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountRealAccountTurnover) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountRealAccountTurnover {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountRealAccountTurnover, v)
	}
	*j = NewAccountRealAccountTurnover(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountRealAccountOpeningReason) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountRealAccountOpeningReason {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountRealAccountOpeningReason, v)
	}
	*j = NewAccountRealAccountOpeningReason(v)
	return nil
}

var enumValues_SetSettingsRequestProfessionalStatus = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetSettingsRequestProfessionalStatus) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetSettingsRequestProfessionalStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetSettingsRequestProfessionalStatus, v)
	}
	*j = SetSettingsRequestProfessionalStatus(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountMaltainvestResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain NewAccountMaltainvestResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NewAccountMaltainvestResp(plain)
	return nil
}

var enumValues_SetSettingsSalutation = []interface{}{
	"Mr",
	"Ms",
	"Miss",
	"Mrs",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetSettingsSalutation) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetSettingsSalutation {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetSettingsSalutation, v)
	}
	*j = SetSettingsSalutation(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountMaltainvestRespNewAccountMaltainvest) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["client_id"]; !ok || v == nil {
		return fmt.Errorf("field client_id: required")
	}
	if v, ok := raw["landing_company"]; !ok || v == nil {
		return fmt.Errorf("field landing_company: required")
	}
	if v, ok := raw["oauth_token"]; !ok || v == nil {
		return fmt.Errorf("field oauth_token: required")
	}
	type Plain NewAccountMaltainvestRespNewAccountMaltainvest
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = NewAccountMaltainvestRespNewAccountMaltainvest(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountMaltainvestRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountMaltainvestRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountMaltainvestRespMsgType, v)
	}
	*j = NewAccountMaltainvestRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountMaltainvest) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["address_city"]; !ok || v == nil {
		return fmt.Errorf("field address_city: required")
	}
	if v, ok := raw["address_line_1"]; !ok || v == nil {
		return fmt.Errorf("field address_line_1: required")
	}
	if v, ok := raw["date_of_birth"]; !ok || v == nil {
		return fmt.Errorf("field date_of_birth: required")
	}
	if v, ok := raw["employment_status"]; !ok || v == nil {
		return fmt.Errorf("field employment_status: required")
	}
	if v, ok := raw["first_name"]; !ok || v == nil {
		return fmt.Errorf("field first_name: required")
	}
	if v, ok := raw["last_name"]; !ok || v == nil {
		return fmt.Errorf("field last_name: required")
	}
	if v, ok := raw["new_account_maltainvest"]; !ok || v == nil {
		return fmt.Errorf("field new_account_maltainvest: required")
	}
	if v, ok := raw["residence"]; !ok || v == nil {
		return fmt.Errorf("field residence: required")
	}
	if v, ok := raw["salutation"]; !ok || v == nil {
		return fmt.Errorf("field salutation: required")
	}
	if v, ok := raw["tax_identification_number"]; !ok || v == nil {
		return fmt.Errorf("field tax_identification_number: required")
	}
	if v, ok := raw["tax_residence"]; !ok || v == nil {
		return fmt.Errorf("field tax_residence: required")
	}
	type Plain NewAccountMaltainvest
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["client_type"]; !ok || v == nil {
		plain.ClientType = "retail"
	}
	*j = NewAccountMaltainvest(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountMaltainvestTradingFrequencyFinancialInstruments) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountMaltainvestTradingFrequencyFinancialInstruments {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountMaltainvestTradingFrequencyFinancialInstruments, v)
	}
	*j = NewAccountMaltainvestTradingFrequencyFinancialInstruments(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountMaltainvestTradingExperienceFinancialInstruments) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountMaltainvestTradingExperienceFinancialInstruments {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountMaltainvestTradingExperienceFinancialInstruments, v)
	}
	*j = NewAccountMaltainvestTradingExperienceFinancialInstruments(v)
	return nil
}

var enumValues_SetSettingsSecretQuestion = []interface{}{
	"Mother's maiden name",
	"Name of your pet",
	"Name of first love",
	"Memorable town/city",
	"Memorable date",
	"Favourite dish",
	"Brand of first car",
	"Favourite artist",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetSettingsSecretQuestion) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetSettingsSecretQuestion {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetSettingsSecretQuestion, v)
	}
	*j = SetSettingsSecretQuestion(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountMaltainvestSourceOfWealth) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountMaltainvestSourceOfWealth {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountMaltainvestSourceOfWealth, v)
	}
	*j = NewAccountMaltainvestSourceOfWealth(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountMaltainvestSourceOfExperience) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountMaltainvestSourceOfExperience {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountMaltainvestSourceOfExperience, v)
	}
	*j = NewAccountMaltainvestSourceOfExperience(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountMaltainvestSecretQuestion) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountMaltainvestSecretQuestion {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountMaltainvestSecretQuestion, v)
	}
	*j = NewAccountMaltainvestSecretQuestion(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountMaltainvestSalutation) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountMaltainvestSalutation {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountMaltainvestSalutation, v)
	}
	*j = NewAccountMaltainvestSalutation(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountMaltainvestRiskTolerance) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountMaltainvestRiskTolerance {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountMaltainvestRiskTolerance, v)
	}
	*j = NewAccountMaltainvestRiskTolerance(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountMaltainvestRequiredInitialMargin) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountMaltainvestRequiredInitialMargin {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountMaltainvestRequiredInitialMargin, v)
	}
	*j = NewAccountMaltainvestRequiredInitialMargin(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountMaltainvestOccupation) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountMaltainvestOccupation {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountMaltainvestOccupation, v)
	}
	*j = NewAccountMaltainvestOccupation(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountMaltainvestNewAccountMaltainvest) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountMaltainvestNewAccountMaltainvest {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountMaltainvestNewAccountMaltainvest, v)
	}
	*j = NewAccountMaltainvestNewAccountMaltainvest(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountMaltainvestNetIncome) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountMaltainvestNetIncome {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountMaltainvestNetIncome, v)
	}
	*j = NewAccountMaltainvestNetIncome(v)
	return nil
}

var enumValues_SetSettingsSetSettings = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetSettingsSetSettings) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetSettingsSetSettings {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetSettingsSetSettings, v)
	}
	*j = SetSettingsSetSettings(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountMaltainvestLeverageTradingHighRiskStopLoss) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountMaltainvestLeverageTradingHighRiskStopLoss {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountMaltainvestLeverageTradingHighRiskStopLoss, v)
	}
	*j = NewAccountMaltainvestLeverageTradingHighRiskStopLoss(v)
	return nil
}

var enumValues_SetSettingsTradingHub = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetSettingsTradingHub) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetSettingsTradingHub {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetSettingsTradingHub, v)
	}
	*j = SetSettingsTradingHub(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountMaltainvestLeverageImpactTrading) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountMaltainvestLeverageImpactTrading {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountMaltainvestLeverageImpactTrading, v)
	}
	*j = NewAccountMaltainvestLeverageImpactTrading(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetSettings) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["set_settings"]; !ok || v == nil {
		return fmt.Errorf("field set_settings: required")
	}
	type Plain SetSettings
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SetSettings(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountMaltainvestIncomeSource) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountMaltainvestIncomeSource {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountMaltainvestIncomeSource, v)
	}
	*j = NewAccountMaltainvestIncomeSource(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountMaltainvestEstimatedWorth) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountMaltainvestEstimatedWorth {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountMaltainvestEstimatedWorth, v)
	}
	*j = NewAccountMaltainvestEstimatedWorth(v)
	return nil
}

var enumValues_SetSettingsRespMsgType = []interface{}{
	"set_settings",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetSettingsRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SetSettingsRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SetSettingsRespMsgType, v)
	}
	*j = SetSettingsRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountMaltainvestEmploymentStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountMaltainvestEmploymentStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountMaltainvestEmploymentStatus, v)
	}
	*j = NewAccountMaltainvestEmploymentStatus(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountMaltainvestEmploymentIndustry) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountMaltainvestEmploymentIndustry {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountMaltainvestEmploymentIndustry, v)
	}
	*j = NewAccountMaltainvestEmploymentIndustry(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SetSettingsResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain SetSettingsResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SetSettingsResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountMaltainvestEducationLevel) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountMaltainvestEducationLevel {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountMaltainvestEducationLevel, v)
	}
	*j = NewAccountMaltainvestEducationLevel(v)
	return nil
}

var enumValues_StatementActionType = []interface{}{
	"buy",
	"sell",
	"deposit",
	"withdrawal",
	"escrow",
	"adjustment",
	"virtual_credit",
	"transfer",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StatementActionType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_StatementActionType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_StatementActionType, v)
	}
	*j = StatementActionType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountMaltainvestClientType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountMaltainvestClientType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountMaltainvestClientType, v)
	}
	*j = NewAccountMaltainvestClientType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountMaltainvestCfdTradingDefinition) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountMaltainvestCfdTradingDefinition {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountMaltainvestCfdTradingDefinition, v)
	}
	*j = NewAccountMaltainvestCfdTradingDefinition(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountMaltainvestCfdFrequency) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountMaltainvestCfdFrequency {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountMaltainvestCfdFrequency, v)
	}
	*j = NewAccountMaltainvestCfdFrequency(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountMaltainvestCfdExperience) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountMaltainvestCfdExperience {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountMaltainvestCfdExperience, v)
	}
	*j = NewAccountMaltainvestCfdExperience(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountMaltainvestAccountTurnover) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountMaltainvestAccountTurnover {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountMaltainvestAccountTurnover, v)
	}
	*j = NewAccountMaltainvestAccountTurnover(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountMaltainvestAccountOpeningReason) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountMaltainvestAccountOpeningReason {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountMaltainvestAccountOpeningReason, v)
	}
	*j = NewAccountMaltainvestAccountOpeningReason(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountMaltainvestAcceptRisk) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountMaltainvestAcceptRisk {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountMaltainvestAcceptRisk, v)
	}
	*j = NewAccountMaltainvestAcceptRisk(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5WithdrawalResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain Mt5WithdrawalResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Mt5WithdrawalResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5WithdrawalRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5WithdrawalRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5WithdrawalRespMsgType, v)
	}
	*j = Mt5WithdrawalRespMsgType(v)
	return nil
}

var enumValues_StatementDescription = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StatementDescription) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_StatementDescription {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_StatementDescription, v)
	}
	*j = StatementDescription(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5Withdrawal) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["from_mt5"]; !ok || v == nil {
		return fmt.Errorf("field from_mt5: required")
	}
	if v, ok := raw["mt5_withdrawal"]; !ok || v == nil {
		return fmt.Errorf("field mt5_withdrawal: required")
	}
	if v, ok := raw["to_binary"]; !ok || v == nil {
		return fmt.Errorf("field to_binary: required")
	}
	type Plain Mt5Withdrawal
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Mt5Withdrawal(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5WithdrawalMt5Withdrawal) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5WithdrawalMt5Withdrawal {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5WithdrawalMt5Withdrawal, v)
	}
	*j = Mt5WithdrawalMt5Withdrawal(v)
	return nil
}

var enumValues_StatementStatement = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StatementStatement) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_StatementStatement {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_StatementStatement, v)
	}
	*j = StatementStatement(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5PasswordResetResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain Mt5PasswordResetResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Mt5PasswordResetResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Statement) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["statement"]; !ok || v == nil {
		return fmt.Errorf("field statement: required")
	}
	type Plain Statement
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["limit"]; !ok || v == nil {
		plain.Limit = 100
	}
	*j = Statement(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5PasswordResetRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5PasswordResetRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5PasswordResetRespMsgType, v)
	}
	*j = Mt5PasswordResetRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5PasswordReset) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["login"]; !ok || v == nil {
		return fmt.Errorf("field login: required")
	}
	if v, ok := raw["mt5_password_reset"]; !ok || v == nil {
		return fmt.Errorf("field mt5_password_reset: required")
	}
	if v, ok := raw["new_password"]; !ok || v == nil {
		return fmt.Errorf("field new_password: required")
	}
	if v, ok := raw["verification_code"]; !ok || v == nil {
		return fmt.Errorf("field verification_code: required")
	}
	type Plain Mt5PasswordReset
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["password_type"]; !ok || v == nil {
		plain.PasswordType = "main"
	}
	*j = Mt5PasswordReset(plain)
	return nil
}

var enumValues_StatementRespMsgType = []interface{}{
	"statement",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StatementRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_StatementRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_StatementRespMsgType, v)
	}
	*j = StatementRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5PasswordResetPasswordType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5PasswordResetPasswordType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5PasswordResetPasswordType, v)
	}
	*j = Mt5PasswordResetPasswordType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5PasswordResetMt5PasswordReset) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5PasswordResetMt5PasswordReset {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5PasswordResetMt5PasswordReset, v)
	}
	*j = Mt5PasswordResetMt5PasswordReset(v)
	return nil
}

var enumValues_StatementRespStatementTransactionsElemActionType = []interface{}{
	"buy",
	"sell",
	"deposit",
	"withdrawal",
	"hold",
	"release",
	"adjustment",
	"virtual_credit",
	"transfer",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StatementRespStatementTransactionsElemActionType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_StatementRespStatementTransactionsElemActionType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_StatementRespStatementTransactionsElemActionType, v)
	}
	*j = StatementRespStatementTransactionsElemActionType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5PasswordCheckResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain Mt5PasswordCheckResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Mt5PasswordCheckResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5PasswordCheckRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5PasswordCheckRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5PasswordCheckRespMsgType, v)
	}
	*j = Mt5PasswordCheckRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5PasswordCheck) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["login"]; !ok || v == nil {
		return fmt.Errorf("field login: required")
	}
	if v, ok := raw["mt5_password_check"]; !ok || v == nil {
		return fmt.Errorf("field mt5_password_check: required")
	}
	if v, ok := raw["password"]; !ok || v == nil {
		return fmt.Errorf("field password: required")
	}
	type Plain Mt5PasswordCheck
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["password_type"]; !ok || v == nil {
		plain.PasswordType = "main"
	}
	*j = Mt5PasswordCheck(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5PasswordCheckPasswordType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5PasswordCheckPasswordType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5PasswordCheckPasswordType, v)
	}
	*j = Mt5PasswordCheckPasswordType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5PasswordCheckMt5PasswordCheck) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5PasswordCheckMt5PasswordCheck {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5PasswordCheckMt5PasswordCheck, v)
	}
	*j = Mt5PasswordCheckMt5PasswordCheck(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5PasswordChangeResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain Mt5PasswordChangeResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Mt5PasswordChangeResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5PasswordChangeRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5PasswordChangeRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5PasswordChangeRespMsgType, v)
	}
	*j = Mt5PasswordChangeRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5PasswordChange) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["login"]; !ok || v == nil {
		return fmt.Errorf("field login: required")
	}
	if v, ok := raw["mt5_password_change"]; !ok || v == nil {
		return fmt.Errorf("field mt5_password_change: required")
	}
	if v, ok := raw["new_password"]; !ok || v == nil {
		return fmt.Errorf("field new_password: required")
	}
	if v, ok := raw["old_password"]; !ok || v == nil {
		return fmt.Errorf("field old_password: required")
	}
	type Plain Mt5PasswordChange
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["password_type"]; !ok || v == nil {
		plain.PasswordType = "main"
	}
	*j = Mt5PasswordChange(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5PasswordChangePasswordType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5PasswordChangePasswordType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5PasswordChangePasswordType, v)
	}
	*j = Mt5PasswordChangePasswordType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5PasswordChangeMt5PasswordChange) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5PasswordChangeMt5PasswordChange {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5PasswordChangeMt5PasswordChange, v)
	}
	*j = Mt5PasswordChangeMt5PasswordChange(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5NewAccountResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain Mt5NewAccountResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Mt5NewAccountResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5NewAccountRespMt5NewAccountMt5AccountType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5NewAccountRespMt5NewAccountMt5AccountType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5NewAccountRespMt5NewAccountMt5AccountType, v)
	}
	*j = Mt5NewAccountRespMt5NewAccountMt5AccountType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5NewAccountRespMt5NewAccountMt5AccountCategory) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5NewAccountRespMt5NewAccountMt5AccountCategory {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5NewAccountRespMt5NewAccountMt5AccountCategory, v)
	}
	*j = Mt5NewAccountRespMt5NewAccountMt5AccountCategory(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5NewAccountRespMt5NewAccountAccountType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5NewAccountRespMt5NewAccountAccountType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5NewAccountRespMt5NewAccountAccountType, v)
	}
	*j = Mt5NewAccountRespMt5NewAccountAccountType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5NewAccountRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5NewAccountRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5NewAccountRespMsgType, v)
	}
	*j = Mt5NewAccountRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StatementResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain StatementResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = StatementResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5NewAccount) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["account_type"]; !ok || v == nil {
		return fmt.Errorf("field account_type: required")
	}
	if v, ok := raw["email"]; !ok || v == nil {
		return fmt.Errorf("field email: required")
	}
	if v, ok := raw["leverage"]; !ok || v == nil {
		return fmt.Errorf("field leverage: required")
	}
	if v, ok := raw["mainPassword"]; !ok || v == nil {
		return fmt.Errorf("field mainPassword: required")
	}
	if v, ok := raw["mt5_new_account"]; !ok || v == nil {
		return fmt.Errorf("field mt5_new_account: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain Mt5NewAccount
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["dry_run"]; !ok || v == nil {
		plain.DryRun = 0
	}
	*j = Mt5NewAccount(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5NewAccountSubAccountCategory) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5NewAccountSubAccountCategory {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5NewAccountSubAccountCategory, v)
	}
	*j = Mt5NewAccountSubAccountCategory(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StatesList) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["states_list"]; !ok || v == nil {
		return fmt.Errorf("field states_list: required")
	}
	type Plain StatesList
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = StatesList(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5NewAccountServer) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5NewAccountServer {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5NewAccountServer, v)
	}
	*j = Mt5NewAccountServer(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5NewAccountMt5NewAccount) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5NewAccountMt5NewAccount {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5NewAccountMt5NewAccount, v)
	}
	*j = Mt5NewAccountMt5NewAccount(v)
	return nil
}

var enumValues_StatesListRespMsgType = []interface{}{
	"states_list",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StatesListRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_StatesListRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_StatesListRespMsgType, v)
	}
	*j = StatesListRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5NewAccountMt5AccountType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5NewAccountMt5AccountType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5NewAccountMt5AccountType, v)
	}
	*j = Mt5NewAccountMt5AccountType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5NewAccountMt5AccountCategory) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5NewAccountMt5AccountCategory {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5NewAccountMt5AccountCategory, v)
	}
	*j = Mt5NewAccountMt5AccountCategory(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5NewAccountDryRun) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5NewAccountDryRun {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5NewAccountDryRun, v)
	}
	*j = Mt5NewAccountDryRun(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StatesListResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain StatesListResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = StatesListResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5NewAccountAccountType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5NewAccountAccountType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5NewAccountAccountType, v)
	}
	*j = Mt5NewAccountAccountType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5LoginListResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain Mt5LoginListResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Mt5LoginListResp(plain)
	return nil
}

var enumValues_TicksSubscribe = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TicksSubscribe) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TicksSubscribe {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TicksSubscribe, v)
	}
	*j = TicksSubscribe(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5LoginListRespMt5LoginListElemSubAccountType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5LoginListRespMt5LoginListElemSubAccountType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5LoginListRespMt5LoginListElemSubAccountType, v)
	}
	*j = Mt5LoginListRespMt5LoginListElemSubAccountType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Ticks) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["ticks"]; !ok || v == nil {
		return fmt.Errorf("field ticks: required")
	}
	type Plain Ticks
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Ticks(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5LoginListRespMt5LoginListElemSubAccountCategory) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5LoginListRespMt5LoginListElemSubAccountCategory {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5LoginListRespMt5LoginListElemSubAccountCategory, v)
	}
	*j = Mt5LoginListRespMt5LoginListElemSubAccountCategory(v)
	return nil
}

var enumValues_TicksHistoryAdjustStartTime = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TicksHistoryAdjustStartTime) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TicksHistoryAdjustStartTime {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TicksHistoryAdjustStartTime, v)
	}
	*j = TicksHistoryAdjustStartTime(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5LoginListRespMt5LoginListElemServerInfoEnvironment) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5LoginListRespMt5LoginListElemServerInfoEnvironment {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5LoginListRespMt5LoginListElemServerInfoEnvironment, v)
	}
	*j = Mt5LoginListRespMt5LoginListElemServerInfoEnvironment(v)
	return nil
}

var enumValues_TicksHistoryGranularity = []interface{}{
	60,
	120,
	180,
	300,
	600,
	900,
	1800,
	3600,
	7200,
	14400,
	28800,
	86400,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TicksHistoryGranularity) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TicksHistoryGranularity {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TicksHistoryGranularity, v)
	}
	*j = TicksHistoryGranularity(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5LoginListRespMt5LoginListElemMarketType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5LoginListRespMt5LoginListElemMarketType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5LoginListRespMt5LoginListElemMarketType, v)
	}
	*j = Mt5LoginListRespMt5LoginListElemMarketType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5LoginListRespMt5LoginListElemLandingCompanyShort) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5LoginListRespMt5LoginListElemLandingCompanyShort {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5LoginListRespMt5LoginListElemLandingCompanyShort, v)
	}
	*j = Mt5LoginListRespMt5LoginListElemLandingCompanyShort(v)
	return nil
}

var enumValues_TicksHistoryStyle = []interface{}{
	"candles",
	"ticks",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TicksHistoryStyle) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TicksHistoryStyle {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TicksHistoryStyle, v)
	}
	*j = TicksHistoryStyle(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5LoginListRespMt5LoginListElemErrorDetailsServerInfoEnvironment) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5LoginListRespMt5LoginListElemErrorDetailsServerInfoEnvironment {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5LoginListRespMt5LoginListElemErrorDetailsServerInfoEnvironment, v)
	}
	*j = Mt5LoginListRespMt5LoginListElemErrorDetailsServerInfoEnvironment(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5LoginListRespMt5LoginListElemAccountType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5LoginListRespMt5LoginListElemAccountType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5LoginListRespMt5LoginListElemAccountType, v)
	}
	*j = Mt5LoginListRespMt5LoginListElemAccountType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5LoginListRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5LoginListRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5LoginListRespMsgType, v)
	}
	*j = Mt5LoginListRespMsgType(v)
	return nil
}

var enumValues_TicksHistorySubscribe = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TicksHistorySubscribe) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TicksHistorySubscribe {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TicksHistorySubscribe, v)
	}
	*j = TicksHistorySubscribe(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5LoginList) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["mt5_login_list"]; !ok || v == nil {
		return fmt.Errorf("field mt5_login_list: required")
	}
	type Plain Mt5LoginList
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Mt5LoginList(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TicksHistory) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["end"]; !ok || v == nil {
		return fmt.Errorf("field end: required")
	}
	if v, ok := raw["ticks_history"]; !ok || v == nil {
		return fmt.Errorf("field ticks_history: required")
	}
	type Plain TicksHistory
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["count"]; !ok || v == nil {
		plain.Count = 5000
	}
	if v, ok := raw["style"]; !ok || v == nil {
		plain.Style = "ticks"
	}
	*j = TicksHistory(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5LoginListMt5LoginList) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5LoginListMt5LoginList {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5LoginListMt5LoginList, v)
	}
	*j = Mt5LoginListMt5LoginList(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5GetSettingsResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain Mt5GetSettingsResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Mt5GetSettingsResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5GetSettingsRespMt5GetSettingsSubAccountType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5GetSettingsRespMt5GetSettingsSubAccountType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5GetSettingsRespMt5GetSettingsSubAccountType, v)
	}
	*j = Mt5GetSettingsRespMt5GetSettingsSubAccountType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5GetSettingsRespMt5GetSettingsMarketType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5GetSettingsRespMt5GetSettingsMarketType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5GetSettingsRespMt5GetSettingsMarketType, v)
	}
	*j = Mt5GetSettingsRespMt5GetSettingsMarketType(v)
	return nil
}

var enumValues_TicksHistoryRespMsgType = []interface{}{
	"history",
	"tick",
	"candles",
	"ohlc",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TicksHistoryRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TicksHistoryRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TicksHistoryRespMsgType, v)
	}
	*j = TicksHistoryRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5GetSettingsRespMt5GetSettingsLandingCompanyShort) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5GetSettingsRespMt5GetSettingsLandingCompanyShort {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5GetSettingsRespMt5GetSettingsLandingCompanyShort, v)
	}
	*j = Mt5GetSettingsRespMt5GetSettingsLandingCompanyShort(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5GetSettingsRespMt5GetSettingsAccountType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5GetSettingsRespMt5GetSettingsAccountType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5GetSettingsRespMt5GetSettingsAccountType, v)
	}
	*j = Mt5GetSettingsRespMt5GetSettingsAccountType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5GetSettingsRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5GetSettingsRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5GetSettingsRespMsgType, v)
	}
	*j = Mt5GetSettingsRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5GetSettings) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["login"]; !ok || v == nil {
		return fmt.Errorf("field login: required")
	}
	if v, ok := raw["mt5_get_settings"]; !ok || v == nil {
		return fmt.Errorf("field mt5_get_settings: required")
	}
	type Plain Mt5GetSettings
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Mt5GetSettings(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5GetSettingsMt5GetSettings) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5GetSettingsMt5GetSettings {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5GetSettingsMt5GetSettings, v)
	}
	*j = Mt5GetSettingsMt5GetSettings(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5DepositResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain Mt5DepositResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Mt5DepositResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TicksHistoryRespSubscription) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	type Plain TicksHistoryRespSubscription
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TicksHistoryRespSubscription(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5DepositRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5DepositRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5DepositRespMsgType, v)
	}
	*j = Mt5DepositRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TicksHistoryResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain TicksHistoryResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TicksHistoryResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5Deposit) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["mt5_deposit"]; !ok || v == nil {
		return fmt.Errorf("field mt5_deposit: required")
	}
	if v, ok := raw["to_mt5"]; !ok || v == nil {
		return fmt.Errorf("field to_mt5: required")
	}
	type Plain Mt5Deposit
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Mt5Deposit(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Mt5DepositMt5Deposit) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Mt5DepositMt5Deposit {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Mt5DepositMt5Deposit, v)
	}
	*j = Mt5DepositMt5Deposit(v)
	return nil
}

var enumValues_TicksRespMsgType = []interface{}{
	"tick",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TicksRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TicksRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TicksRespMsgType, v)
	}
	*j = TicksRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LogoutResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain LogoutResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LogoutResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LogoutRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LogoutRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LogoutRespMsgType, v)
	}
	*j = LogoutRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TicksRespSubscription) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	type Plain TicksRespSubscription
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TicksRespSubscription(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LogoutRespLogout) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LogoutRespLogout {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LogoutRespLogout, v)
	}
	*j = LogoutRespLogout(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TicksRespTick) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["pip_size"]; !ok || v == nil {
		return fmt.Errorf("field pip_size: required")
	}
	type Plain TicksRespTick
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TicksRespTick(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Logout) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["logout"]; !ok || v == nil {
		return fmt.Errorf("field logout: required")
	}
	type Plain Logout
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Logout(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TicksResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain TicksResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TicksResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LogoutLogout) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LogoutLogout {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LogoutLogout, v)
	}
	*j = LogoutLogout(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LoginHistoryResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain LoginHistoryResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LoginHistoryResp(plain)
	return nil
}

var enumValues_TimeTime = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TimeTime) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TimeTime {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TimeTime, v)
	}
	*j = TimeTime(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LoginHistoryRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LoginHistoryRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LoginHistoryRespMsgType, v)
	}
	*j = LoginHistoryRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Time) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["time"]; !ok || v == nil {
		return fmt.Errorf("field time: required")
	}
	type Plain Time
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Time(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LoginHistoryRespLoginHistoryElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["action"]; !ok || v == nil {
		return fmt.Errorf("field action: required")
	}
	if v, ok := raw["environment"]; !ok || v == nil {
		return fmt.Errorf("field environment: required")
	}
	if v, ok := raw["status"]; !ok || v == nil {
		return fmt.Errorf("field status: required")
	}
	if v, ok := raw["time"]; !ok || v == nil {
		return fmt.Errorf("field time: required")
	}
	type Plain LoginHistoryRespLoginHistoryElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LoginHistoryRespLoginHistoryElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LoginHistoryRespLoginHistoryElemStatus) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LoginHistoryRespLoginHistoryElemStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LoginHistoryRespLoginHistoryElemStatus, v)
	}
	*j = LoginHistoryRespLoginHistoryElemStatus(v)
	return nil
}

var enumValues_TimeRespMsgType = []interface{}{
	"time",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TimeRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TimeRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TimeRespMsgType, v)
	}
	*j = TimeRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LoginHistory) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["login_history"]; !ok || v == nil {
		return fmt.Errorf("field login_history: required")
	}
	type Plain LoginHistory
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["limit"]; !ok || v == nil {
		plain.Limit = 10
	}
	*j = LoginHistory(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LoginHistoryLoginHistory) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LoginHistoryLoginHistory {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LoginHistoryLoginHistory, v)
	}
	*j = LoginHistoryLoginHistory(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TimeResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain TimeResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TimeResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain LandingCompanyResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandingCompanyResp(plain)
	return nil
}

var enumValues_TncApprovalAffiliateCocAgreement = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TncApprovalAffiliateCocAgreement) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TncApprovalAffiliateCocAgreement {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TncApprovalAffiliateCocAgreement, v)
	}
	*j = TncApprovalAffiliateCocAgreement(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandingCompanyRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandingCompanyRespMsgType, v)
	}
	*j = LandingCompanyRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyRespLandingCompanyUkgcFundsProtection) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandingCompanyRespLandingCompanyUkgcFundsProtection {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandingCompanyRespLandingCompanyUkgcFundsProtection, v)
	}
	*j = LandingCompanyRespLandingCompanyUkgcFundsProtection(v)
	return nil
}

var enumValues_TncApprovalTncApproval = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TncApprovalTncApproval) UnmarshalJSON(b []byte) error {
	var v float64
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TncApprovalTncApproval {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TncApprovalTncApproval, v)
	}
	*j = TncApprovalTncApproval(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyRespLandingCompanySkipDepositVerification) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandingCompanyRespLandingCompanySkipDepositVerification {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandingCompanyRespLandingCompanySkipDepositVerification, v)
	}
	*j = LandingCompanyRespLandingCompanySkipDepositVerification(v)
	return nil
}

var enumValues_TncApprovalUkgcFundsProtection = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TncApprovalUkgcFundsProtection) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TncApprovalUkgcFundsProtection {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TncApprovalUkgcFundsProtection, v)
	}
	*j = TncApprovalUkgcFundsProtection(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyRespLandingCompanyRequireVerificationWhenNotAgeVerified) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandingCompanyRespLandingCompanyRequireVerificationWhenNotAgeVerified {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandingCompanyRespLandingCompanyRequireVerificationWhenNotAgeVerified, v)
	}
	*j = LandingCompanyRespLandingCompanyRequireVerificationWhenNotAgeVerified(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TncApproval) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["tnc_approval"]; !ok || v == nil {
		return fmt.Errorf("field tnc_approval: required")
	}
	type Plain TncApproval
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TncApproval(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyRespLandingCompanyRequirePoi) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandingCompanyRespLandingCompanyRequirePoi {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandingCompanyRespLandingCompanyRequirePoi, v)
	}
	*j = LandingCompanyRespLandingCompanyRequirePoi(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyRespLandingCompanyRequireAgeVerifiedForSynthetic) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandingCompanyRespLandingCompanyRequireAgeVerifiedForSynthetic {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandingCompanyRespLandingCompanyRequireAgeVerifiedForSynthetic, v)
	}
	*j = LandingCompanyRespLandingCompanyRequireAgeVerifiedForSynthetic(v)
	return nil
}

var enumValues_TncApprovalRespMsgType = []interface{}{
	"tnc_approval",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TncApprovalRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TncApprovalRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TncApprovalRespMsgType, v)
	}
	*j = TncApprovalRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyRespLandingCompanyRequireAddressPostcode) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandingCompanyRespLandingCompanyRequireAddressPostcode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandingCompanyRespLandingCompanyRequireAddressPostcode, v)
	}
	*j = LandingCompanyRespLandingCompanyRequireAddressPostcode(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyRespLandingCompanyNoProvince) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandingCompanyRespLandingCompanyNoProvince {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandingCompanyRespLandingCompanyNoProvince, v)
	}
	*j = LandingCompanyRespLandingCompanyNoProvince(v)
	return nil
}

var enumValues_TncApprovalRespTncApproval = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TncApprovalRespTncApproval) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TncApprovalRespTncApproval {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TncApprovalRespTncApproval, v)
	}
	*j = TncApprovalRespTncApproval(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyRespLandingCompanyNeedSetMaxTurnoverLimit) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandingCompanyRespLandingCompanyNeedSetMaxTurnoverLimit {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandingCompanyRespLandingCompanyNeedSetMaxTurnoverLimit, v)
	}
	*j = LandingCompanyRespLandingCompanyNeedSetMaxTurnoverLimit(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TncApprovalResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain TncApprovalResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TncApprovalResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyRespLandingCompanyMt5AgeVerification) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandingCompanyRespLandingCompanyMt5AgeVerification {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandingCompanyRespLandingCompanyMt5AgeVerification, v)
	}
	*j = LandingCompanyRespLandingCompanyMt5AgeVerification(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyRespLandingCompanyIsIdvSupported) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandingCompanyRespLandingCompanyIsIdvSupported {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandingCompanyRespLandingCompanyIsIdvSupported, v)
	}
	*j = LandingCompanyRespLandingCompanyIsIdvSupported(v)
	return nil
}

var enumValues_TopupVirtualTopupVirtual = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TopupVirtualTopupVirtual) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TopupVirtualTopupVirtual {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TopupVirtualTopupVirtual, v)
	}
	*j = TopupVirtualTopupVirtual(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyRespLandingCompanyDxtradeGamingCompanyStandardTinNotMandatory) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandingCompanyRespLandingCompanyDxtradeGamingCompanyStandardTinNotMandatory {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandingCompanyRespLandingCompanyDxtradeGamingCompanyStandardTinNotMandatory, v)
	}
	*j = LandingCompanyRespLandingCompanyDxtradeGamingCompanyStandardTinNotMandatory(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TopupVirtual) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["topup_virtual"]; !ok || v == nil {
		return fmt.Errorf("field topup_virtual: required")
	}
	type Plain TopupVirtual
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TopupVirtual(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyRespLandingCompanyDxtradeGamingCompanyStandardSupportProfessionalClient) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandingCompanyRespLandingCompanyDxtradeGamingCompanyStandardSupportProfessionalClient {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandingCompanyRespLandingCompanyDxtradeGamingCompanyStandardSupportProfessionalClient, v)
	}
	*j = LandingCompanyRespLandingCompanyDxtradeGamingCompanyStandardSupportProfessionalClient(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyRespLandingCompanyDxtradeGamingCompanyStandardHasRealityCheck) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandingCompanyRespLandingCompanyDxtradeGamingCompanyStandardHasRealityCheck {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandingCompanyRespLandingCompanyDxtradeGamingCompanyStandardHasRealityCheck, v)
	}
	*j = LandingCompanyRespLandingCompanyDxtradeGamingCompanyStandardHasRealityCheck(v)
	return nil
}

var enumValues_TopupVirtualRespMsgType = []interface{}{
	"topup_virtual",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TopupVirtualRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TopupVirtualRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TopupVirtualRespMsgType, v)
	}
	*j = TopupVirtualRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyRespLandingCompanyDxtradeFinancialCompanyStandardTinNotMandatory) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandingCompanyRespLandingCompanyDxtradeFinancialCompanyStandardTinNotMandatory {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandingCompanyRespLandingCompanyDxtradeFinancialCompanyStandardTinNotMandatory, v)
	}
	*j = LandingCompanyRespLandingCompanyDxtradeFinancialCompanyStandardTinNotMandatory(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyRespLandingCompanyDxtradeFinancialCompanyStandardSupportProfessionalClient) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandingCompanyRespLandingCompanyDxtradeFinancialCompanyStandardSupportProfessionalClient {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandingCompanyRespLandingCompanyDxtradeFinancialCompanyStandardSupportProfessionalClient, v)
	}
	*j = LandingCompanyRespLandingCompanyDxtradeFinancialCompanyStandardSupportProfessionalClient(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyRespLandingCompanyDxtradeFinancialCompanyStandardHasRealityCheck) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandingCompanyRespLandingCompanyDxtradeFinancialCompanyStandardHasRealityCheck {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandingCompanyRespLandingCompanyDxtradeFinancialCompanyStandardHasRealityCheck, v)
	}
	*j = LandingCompanyRespLandingCompanyDxtradeFinancialCompanyStandardHasRealityCheck(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TopupVirtualResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain TopupVirtualResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TopupVirtualResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyRespLandingCompanyDxtradeAllCompanyStandardTinNotMandatory) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandingCompanyRespLandingCompanyDxtradeAllCompanyStandardTinNotMandatory {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandingCompanyRespLandingCompanyDxtradeAllCompanyStandardTinNotMandatory, v)
	}
	*j = LandingCompanyRespLandingCompanyDxtradeAllCompanyStandardTinNotMandatory(v)
	return nil
}

var enumValues_TradingDurationsLandingCompany = []interface{}{
	"iom",
	"malta",
	"maltainvest",
	"svg",
	"virtual",
	"vanuatu",
	"champion",
	"champion-virtual",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingDurationsLandingCompany) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TradingDurationsLandingCompany {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TradingDurationsLandingCompany, v)
	}
	*j = TradingDurationsLandingCompany(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyRespLandingCompanyDxtradeAllCompanyStandardSupportProfessionalClient) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandingCompanyRespLandingCompanyDxtradeAllCompanyStandardSupportProfessionalClient {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandingCompanyRespLandingCompanyDxtradeAllCompanyStandardSupportProfessionalClient, v)
	}
	*j = LandingCompanyRespLandingCompanyDxtradeAllCompanyStandardSupportProfessionalClient(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyRespLandingCompanyDxtradeAllCompanyStandardHasRealityCheck) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandingCompanyRespLandingCompanyDxtradeAllCompanyStandardHasRealityCheck {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandingCompanyRespLandingCompanyDxtradeAllCompanyStandardHasRealityCheck, v)
	}
	*j = LandingCompanyRespLandingCompanyDxtradeAllCompanyStandardHasRealityCheck(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyRespLandingCompanyDerivezAllStandard) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandingCompanyRespLandingCompanyDerivezAllStandard {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandingCompanyRespLandingCompanyDerivezAllStandard, v)
	}
	*j = LandingCompanyRespLandingCompanyDerivezAllStandard(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyRespLandingCompanyCtraderAllStandard) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandingCompanyRespLandingCompanyCtraderAllStandard {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandingCompanyRespLandingCompanyCtraderAllStandard, v)
	}
	*j = LandingCompanyRespLandingCompanyCtraderAllStandard(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyRespLandingCompanyAllCompany) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandingCompanyRespLandingCompanyAllCompany {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandingCompanyRespLandingCompanyAllCompany, v)
	}
	*j = LandingCompanyRespLandingCompanyAllCompany(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyRespLandingCompanyAddressParseable) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandingCompanyRespLandingCompanyAddressParseable {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandingCompanyRespLandingCompanyAddressParseable, v)
	}
	*j = LandingCompanyRespLandingCompanyAddressParseable(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyDetailsResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain LandingCompanyDetailsResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandingCompanyDetailsResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyDetailsRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandingCompanyDetailsRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandingCompanyDetailsRespMsgType, v)
	}
	*j = LandingCompanyDetailsRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyDetailsRespLandingCompanyDetailsTinNotMandatory) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandingCompanyDetailsRespLandingCompanyDetailsTinNotMandatory {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandingCompanyDetailsRespLandingCompanyDetailsTinNotMandatory, v)
	}
	*j = LandingCompanyDetailsRespLandingCompanyDetailsTinNotMandatory(v)
	return nil
}

var enumValues_TradingDurationsLandingCompanyShort = []interface{}{
	"iom",
	"malta",
	"maltainvest",
	"svg",
	"virtual",
	"vanuatu",
	"champion",
	"champion-virtual",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingDurationsLandingCompanyShort) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TradingDurationsLandingCompanyShort {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TradingDurationsLandingCompanyShort, v)
	}
	*j = TradingDurationsLandingCompanyShort(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyDetailsRespLandingCompanyDetailsSupportProfessionalClient) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandingCompanyDetailsRespLandingCompanyDetailsSupportProfessionalClient {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandingCompanyDetailsRespLandingCompanyDetailsSupportProfessionalClient, v)
	}
	*j = LandingCompanyDetailsRespLandingCompanyDetailsSupportProfessionalClient(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyDetailsRespLandingCompanyDetailsHasRealityCheck) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandingCompanyDetailsRespLandingCompanyDetailsHasRealityCheck {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandingCompanyDetailsRespLandingCompanyDetailsHasRealityCheck, v)
	}
	*j = LandingCompanyDetailsRespLandingCompanyDetailsHasRealityCheck(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["landing_company_details"]; !ok || v == nil {
		return fmt.Errorf("field landing_company_details: required")
	}
	type Plain LandingCompanyDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandingCompanyDetails(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompanyDetailsLandingCompanyDetails) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_LandingCompanyDetailsLandingCompanyDetails {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_LandingCompanyDetailsLandingCompanyDetails, v)
	}
	*j = LandingCompanyDetailsLandingCompanyDetails(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LandingCompany) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["landing_company"]; !ok || v == nil {
		return fmt.Errorf("field landing_company: required")
	}
	type Plain LandingCompany
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = LandingCompany(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IdentityVerificationDocumentAddResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain IdentityVerificationDocumentAddResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = IdentityVerificationDocumentAddResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IdentityVerificationDocumentAddRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_IdentityVerificationDocumentAddRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_IdentityVerificationDocumentAddRespMsgType, v)
	}
	*j = IdentityVerificationDocumentAddRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IdentityVerificationDocumentAddRespIdentityVerificationDocumentAdd) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_IdentityVerificationDocumentAddRespIdentityVerificationDocumentAdd {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_IdentityVerificationDocumentAddRespIdentityVerificationDocumentAdd, v)
	}
	*j = IdentityVerificationDocumentAddRespIdentityVerificationDocumentAdd(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IdentityVerificationDocumentAdd) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["document_number"]; !ok || v == nil {
		return fmt.Errorf("field document_number: required")
	}
	if v, ok := raw["document_type"]; !ok || v == nil {
		return fmt.Errorf("field document_type: required")
	}
	if v, ok := raw["identity_verification_document_add"]; !ok || v == nil {
		return fmt.Errorf("field identity_verification_document_add: required")
	}
	if v, ok := raw["issuing_country"]; !ok || v == nil {
		return fmt.Errorf("field issuing_country: required")
	}
	type Plain IdentityVerificationDocumentAdd
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = IdentityVerificationDocumentAdd(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IdentityVerificationDocumentAddIdentityVerificationDocumentAdd) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_IdentityVerificationDocumentAddIdentityVerificationDocumentAdd {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_IdentityVerificationDocumentAddIdentityVerificationDocumentAdd, v)
	}
	*j = IdentityVerificationDocumentAddIdentityVerificationDocumentAdd(v)
	return nil
}

var enumValues_TradingDurationsTradingDurations = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingDurationsTradingDurations) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TradingDurationsTradingDurations {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TradingDurationsTradingDurations, v)
	}
	*j = TradingDurationsTradingDurations(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetSettingsResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain GetSettingsResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetSettingsResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingDurations) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["trading_durations"]; !ok || v == nil {
		return fmt.Errorf("field trading_durations: required")
	}
	type Plain TradingDurations
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TradingDurations(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetSettingsRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GetSettingsRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GetSettingsRespMsgType, v)
	}
	*j = GetSettingsRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetSettingsRespGetSettingsRequestProfessionalStatus) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GetSettingsRespGetSettingsRequestProfessionalStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GetSettingsRespGetSettingsRequestProfessionalStatus, v)
	}
	*j = GetSettingsRespGetSettingsRequestProfessionalStatus(v)
	return nil
}

var enumValues_TradingDurationsRespMsgType = []interface{}{
	"trading_durations",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingDurationsRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TradingDurationsRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TradingDurationsRespMsgType, v)
	}
	*j = TradingDurationsRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetSettingsRespGetSettingsNonPepDeclaration) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GetSettingsRespGetSettingsNonPepDeclaration {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GetSettingsRespGetSettingsNonPepDeclaration, v)
	}
	*j = GetSettingsRespGetSettingsNonPepDeclaration(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetSettingsRespGetSettingsIsAuthenticatedPaymentAgent) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GetSettingsRespGetSettingsIsAuthenticatedPaymentAgent {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GetSettingsRespGetSettingsIsAuthenticatedPaymentAgent, v)
	}
	*j = GetSettingsRespGetSettingsIsAuthenticatedPaymentAgent(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetSettingsRespGetSettingsHasSecretAnswer) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GetSettingsRespGetSettingsHasSecretAnswer {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GetSettingsRespGetSettingsHasSecretAnswer, v)
	}
	*j = GetSettingsRespGetSettingsHasSecretAnswer(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetSettingsRespGetSettingsFeatureFlagWallet) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GetSettingsRespGetSettingsFeatureFlagWallet {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GetSettingsRespGetSettingsFeatureFlagWallet, v)
	}
	*j = GetSettingsRespGetSettingsFeatureFlagWallet(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetSettingsRespGetSettingsEmploymentStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GetSettingsRespGetSettingsEmploymentStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GetSettingsRespGetSettingsEmploymentStatus, v)
	}
	*j = GetSettingsRespGetSettingsEmploymentStatus(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetSettingsRespGetSettingsEmailConsent) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GetSettingsRespGetSettingsEmailConsent {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GetSettingsRespGetSettingsEmailConsent, v)
	}
	*j = GetSettingsRespGetSettingsEmailConsent(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetSettingsRespGetSettingsDxtradeUserException) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GetSettingsRespGetSettingsDxtradeUserException {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GetSettingsRespGetSettingsDxtradeUserException, v)
	}
	*j = GetSettingsRespGetSettingsDxtradeUserException(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetSettingsRespGetSettingsAllowCopiers) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GetSettingsRespGetSettingsAllowCopiers {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GetSettingsRespGetSettingsAllowCopiers, v)
	}
	*j = GetSettingsRespGetSettingsAllowCopiers(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetSettings) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["get_settings"]; !ok || v == nil {
		return fmt.Errorf("field get_settings: required")
	}
	type Plain GetSettings
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetSettings(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetSettingsGetSettings) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GetSettingsGetSettings {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GetSettingsGetSettings, v)
	}
	*j = GetSettingsGetSettings(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetSelfExclusionResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain GetSelfExclusionResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetSelfExclusionResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetSelfExclusionRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GetSelfExclusionRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GetSelfExclusionRespMsgType, v)
	}
	*j = GetSelfExclusionRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingDurationsResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain TradingDurationsResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TradingDurationsResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetSelfExclusion) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["get_self_exclusion"]; !ok || v == nil {
		return fmt.Errorf("field get_self_exclusion: required")
	}
	type Plain GetSelfExclusion
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetSelfExclusion(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetSelfExclusionGetSelfExclusion) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GetSelfExclusionGetSelfExclusion {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GetSelfExclusionGetSelfExclusion, v)
	}
	*j = GetSelfExclusionGetSelfExclusion(v)
	return nil
}

var enumValues_TradingPlatformInvestorPasswordResetPlatform = []interface{}{
	"mt5",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingPlatformInvestorPasswordResetPlatform) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TradingPlatformInvestorPasswordResetPlatform {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TradingPlatformInvestorPasswordResetPlatform, v)
	}
	*j = TradingPlatformInvestorPasswordResetPlatform(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetLimitsResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain GetLimitsResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetLimitsResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetLimitsRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GetLimitsRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GetLimitsRespMsgType, v)
	}
	*j = GetLimitsRespMsgType(v)
	return nil
}

var enumValues_TradingPlatformInvestorPasswordResetTradingPlatformInvestorPasswordReset = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingPlatformInvestorPasswordResetTradingPlatformInvestorPasswordReset) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TradingPlatformInvestorPasswordResetTradingPlatformInvestorPasswordReset {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TradingPlatformInvestorPasswordResetTradingPlatformInvestorPasswordReset, v)
	}
	*j = TradingPlatformInvestorPasswordResetTradingPlatformInvestorPasswordReset(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetLimits) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["get_limits"]; !ok || v == nil {
		return fmt.Errorf("field get_limits: required")
	}
	type Plain GetLimits
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetLimits(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingPlatformInvestorPasswordReset) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["account_id"]; !ok || v == nil {
		return fmt.Errorf("field account_id: required")
	}
	if v, ok := raw["new_password"]; !ok || v == nil {
		return fmt.Errorf("field new_password: required")
	}
	if v, ok := raw["platform"]; !ok || v == nil {
		return fmt.Errorf("field platform: required")
	}
	if v, ok := raw["trading_platform_investor_password_reset"]; !ok || v == nil {
		return fmt.Errorf("field trading_platform_investor_password_reset: required")
	}
	if v, ok := raw["verification_code"]; !ok || v == nil {
		return fmt.Errorf("field verification_code: required")
	}
	type Plain TradingPlatformInvestorPasswordReset
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TradingPlatformInvestorPasswordReset(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetLimitsGetLimits) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GetLimitsGetLimits {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GetLimitsGetLimits, v)
	}
	*j = GetLimitsGetLimits(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetFinancialAssessmentResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain GetFinancialAssessmentResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetFinancialAssessmentResp(plain)
	return nil
}

var enumValues_TradingPlatformInvestorPasswordResetRespMsgType = []interface{}{
	"trading_platform_investor_password_reset",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingPlatformInvestorPasswordResetRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TradingPlatformInvestorPasswordResetRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TradingPlatformInvestorPasswordResetRespMsgType, v)
	}
	*j = TradingPlatformInvestorPasswordResetRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetFinancialAssessmentRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GetFinancialAssessmentRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GetFinancialAssessmentRespMsgType, v)
	}
	*j = GetFinancialAssessmentRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetFinancialAssessment) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["get_financial_assessment"]; !ok || v == nil {
		return fmt.Errorf("field get_financial_assessment: required")
	}
	type Plain GetFinancialAssessment
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetFinancialAssessment(plain)
	return nil
}

var enumValues_TradingPlatformInvestorPasswordResetRespTradingPlatformPasswordReset = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingPlatformInvestorPasswordResetRespTradingPlatformPasswordReset) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TradingPlatformInvestorPasswordResetRespTradingPlatformPasswordReset {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TradingPlatformInvestorPasswordResetRespTradingPlatformPasswordReset, v)
	}
	*j = TradingPlatformInvestorPasswordResetRespTradingPlatformPasswordReset(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetFinancialAssessmentGetFinancialAssessment) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GetFinancialAssessmentGetFinancialAssessment {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GetFinancialAssessmentGetFinancialAssessment, v)
	}
	*j = GetFinancialAssessmentGetFinancialAssessment(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingPlatformInvestorPasswordResetResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain TradingPlatformInvestorPasswordResetResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TradingPlatformInvestorPasswordResetResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetAccountStatusResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain GetAccountStatusResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetAccountStatusResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetAccountStatusRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GetAccountStatusRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GetAccountStatusRespMsgType, v)
	}
	*j = GetAccountStatusRespMsgType(v)
	return nil
}

var enumValues_TradingPlatformPasswordResetPlatform = []interface{}{
	"dxtrade",
	"mt5",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingPlatformPasswordResetPlatform) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TradingPlatformPasswordResetPlatform {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TradingPlatformPasswordResetPlatform, v)
	}
	*j = TradingPlatformPasswordResetPlatform(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetAccountStatusRespGetAccountStatus) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["currency_config"]; !ok || v == nil {
		return fmt.Errorf("field currency_config: required")
	}
	if v, ok := raw["p2p_status"]; !ok || v == nil {
		return fmt.Errorf("field p2p_status: required")
	}
	if v, ok := raw["prompt_client_to_authenticate"]; !ok || v == nil {
		return fmt.Errorf("field prompt_client_to_authenticate: required")
	}
	if v, ok := raw["risk_classification"]; !ok || v == nil {
		return fmt.Errorf("field risk_classification: required")
	}
	if v, ok := raw["status"]; !ok || v == nil {
		return fmt.Errorf("field status: required")
	}
	type Plain GetAccountStatusRespGetAccountStatus
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetAccountStatusRespGetAccountStatus(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetAccountStatusRespGetAccountStatusSocialIdentityProvider) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GetAccountStatusRespGetAccountStatusSocialIdentityProvider {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GetAccountStatusRespGetAccountStatusSocialIdentityProvider, v)
	}
	*j = GetAccountStatusRespGetAccountStatusSocialIdentityProvider(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetAccountStatusRespGetAccountStatusPromptClientToAuthenticate) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GetAccountStatusRespGetAccountStatusPromptClientToAuthenticate {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GetAccountStatusRespGetAccountStatusPromptClientToAuthenticate, v)
	}
	*j = GetAccountStatusRespGetAccountStatusPromptClientToAuthenticate(v)
	return nil
}

var enumValues_TradingPlatformPasswordResetTradingPlatformPasswordReset = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingPlatformPasswordResetTradingPlatformPasswordReset) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TradingPlatformPasswordResetTradingPlatformPasswordReset {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TradingPlatformPasswordResetTradingPlatformPasswordReset, v)
	}
	*j = TradingPlatformPasswordResetTradingPlatformPasswordReset(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetAccountStatusRespGetAccountStatusP2PStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GetAccountStatusRespGetAccountStatusP2PStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GetAccountStatusRespGetAccountStatusP2PStatus, v)
	}
	*j = GetAccountStatusRespGetAccountStatusP2PStatus(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingPlatformPasswordReset) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["new_password"]; !ok || v == nil {
		return fmt.Errorf("field new_password: required")
	}
	if v, ok := raw["platform"]; !ok || v == nil {
		return fmt.Errorf("field platform: required")
	}
	if v, ok := raw["trading_platform_password_reset"]; !ok || v == nil {
		return fmt.Errorf("field trading_platform_password_reset: required")
	}
	if v, ok := raw["verification_code"]; !ok || v == nil {
		return fmt.Errorf("field verification_code: required")
	}
	type Plain TradingPlatformPasswordReset
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TradingPlatformPasswordReset(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetAccountStatusRespGetAccountStatusAuthentication) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["needs_verification"]; !ok || v == nil {
		return fmt.Errorf("field needs_verification: required")
	}
	type Plain GetAccountStatusRespGetAccountStatusAuthentication
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetAccountStatusRespGetAccountStatusAuthentication(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetAccountStatusRespGetAccountStatusAuthenticationOwnershipStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GetAccountStatusRespGetAccountStatusAuthenticationOwnershipStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GetAccountStatusRespGetAccountStatusAuthenticationOwnershipStatus, v)
	}
	*j = GetAccountStatusRespGetAccountStatusAuthenticationOwnershipStatus(v)
	return nil
}

var enumValues_TradingPlatformPasswordResetRespMsgType = []interface{}{
	"trading_platform_password_reset",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingPlatformPasswordResetRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TradingPlatformPasswordResetRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TradingPlatformPasswordResetRespMsgType, v)
	}
	*j = TradingPlatformPasswordResetRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetAccountStatusRespGetAccountStatusAuthenticationIncomeStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GetAccountStatusRespGetAccountStatusAuthenticationIncomeStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GetAccountStatusRespGetAccountStatusAuthenticationIncomeStatus, v)
	}
	*j = GetAccountStatusRespGetAccountStatusAuthenticationIncomeStatus(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetAccountStatusRespGetAccountStatusAuthenticationIdentityStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GetAccountStatusRespGetAccountStatusAuthenticationIdentityStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GetAccountStatusRespGetAccountStatusAuthenticationIdentityStatus, v)
	}
	*j = GetAccountStatusRespGetAccountStatusAuthenticationIdentityStatus(v)
	return nil
}

var enumValues_TradingPlatformPasswordResetRespTradingPlatformPasswordReset = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingPlatformPasswordResetRespTradingPlatformPasswordReset) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TradingPlatformPasswordResetRespTradingPlatformPasswordReset {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TradingPlatformPasswordResetRespTradingPlatformPasswordReset, v)
	}
	*j = TradingPlatformPasswordResetRespTradingPlatformPasswordReset(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesOnfidoStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesOnfidoStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesOnfidoStatus, v)
	}
	*j = GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesOnfidoStatus(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingPlatformPasswordResetResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain TradingPlatformPasswordResetResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TradingPlatformPasswordResetResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesOnfidoIsCountrySupported) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesOnfidoIsCountrySupported {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesOnfidoIsCountrySupported, v)
	}
	*j = GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesOnfidoIsCountrySupported(v)
	return nil
}

var enumValues_TradingServersAccountType = []interface{}{
	"demo",
	"real",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingServersAccountType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TradingServersAccountType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TradingServersAccountType, v)
	}
	*j = TradingServersAccountType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesManualStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesManualStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesManualStatus, v)
	}
	*j = GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesManualStatus(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesIdvStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesIdvStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesIdvStatus, v)
	}
	*j = GetAccountStatusRespGetAccountStatusAuthenticationIdentityServicesIdvStatus(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetAccountStatusRespGetAccountStatusAuthenticationDocumentStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GetAccountStatusRespGetAccountStatusAuthenticationDocumentStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GetAccountStatusRespGetAccountStatusAuthenticationDocumentStatus, v)
	}
	*j = GetAccountStatusRespGetAccountStatusAuthenticationDocumentStatus(v)
	return nil
}

var enumValues_TradingServersEnvironment = []interface{}{
	"all",
	"Deriv-Demo",
	"Deriv-Server",
	"Deriv-Server-02",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingServersEnvironment) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TradingServersEnvironment {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TradingServersEnvironment, v)
	}
	*j = TradingServersEnvironment(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetAccountStatusRespGetAccountStatusAuthenticationAttemptsHistoryElemStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GetAccountStatusRespGetAccountStatusAuthenticationAttemptsHistoryElemStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GetAccountStatusRespGetAccountStatusAuthenticationAttemptsHistoryElemStatus, v)
	}
	*j = GetAccountStatusRespGetAccountStatusAuthenticationAttemptsHistoryElemStatus(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetAccountStatus) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["get_account_status"]; !ok || v == nil {
		return fmt.Errorf("field get_account_status: required")
	}
	type Plain GetAccountStatus
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetAccountStatus(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetAccountStatusGetAccountStatus) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GetAccountStatusGetAccountStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GetAccountStatusGetAccountStatus, v)
	}
	*j = GetAccountStatusGetAccountStatus(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ForgetResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain ForgetResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ForgetResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ForgetRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ForgetRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ForgetRespMsgType, v)
	}
	*j = ForgetRespMsgType(v)
	return nil
}

var enumValues_TradingServersMarketType = []interface{}{
	"financial",
	"synthetic",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingServersMarketType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TradingServersMarketType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TradingServersMarketType, v)
	}
	*j = TradingServersMarketType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ForgetRespForget) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ForgetRespForget {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ForgetRespForget, v)
	}
	*j = ForgetRespForget(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ForgetAllResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain ForgetAllResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ForgetAllResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ForgetAllRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ForgetAllRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ForgetAllRespMsgType, v)
	}
	*j = ForgetAllRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ForgetAll) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["forget_all"]; !ok || v == nil {
		return fmt.Errorf("field forget_all: required")
	}
	type Plain ForgetAll
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ForgetAll(plain)
	return nil
}

var enumValues_TradingServersPlatform = []interface{}{
	"mt5",
	"dxtrade",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingServersPlatform) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TradingServersPlatform {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TradingServersPlatform, v)
	}
	*j = TradingServersPlatform(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StreamTypes) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_StreamTypes {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_StreamTypes, v)
	}
	*j = StreamTypes(v)
	return nil
}

var enumValues_StreamTypes = []interface{}{
	"balance",
	"candles",
	"cashier_payments",
	"p2p_advert",
	"p2p_advertiser",
	"p2p_order",
	"proposal",
	"proposal_open_contract",
	"ticks",
	"transaction",
	"trading_platform_asset_listing",
	"website_status",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Forget) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["forget"]; !ok || v == nil {
		return fmt.Errorf("field forget: required")
	}
	type Plain Forget
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Forget(plain)
	return nil
}

var enumValues_TradingServersTradingServers = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingServersTradingServers) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TradingServersTradingServers {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TradingServersTradingServers, v)
	}
	*j = TradingServersTradingServers(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExchangeRatesResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain ExchangeRatesResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ExchangeRatesResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingServers) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["trading_servers"]; !ok || v == nil {
		return fmt.Errorf("field trading_servers: required")
	}
	type Plain TradingServers
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["environment"]; !ok || v == nil {
		plain.Environment = "all"
	}
	if v, ok := raw["market_type"]; !ok || v == nil {
		plain.MarketType = "synthetic"
	}
	if v, ok := raw["platform"]; !ok || v == nil {
		plain.Platform = "mt5"
	}
	*j = TradingServers(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExchangeRatesRespSubscription) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	type Plain ExchangeRatesRespSubscription
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ExchangeRatesRespSubscription(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExchangeRatesRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ExchangeRatesRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ExchangeRatesRespMsgType, v)
	}
	*j = ExchangeRatesRespMsgType(v)
	return nil
}

var enumValues_TradingServersRespMsgType = []interface{}{
	"trading_servers",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingServersRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TradingServersRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TradingServersRespMsgType, v)
	}
	*j = TradingServersRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExchangeRates) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["base_currency"]; !ok || v == nil {
		return fmt.Errorf("field base_currency: required")
	}
	if v, ok := raw["exchange_rates"]; !ok || v == nil {
		return fmt.Errorf("field exchange_rates: required")
	}
	type Plain ExchangeRates
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ExchangeRates(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExchangeRatesSubscribe) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ExchangeRatesSubscribe {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ExchangeRatesSubscribe, v)
	}
	*j = ExchangeRatesSubscribe(v)
	return nil
}

var enumValues_TradingServersRespTradingServersElemAccountType = []interface{}{
	"demo",
	"real",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingServersRespTradingServersElemAccountType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TradingServersRespTradingServersElemAccountType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TradingServersRespTradingServersElemAccountType, v)
	}
	*j = TradingServersRespTradingServersElemAccountType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExchangeRatesExchangeRates) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ExchangeRatesExchangeRates {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ExchangeRatesExchangeRates, v)
	}
	*j = ExchangeRatesExchangeRates(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EconomicCalendarResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain EconomicCalendarResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = EconomicCalendarResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EconomicCalendarRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EconomicCalendarRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EconomicCalendarRespMsgType, v)
	}
	*j = EconomicCalendarRespMsgType(v)
	return nil
}

var enumValues_TradingServersRespTradingServersElemDisabled = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingServersRespTradingServersElemDisabled) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TradingServersRespTradingServersElemDisabled {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TradingServersRespTradingServersElemDisabled, v)
	}
	*j = TradingServersRespTradingServersElemDisabled(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EconomicCalendar) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["economic_calendar"]; !ok || v == nil {
		return fmt.Errorf("field economic_calendar: required")
	}
	type Plain EconomicCalendar
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = EconomicCalendar(plain)
	return nil
}

var enumValues_TradingServersRespTradingServersElemEnvironment = []interface{}{
	"Deriv-Demo",
	"Deriv-Server",
	"Deriv-Server-02",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingServersRespTradingServersElemEnvironment) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TradingServersRespTradingServersElemEnvironment {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TradingServersRespTradingServersElemEnvironment, v)
	}
	*j = TradingServersRespTradingServersElemEnvironment(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EconomicCalendarEconomicCalendar) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EconomicCalendarEconomicCalendar {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EconomicCalendarEconomicCalendar, v)
	}
	*j = EconomicCalendarEconomicCalendar(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DocumentUploadResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain DocumentUploadResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DocumentUploadResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DocumentUploadRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DocumentUploadRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DocumentUploadRespMsgType, v)
	}
	*j = DocumentUploadRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DocumentUploadRespDocumentUpload) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["call_type"]; !ok || v == nil {
		return fmt.Errorf("field call_type: required")
	}
	if v, ok := raw["upload_id"]; !ok || v == nil {
		return fmt.Errorf("field upload_id: required")
	}
	type Plain DocumentUploadRespDocumentUpload
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DocumentUploadRespDocumentUpload(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DocumentUpload) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["document_format"]; !ok || v == nil {
		return fmt.Errorf("field document_format: required")
	}
	if v, ok := raw["document_type"]; !ok || v == nil {
		return fmt.Errorf("field document_type: required")
	}
	if v, ok := raw["document_upload"]; !ok || v == nil {
		return fmt.Errorf("field document_upload: required")
	}
	if v, ok := raw["expected_checksum"]; !ok || v == nil {
		return fmt.Errorf("field expected_checksum: required")
	}
	if v, ok := raw["file_size"]; !ok || v == nil {
		return fmt.Errorf("field file_size: required")
	}
	type Plain DocumentUpload
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DocumentUpload(plain)
	return nil
}

var enumValues_TradingServersRespTradingServersElemId = []interface{}{
	"p01_ts01",
	"p01_ts02",
	"p01_ts03",
	"p01_ts04",
	"p02_ts02",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingServersRespTradingServersElemId) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TradingServersRespTradingServersElemId {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TradingServersRespTradingServersElemId, v)
	}
	*j = TradingServersRespTradingServersElemId(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DocumentUploadProofOfOwnership) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["details"]; !ok || v == nil {
		return fmt.Errorf("field details: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	type Plain DocumentUploadProofOfOwnership
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DocumentUploadProofOfOwnership(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DocumentUploadPageType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DocumentUploadPageType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DocumentUploadPageType, v)
	}
	*j = DocumentUploadPageType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DocumentUploadLifetimeValid) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DocumentUploadLifetimeValid {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DocumentUploadLifetimeValid, v)
	}
	*j = DocumentUploadLifetimeValid(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DocumentUploadDocumentUpload) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DocumentUploadDocumentUpload {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DocumentUploadDocumentUpload, v)
	}
	*j = DocumentUploadDocumentUpload(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DocumentUploadDocumentType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DocumentUploadDocumentType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DocumentUploadDocumentType, v)
	}
	*j = DocumentUploadDocumentType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DocumentUploadDocumentFormat) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DocumentUploadDocumentFormat {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DocumentUploadDocumentFormat, v)
	}
	*j = DocumentUploadDocumentFormat(v)
	return nil
}

var enumValues_TradingServersRespTradingServersElemRecommended = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingServersRespTradingServersElemRecommended) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TradingServersRespTradingServersElemRecommended {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TradingServersRespTradingServersElemRecommended, v)
	}
	*j = TradingServersRespTradingServersElemRecommended(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CryptoConfigResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain CryptoConfigResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CryptoConfigResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CryptoConfigRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CryptoConfigRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CryptoConfigRespMsgType, v)
	}
	*j = CryptoConfigRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingServersResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain TradingServersResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TradingServersResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CryptoConfigRespCryptoConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["currencies_config"]; !ok || v == nil {
		return fmt.Errorf("field currencies_config: required")
	}
	type Plain CryptoConfigRespCryptoConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CryptoConfigRespCryptoConfig(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CryptoConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["crypto_config"]; !ok || v == nil {
		return fmt.Errorf("field crypto_config: required")
	}
	type Plain CryptoConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CryptoConfig(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingTimes) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["trading_times"]; !ok || v == nil {
		return fmt.Errorf("field trading_times: required")
	}
	type Plain TradingTimes
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TradingTimes(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CryptoConfigCryptoConfig) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CryptoConfigCryptoConfig {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CryptoConfigCryptoConfig, v)
	}
	*j = CryptoConfigCryptoConfig(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CopytradingStatisticsResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain CopytradingStatisticsResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CopytradingStatisticsResp(plain)
	return nil
}

var enumValues_TradingTimesRespMsgType = []interface{}{
	"trading_times",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingTimesRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TradingTimesRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TradingTimesRespMsgType, v)
	}
	*j = TradingTimesRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CopytradingStatisticsRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CopytradingStatisticsRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CopytradingStatisticsRespMsgType, v)
	}
	*j = CopytradingStatisticsRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CopytradingStatisticsRespCopytradingStatistics) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["active_since"]; !ok || v == nil {
		return fmt.Errorf("field active_since: required")
	}
	if v, ok := raw["avg_duration"]; !ok || v == nil {
		return fmt.Errorf("field avg_duration: required")
	}
	if v, ok := raw["avg_loss"]; !ok || v == nil {
		return fmt.Errorf("field avg_loss: required")
	}
	if v, ok := raw["avg_profit"]; !ok || v == nil {
		return fmt.Errorf("field avg_profit: required")
	}
	if v, ok := raw["copiers"]; !ok || v == nil {
		return fmt.Errorf("field copiers: required")
	}
	if v, ok := raw["last_12months_profitable_trades"]; !ok || v == nil {
		return fmt.Errorf("field last_12months_profitable_trades: required")
	}
	if v, ok := raw["monthly_profitable_trades"]; !ok || v == nil {
		return fmt.Errorf("field monthly_profitable_trades: required")
	}
	if v, ok := raw["performance_probability"]; !ok || v == nil {
		return fmt.Errorf("field performance_probability: required")
	}
	if v, ok := raw["total_trades"]; !ok || v == nil {
		return fmt.Errorf("field total_trades: required")
	}
	if v, ok := raw["trades_breakdown"]; !ok || v == nil {
		return fmt.Errorf("field trades_breakdown: required")
	}
	if v, ok := raw["trades_profitable"]; !ok || v == nil {
		return fmt.Errorf("field trades_profitable: required")
	}
	type Plain CopytradingStatisticsRespCopytradingStatistics
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CopytradingStatisticsRespCopytradingStatistics(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CopytradingStatistics) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["copytrading_statistics"]; !ok || v == nil {
		return fmt.Errorf("field copytrading_statistics: required")
	}
	if v, ok := raw["trader_id"]; !ok || v == nil {
		return fmt.Errorf("field trader_id: required")
	}
	type Plain CopytradingStatistics
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CopytradingStatistics(plain)
	return nil
}

var enumValues_TradingTimesRespTradingTimesMarketsElemSubmarketsElemSymbolsElemTradingDaysElem = []interface{}{
	"Sun",
	"Mon",
	"Tue",
	"Wed",
	"Thu",
	"Fri",
	"Sat",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingTimesRespTradingTimesMarketsElemSubmarketsElemSymbolsElemTradingDaysElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TradingTimesRespTradingTimesMarketsElemSubmarketsElemSymbolsElemTradingDaysElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TradingTimesRespTradingTimesMarketsElemSubmarketsElemSymbolsElemTradingDaysElem, v)
	}
	*j = TradingTimesRespTradingTimesMarketsElemSubmarketsElemSymbolsElemTradingDaysElem(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CopytradingStatisticsCopytradingStatistics) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CopytradingStatisticsCopytradingStatistics {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CopytradingStatisticsCopytradingStatistics, v)
	}
	*j = CopytradingStatisticsCopytradingStatistics(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CopytradingListResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain CopytradingListResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CopytradingListResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CopytradingListRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CopytradingListRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CopytradingListRespMsgType, v)
	}
	*j = CopytradingListRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CopytradingListRespCopytradingList) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["copiers"]; !ok || v == nil {
		return fmt.Errorf("field copiers: required")
	}
	if v, ok := raw["traders"]; !ok || v == nil {
		return fmt.Errorf("field traders: required")
	}
	type Plain CopytradingListRespCopytradingList
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CopytradingListRespCopytradingList(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CopytradingListRespCopytradingListCopiersElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["loginid"]; !ok || v == nil {
		return fmt.Errorf("field loginid: required")
	}
	type Plain CopytradingListRespCopytradingListCopiersElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CopytradingListRespCopytradingListCopiersElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CopytradingList) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["copytrading_list"]; !ok || v == nil {
		return fmt.Errorf("field copytrading_list: required")
	}
	type Plain CopytradingList
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CopytradingList(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CopytradingListCopytradingList) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CopytradingListCopytradingList {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CopytradingListCopytradingList, v)
	}
	*j = CopytradingListCopytradingList(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CopyStopResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain CopyStopResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CopyStopResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingTimesRespTradingTimesMarketsElemSubmarketsElemSymbolsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["symbol"]; !ok || v == nil {
		return fmt.Errorf("field symbol: required")
	}
	type Plain TradingTimesRespTradingTimesMarketsElemSubmarketsElemSymbolsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TradingTimesRespTradingTimesMarketsElemSubmarketsElemSymbolsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CopyStopRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CopyStopRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CopyStopRespMsgType, v)
	}
	*j = CopyStopRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingTimesRespTradingTimesMarketsElemSubmarketsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain TradingTimesRespTradingTimesMarketsElemSubmarketsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TradingTimesRespTradingTimesMarketsElemSubmarketsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CopyStop) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["copy_stop"]; !ok || v == nil {
		return fmt.Errorf("field copy_stop: required")
	}
	type Plain CopyStop
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CopyStop(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingTimesRespTradingTimesMarketsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain TradingTimesRespTradingTimesMarketsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TradingTimesRespTradingTimesMarketsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CopyStartResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain CopyStartResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CopyStartResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingTimesRespTradingTimes) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["markets"]; !ok || v == nil {
		return fmt.Errorf("field markets: required")
	}
	type Plain TradingTimesRespTradingTimes
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TradingTimesRespTradingTimes(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CopyStartRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CopyStartRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CopyStartRespMsgType, v)
	}
	*j = CopyStartRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TradingTimesResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain TradingTimesResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TradingTimesResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CopyStart) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["copy_start"]; !ok || v == nil {
		return fmt.Errorf("field copy_start: required")
	}
	type Plain CopyStart
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CopyStart(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractsForResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain ContractsForResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ContractsForResp(plain)
	return nil
}

var enumValues_TransactionSubscribe = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransactionSubscribe) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TransactionSubscribe {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TransactionSubscribe, v)
	}
	*j = TransactionSubscribe(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractsForRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ContractsForRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ContractsForRespMsgType, v)
	}
	*j = ContractsForRespMsgType(v)
	return nil
}

var enumValues_TransactionTransaction = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransactionTransaction) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TransactionTransaction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TransactionTransaction, v)
	}
	*j = TransactionTransaction(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractsForRespContractsFor) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["available"]; !ok || v == nil {
		return fmt.Errorf("field available: required")
	}
	type Plain ContractsForRespContractsFor
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ContractsForRespContractsFor(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Transaction) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["subscribe"]; !ok || v == nil {
		return fmt.Errorf("field subscribe: required")
	}
	if v, ok := raw["transaction"]; !ok || v == nil {
		return fmt.Errorf("field transaction: required")
	}
	type Plain Transaction
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Transaction(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractsForRespContractsForAvailableElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["barrier_category"]; !ok || v == nil {
		return fmt.Errorf("field barrier_category: required")
	}
	if v, ok := raw["barriers"]; !ok || v == nil {
		return fmt.Errorf("field barriers: required")
	}
	if v, ok := raw["contract_category"]; !ok || v == nil {
		return fmt.Errorf("field contract_category: required")
	}
	if v, ok := raw["contract_category_display"]; !ok || v == nil {
		return fmt.Errorf("field contract_category_display: required")
	}
	if v, ok := raw["contract_type"]; !ok || v == nil {
		return fmt.Errorf("field contract_type: required")
	}
	if v, ok := raw["exchange_name"]; !ok || v == nil {
		return fmt.Errorf("field exchange_name: required")
	}
	if v, ok := raw["expiry_type"]; !ok || v == nil {
		return fmt.Errorf("field expiry_type: required")
	}
	if v, ok := raw["market"]; !ok || v == nil {
		return fmt.Errorf("field market: required")
	}
	if v, ok := raw["max_contract_duration"]; !ok || v == nil {
		return fmt.Errorf("field max_contract_duration: required")
	}
	if v, ok := raw["min_contract_duration"]; !ok || v == nil {
		return fmt.Errorf("field min_contract_duration: required")
	}
	if v, ok := raw["sentiment"]; !ok || v == nil {
		return fmt.Errorf("field sentiment: required")
	}
	if v, ok := raw["start_type"]; !ok || v == nil {
		return fmt.Errorf("field start_type: required")
	}
	if v, ok := raw["submarket"]; !ok || v == nil {
		return fmt.Errorf("field submarket: required")
	}
	if v, ok := raw["underlying_symbol"]; !ok || v == nil {
		return fmt.Errorf("field underlying_symbol: required")
	}
	type Plain ContractsForRespContractsForAvailableElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ContractsForRespContractsForAvailableElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractsFor) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["contracts_for"]; !ok || v == nil {
		return fmt.Errorf("field contracts_for: required")
	}
	type Plain ContractsFor
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["currency"]; !ok || v == nil {
		plain.Currency = "USD"
	}
	if v, ok := raw["landing_company"]; !ok || v == nil {
		plain.LandingCompany = "virtual"
	}
	if v, ok := raw["landing_company_short"]; !ok || v == nil {
		plain.LandingCompanyShort = "virtual"
	}
	*j = ContractsFor(plain)
	return nil
}

var enumValues_TransactionRespMsgType = []interface{}{
	"transaction",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransactionRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TransactionRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TransactionRespMsgType, v)
	}
	*j = TransactionRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractsForProductType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ContractsForProductType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ContractsForProductType, v)
	}
	*j = ContractsForProductType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractsForLandingCompanyShort) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ContractsForLandingCompanyShort {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ContractsForLandingCompanyShort, v)
	}
	*j = ContractsForLandingCompanyShort(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransactionRespSubscription) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	type Plain TransactionRespSubscription
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TransactionRespSubscription(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractsForLandingCompany) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ContractsForLandingCompany {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ContractsForLandingCompany, v)
	}
	*j = ContractsForLandingCompany(v)
	return nil
}

var enumValues_TransactionRespTransactionAction = []interface{}{
	"buy",
	"sell",
	"deposit",
	"withdrawal",
	"escrow",
	"adjustment",
	"virtual_credit",
	"transfer",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransactionRespTransactionAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TransactionRespTransactionAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TransactionRespTransactionAction, v)
	}
	*j = TransactionRespTransactionAction(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractUpdateResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain ContractUpdateResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ContractUpdateResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractUpdateRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ContractUpdateRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ContractUpdateRespMsgType, v)
	}
	*j = ContractUpdateRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractUpdateHistoryResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain ContractUpdateHistoryResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ContractUpdateHistoryResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractUpdateHistoryRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ContractUpdateHistoryRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ContractUpdateHistoryRespMsgType, v)
	}
	*j = ContractUpdateHistoryRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractUpdateHistory) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["contract_id"]; !ok || v == nil {
		return fmt.Errorf("field contract_id: required")
	}
	if v, ok := raw["contract_update_history"]; !ok || v == nil {
		return fmt.Errorf("field contract_update_history: required")
	}
	type Plain ContractUpdateHistory
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["limit"]; !ok || v == nil {
		plain.Limit = 500
	}
	*j = ContractUpdateHistory(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractUpdateHistoryContractUpdateHistory) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ContractUpdateHistoryContractUpdateHistory {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ContractUpdateHistoryContractUpdateHistory, v)
	}
	*j = ContractUpdateHistoryContractUpdateHistory(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractUpdate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["contract_id"]; !ok || v == nil {
		return fmt.Errorf("field contract_id: required")
	}
	if v, ok := raw["contract_update"]; !ok || v == nil {
		return fmt.Errorf("field contract_update: required")
	}
	if v, ok := raw["limit_order"]; !ok || v == nil {
		return fmt.Errorf("field limit_order: required")
	}
	type Plain ContractUpdate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ContractUpdate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractUpdateContractUpdate) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ContractUpdateContractUpdate {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ContractUpdateContractUpdate, v)
	}
	*j = ContractUpdateContractUpdate(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CashierResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain CashierResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CashierResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CashierRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CashierRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CashierRespMsgType, v)
	}
	*j = CashierRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransactionResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain TransactionResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TransactionResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Cashier) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Cashier
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["cashier"]; !ok || v == nil {
		plain.Cashier = "deposit"
	}
	if v, ok := raw["dry_run"]; !ok || v == nil {
		plain.DryRun = 0
	}
	if v, ok := raw["provider"]; !ok || v == nil {
		plain.Provider = "doughflow"
	}
	if v, ok := raw["type"]; !ok || v == nil {
		plain.Type = "url"
	}
	*j = Cashier(plain)
	return nil
}

var enumValues_TransferBetweenAccountsAccounts = []interface{}{
	"all",
	"brief",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransferBetweenAccountsAccounts) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TransferBetweenAccountsAccounts {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TransferBetweenAccountsAccounts, v)
	}
	*j = TransferBetweenAccountsAccounts(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CashierType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CashierType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CashierType, v)
	}
	*j = CashierType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CashierProvider) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CashierProvider {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CashierProvider, v)
	}
	*j = CashierProvider(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CashierDryRun) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CashierDryRun {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CashierDryRun, v)
	}
	*j = CashierDryRun(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CashierCashier) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CashierCashier {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CashierCashier, v)
	}
	*j = CashierCashier(v)
	return nil
}

var enumValues_TransferBetweenAccountsTransferBetweenAccounts = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransferBetweenAccountsTransferBetweenAccounts) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TransferBetweenAccountsTransferBetweenAccounts {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TransferBetweenAccountsTransferBetweenAccounts, v)
	}
	*j = TransferBetweenAccountsTransferBetweenAccounts(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CancelResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain CancelResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CancelResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransferBetweenAccounts) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["transfer_between_accounts"]; !ok || v == nil {
		return fmt.Errorf("field transfer_between_accounts: required")
	}
	type Plain TransferBetweenAccounts
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["accounts"]; !ok || v == nil {
		plain.Accounts = "brief"
	}
	*j = TransferBetweenAccounts(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CancelRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_CancelRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_CancelRespMsgType, v)
	}
	*j = CancelRespMsgType(v)
	return nil
}

var enumValues_TransferBetweenAccountsRespAccountsElemAccountType = []interface{}{
	"trading",
	"mt5",
	"wallet",
	"dxtrade",
	"derivez",
	"binary",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransferBetweenAccountsRespAccountsElemAccountType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TransferBetweenAccountsRespAccountsElemAccountType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TransferBetweenAccountsRespAccountsElemAccountType, v)
	}
	*j = TransferBetweenAccountsRespAccountsElemAccountType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Cancel) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["cancel"]; !ok || v == nil {
		return fmt.Errorf("field cancel: required")
	}
	type Plain Cancel
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Cancel(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuyResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain BuyResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BuyResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuyRespSubscription) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	type Plain BuyRespSubscription
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BuyRespSubscription(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuyRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BuyRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BuyRespMsgType, v)
	}
	*j = BuyRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuyRespBuy) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["balance_after"]; !ok || v == nil {
		return fmt.Errorf("field balance_after: required")
	}
	if v, ok := raw["buy_price"]; !ok || v == nil {
		return fmt.Errorf("field buy_price: required")
	}
	if v, ok := raw["contract_id"]; !ok || v == nil {
		return fmt.Errorf("field contract_id: required")
	}
	if v, ok := raw["longcode"]; !ok || v == nil {
		return fmt.Errorf("field longcode: required")
	}
	if v, ok := raw["payout"]; !ok || v == nil {
		return fmt.Errorf("field payout: required")
	}
	if v, ok := raw["purchase_time"]; !ok || v == nil {
		return fmt.Errorf("field purchase_time: required")
	}
	if v, ok := raw["shortcode"]; !ok || v == nil {
		return fmt.Errorf("field shortcode: required")
	}
	if v, ok := raw["start_time"]; !ok || v == nil {
		return fmt.Errorf("field start_time: required")
	}
	if v, ok := raw["transaction_id"]; !ok || v == nil {
		return fmt.Errorf("field transaction_id: required")
	}
	type Plain BuyRespBuy
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BuyRespBuy(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuyContractForMultipleAccountsResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain BuyContractForMultipleAccountsResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BuyContractForMultipleAccountsResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuyContractForMultipleAccountsRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BuyContractForMultipleAccountsRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BuyContractForMultipleAccountsRespMsgType, v)
	}
	*j = BuyContractForMultipleAccountsRespMsgType(v)
	return nil
}

var enumValues_TransferBetweenAccountsRespAccountsElemDemoAccount = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransferBetweenAccountsRespAccountsElemDemoAccount) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TransferBetweenAccountsRespAccountsElemDemoAccount {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TransferBetweenAccountsRespAccountsElemDemoAccount, v)
	}
	*j = TransferBetweenAccountsRespAccountsElemDemoAccount(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuyContractForMultipleAccountsRespBuyContractForMultipleAccounts) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["result"]; !ok || v == nil {
		return fmt.Errorf("field result: required")
	}
	type Plain BuyContractForMultipleAccountsRespBuyContractForMultipleAccounts
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BuyContractForMultipleAccountsRespBuyContractForMultipleAccounts(plain)
	return nil
}

var enumValues_TransferBetweenAccountsRespAccountsElemMarketType = []interface{}{
	"financial",
	"synthetic",
	"all",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransferBetweenAccountsRespAccountsElemMarketType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TransferBetweenAccountsRespAccountsElemMarketType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TransferBetweenAccountsRespAccountsElemMarketType, v)
	}
	*j = TransferBetweenAccountsRespAccountsElemMarketType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuyContractForMultipleAccounts) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["buy_contract_for_multiple_accounts"]; !ok || v == nil {
		return fmt.Errorf("field buy_contract_for_multiple_accounts: required")
	}
	if v, ok := raw["price"]; !ok || v == nil {
		return fmt.Errorf("field price: required")
	}
	if v, ok := raw["tokens"]; !ok || v == nil {
		return fmt.Errorf("field tokens: required")
	}
	type Plain BuyContractForMultipleAccounts
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BuyContractForMultipleAccounts(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuyContractForMultipleAccountsParameters) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["contract_type"]; !ok || v == nil {
		return fmt.Errorf("field contract_type: required")
	}
	if v, ok := raw["currency"]; !ok || v == nil {
		return fmt.Errorf("field currency: required")
	}
	if v, ok := raw["symbol"]; !ok || v == nil {
		return fmt.Errorf("field symbol: required")
	}
	type Plain BuyContractForMultipleAccountsParameters
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BuyContractForMultipleAccountsParameters(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuyContractForMultipleAccountsParametersDurationUnit) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BuyContractForMultipleAccountsParametersDurationUnit {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BuyContractForMultipleAccountsParametersDurationUnit, v)
	}
	*j = BuyContractForMultipleAccountsParametersDurationUnit(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuyContractForMultipleAccountsParametersContractType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BuyContractForMultipleAccountsParametersContractType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BuyContractForMultipleAccountsParametersContractType, v)
	}
	*j = BuyContractForMultipleAccountsParametersContractType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuyContractForMultipleAccountsParametersBasis) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BuyContractForMultipleAccountsParametersBasis {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BuyContractForMultipleAccountsParametersBasis, v)
	}
	*j = BuyContractForMultipleAccountsParametersBasis(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Buy) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["buy"]; !ok || v == nil {
		return fmt.Errorf("field buy: required")
	}
	if v, ok := raw["price"]; !ok || v == nil {
		return fmt.Errorf("field price: required")
	}
	type Plain Buy
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Buy(plain)
	return nil
}

var enumValues_TransferBetweenAccountsRespMsgType = []interface{}{
	"transfer_between_accounts",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransferBetweenAccountsRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TransferBetweenAccountsRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TransferBetweenAccountsRespMsgType, v)
	}
	*j = TransferBetweenAccountsRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuySubscribe) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BuySubscribe {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BuySubscribe, v)
	}
	*j = BuySubscribe(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuyParameters) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["contract_type"]; !ok || v == nil {
		return fmt.Errorf("field contract_type: required")
	}
	if v, ok := raw["currency"]; !ok || v == nil {
		return fmt.Errorf("field currency: required")
	}
	if v, ok := raw["symbol"]; !ok || v == nil {
		return fmt.Errorf("field symbol: required")
	}
	type Plain BuyParameters
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["product_type"]; !ok || v == nil {
		plain.ProductType = "basic"
	}
	*j = BuyParameters(plain)
	return nil
}

var enumValues_TransferBetweenAccountsRespTransferBetweenAccounts = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransferBetweenAccountsRespTransferBetweenAccounts) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TransferBetweenAccountsRespTransferBetweenAccounts {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TransferBetweenAccountsRespTransferBetweenAccounts, v)
	}
	*j = TransferBetweenAccountsRespTransferBetweenAccounts(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuyParametersProductType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BuyParametersProductType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BuyParametersProductType, v)
	}
	*j = BuyParametersProductType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransferBetweenAccountsResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain TransferBetweenAccountsResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TransferBetweenAccountsResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuyParametersDurationUnit) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BuyParametersDurationUnit {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BuyParametersDurationUnit, v)
	}
	*j = BuyParametersDurationUnit(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuyParametersContractType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BuyParametersContractType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BuyParametersContractType, v)
	}
	*j = BuyParametersContractType(v)
	return nil
}

var enumValues_UnsubscribeEmailUnsubscribeEmail = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UnsubscribeEmailUnsubscribeEmail) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_UnsubscribeEmailUnsubscribeEmail {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_UnsubscribeEmailUnsubscribeEmail, v)
	}
	*j = UnsubscribeEmailUnsubscribeEmail(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuyParametersBasis) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BuyParametersBasis {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BuyParametersBasis, v)
	}
	*j = BuyParametersBasis(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UnsubscribeEmail) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["binary_user_id"]; !ok || v == nil {
		return fmt.Errorf("field binary_user_id: required")
	}
	if v, ok := raw["checksum"]; !ok || v == nil {
		return fmt.Errorf("field checksum: required")
	}
	if v, ok := raw["unsubscribe_email"]; !ok || v == nil {
		return fmt.Errorf("field unsubscribe_email: required")
	}
	type Plain UnsubscribeEmail
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UnsubscribeEmail(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BuyParametersBarrierRange) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BuyParametersBarrierRange {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BuyParametersBarrierRange, v)
	}
	*j = BuyParametersBarrierRange(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BalanceResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain BalanceResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BalanceResp(plain)
	return nil
}

var enumValues_UnsubscribeEmailRespEmailUnsubscribeStatus = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UnsubscribeEmailRespEmailUnsubscribeStatus) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_UnsubscribeEmailRespEmailUnsubscribeStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_UnsubscribeEmailRespEmailUnsubscribeStatus, v)
	}
	*j = UnsubscribeEmailRespEmailUnsubscribeStatus(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BalanceRespSubscription) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	type Plain BalanceRespSubscription
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BalanceRespSubscription(plain)
	return nil
}

var enumValues_UnsubscribeEmailRespMsgType = []interface{}{
	"unsubscribe_email",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UnsubscribeEmailRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_UnsubscribeEmailRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_UnsubscribeEmailRespMsgType, v)
	}
	*j = UnsubscribeEmailRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BalanceRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BalanceRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BalanceRespMsgType, v)
	}
	*j = BalanceRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BalanceRespBalance) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["balance"]; !ok || v == nil {
		return fmt.Errorf("field balance: required")
	}
	if v, ok := raw["currency"]; !ok || v == nil {
		return fmt.Errorf("field currency: required")
	}
	if v, ok := raw["loginid"]; !ok || v == nil {
		return fmt.Errorf("field loginid: required")
	}
	type Plain BalanceRespBalance
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BalanceRespBalance(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UnsubscribeEmailResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain UnsubscribeEmailResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = UnsubscribeEmailResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BalanceRespBalanceTotalMt5Demo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["currency"]; !ok || v == nil {
		return fmt.Errorf("field currency: required")
	}
	type Plain BalanceRespBalanceTotalMt5Demo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BalanceRespBalanceTotalMt5Demo(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BalanceRespBalanceTotalMt5) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["currency"]; !ok || v == nil {
		return fmt.Errorf("field currency: required")
	}
	type Plain BalanceRespBalanceTotalMt5
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BalanceRespBalanceTotalMt5(plain)
	return nil
}

var enumValues_VerifyEmailType = []interface{}{
	"partner_account_opening",
	"account_opening",
	"reset_password",
	"paymentagent_withdraw",
	"payment_withdraw",
	"trading_platform_password_reset",
	"trading_platform_dxtrade_password_reset",
	"trading_platform_mt5_password_reset",
	"trading_platform_investor_password_reset",
	"request_email",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VerifyEmailType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VerifyEmailType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VerifyEmailType, v)
	}
	*j = VerifyEmailType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BalanceRespBalanceTotalDerivDemo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["currency"]; !ok || v == nil {
		return fmt.Errorf("field currency: required")
	}
	type Plain BalanceRespBalanceTotalDerivDemo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BalanceRespBalanceTotalDerivDemo(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BalanceRespBalanceTotalDeriv) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount: required")
	}
	if v, ok := raw["currency"]; !ok || v == nil {
		return fmt.Errorf("field currency: required")
	}
	type Plain BalanceRespBalanceTotalDeriv
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BalanceRespBalanceTotalDeriv(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Balance) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["balance"]; !ok || v == nil {
		return fmt.Errorf("field balance: required")
	}
	type Plain Balance
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["account"]; !ok || v == nil {
		plain.Account = "current"
	}
	*j = Balance(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BalanceSubscribe) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BalanceSubscribe {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BalanceSubscribe, v)
	}
	*j = BalanceSubscribe(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BalanceBalance) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BalanceBalance {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BalanceBalance, v)
	}
	*j = BalanceBalance(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuthorizeResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain AuthorizeResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AuthorizeResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuthorizeRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AuthorizeRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AuthorizeRespMsgType, v)
	}
	*j = AuthorizeRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuthorizeRespAuthorizeLinkedToElemPlatform) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AuthorizeRespAuthorizeLinkedToElemPlatform {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AuthorizeRespAuthorizeLinkedToElemPlatform, v)
	}
	*j = AuthorizeRespAuthorizeLinkedToElemPlatform(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuthorizeRespAuthorizeIsVirtual) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AuthorizeRespAuthorizeIsVirtual {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AuthorizeRespAuthorizeIsVirtual, v)
	}
	*j = AuthorizeRespAuthorizeIsVirtual(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatform) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatform {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatform, v)
	}
	*j = AuthorizeRespAuthorizeAccountListElemLinkedToElemPlatform(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuthorizeRespAuthorizeAccountListElemIsVirtual) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AuthorizeRespAuthorizeAccountListElemIsVirtual {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AuthorizeRespAuthorizeAccountListElemIsVirtual, v)
	}
	*j = AuthorizeRespAuthorizeAccountListElemIsVirtual(v)
	return nil
}

var enumValues_VerifyEmailUrlParametersSignupDevice = []interface{}{
	"desktop",
	"mobile",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VerifyEmailUrlParametersSignupDevice) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VerifyEmailUrlParametersSignupDevice {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VerifyEmailUrlParametersSignupDevice, v)
	}
	*j = VerifyEmailUrlParametersSignupDevice(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuthorizeRespAuthorizeAccountListElemIsDisabled) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AuthorizeRespAuthorizeAccountListElemIsDisabled {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AuthorizeRespAuthorizeAccountListElemIsDisabled, v)
	}
	*j = AuthorizeRespAuthorizeAccountListElemIsDisabled(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuthorizeRespAuthorizeAccountListElemAccountCategory) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AuthorizeRespAuthorizeAccountListElemAccountCategory {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AuthorizeRespAuthorizeAccountListElemAccountCategory, v)
	}
	*j = AuthorizeRespAuthorizeAccountListElemAccountCategory(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Authorize) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["authorize"]; !ok || v == nil {
		return fmt.Errorf("field authorize: required")
	}
	type Plain Authorize
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["add_to_login_history"]; !ok || v == nil {
		plain.AddToLoginHistory = 0
	}
	*j = Authorize(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AuthorizeAddToLoginHistory) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AuthorizeAddToLoginHistory {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AuthorizeAddToLoginHistory, v)
	}
	*j = AuthorizeAddToLoginHistory(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VerifyEmail) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	if v, ok := raw["verify_email"]; !ok || v == nil {
		return fmt.Errorf("field verify_email: required")
	}
	type Plain VerifyEmail
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = VerifyEmail(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AssetIndexResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain AssetIndexResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AssetIndexResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AssetIndexRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AssetIndexRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AssetIndexRespMsgType, v)
	}
	*j = AssetIndexRespMsgType(v)
	return nil
}

var enumValues_VerifyEmailCellxpertType = []interface{}{
	"partner_account_opening",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VerifyEmailCellxpertType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VerifyEmailCellxpertType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VerifyEmailCellxpertType, v)
	}
	*j = VerifyEmailCellxpertType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AssetIndex) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["asset_index"]; !ok || v == nil {
		return fmt.Errorf("field asset_index: required")
	}
	type Plain AssetIndex
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AssetIndex(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AssetIndexLandingCompanyShort) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AssetIndexLandingCompanyShort {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AssetIndexLandingCompanyShort, v)
	}
	*j = AssetIndexLandingCompanyShort(v)
	return nil
}

var enumValues_VerifyEmailCellxpertUrlParametersSignupDevice = []interface{}{
	"desktop",
	"mobile",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VerifyEmailCellxpertUrlParametersSignupDevice) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VerifyEmailCellxpertUrlParametersSignupDevice {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VerifyEmailCellxpertUrlParametersSignupDevice, v)
	}
	*j = VerifyEmailCellxpertUrlParametersSignupDevice(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AssetIndexLandingCompany) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AssetIndexLandingCompany {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AssetIndexLandingCompany, v)
	}
	*j = AssetIndexLandingCompany(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AssetIndexAssetIndex) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AssetIndexAssetIndex {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AssetIndexAssetIndex, v)
	}
	*j = AssetIndexAssetIndex(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppUpdateResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain AppUpdateResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AppUpdateResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppUpdateRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AppUpdateRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AppUpdateRespMsgType, v)
	}
	*j = AppUpdateRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VerifyEmailCellxpert) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type: required")
	}
	if v, ok := raw["verify_email_cellxpert"]; !ok || v == nil {
		return fmt.Errorf("field verify_email_cellxpert: required")
	}
	type Plain VerifyEmailCellxpert
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = VerifyEmailCellxpert(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppUpdate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["app_update"]; !ok || v == nil {
		return fmt.Errorf("field app_update: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["scopes"]; !ok || v == nil {
		return fmt.Errorf("field scopes: required")
	}
	type Plain AppUpdate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AppUpdate(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppUpdateScopesElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AppUpdateScopesElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AppUpdateScopesElem, v)
	}
	*j = AppUpdateScopesElem(v)
	return nil
}

var enumValues_VerifyEmailCellxpertRespMsgType = []interface{}{
	"verify_email_cellxpert",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VerifyEmailCellxpertRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VerifyEmailCellxpertRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VerifyEmailCellxpertRespMsgType, v)
	}
	*j = VerifyEmailCellxpertRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppRegisterResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain AppRegisterResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AppRegisterResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppRegisterRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AppRegisterRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AppRegisterRespMsgType, v)
	}
	*j = AppRegisterRespMsgType(v)
	return nil
}

var enumValues_VerifyEmailCellxpertRespVerifyEmailCellxpert = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VerifyEmailCellxpertRespVerifyEmailCellxpert) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VerifyEmailCellxpertRespVerifyEmailCellxpert {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VerifyEmailCellxpertRespVerifyEmailCellxpert, v)
	}
	*j = VerifyEmailCellxpertRespVerifyEmailCellxpert(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppRegisterRespAppRegister) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["app_id"]; !ok || v == nil {
		return fmt.Errorf("field app_id: required")
	}
	if v, ok := raw["app_markup_percentage"]; !ok || v == nil {
		return fmt.Errorf("field app_markup_percentage: required")
	}
	if v, ok := raw["appstore"]; !ok || v == nil {
		return fmt.Errorf("field appstore: required")
	}
	if v, ok := raw["github"]; !ok || v == nil {
		return fmt.Errorf("field github: required")
	}
	if v, ok := raw["googleplay"]; !ok || v == nil {
		return fmt.Errorf("field googleplay: required")
	}
	if v, ok := raw["homepage"]; !ok || v == nil {
		return fmt.Errorf("field homepage: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["redirect_uri"]; !ok || v == nil {
		return fmt.Errorf("field redirect_uri: required")
	}
	if v, ok := raw["verification_uri"]; !ok || v == nil {
		return fmt.Errorf("field verification_uri: required")
	}
	type Plain AppRegisterRespAppRegister
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AppRegisterRespAppRegister(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VerifyEmailCellxpertResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain VerifyEmailCellxpertResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = VerifyEmailCellxpertResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppRegister) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["app_register"]; !ok || v == nil {
		return fmt.Errorf("field app_register: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["scopes"]; !ok || v == nil {
		return fmt.Errorf("field scopes: required")
	}
	type Plain AppRegister
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AppRegister(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppRegisterScopesElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AppRegisterScopesElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AppRegisterScopesElem, v)
	}
	*j = AppRegisterScopesElem(v)
	return nil
}

var enumValues_VerifyEmailRespMsgType = []interface{}{
	"verify_email",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VerifyEmailRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VerifyEmailRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VerifyEmailRespMsgType, v)
	}
	*j = VerifyEmailRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppRegisterAppRegister) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AppRegisterAppRegister {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AppRegisterAppRegister, v)
	}
	*j = AppRegisterAppRegister(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppMarkupStatisticsResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain AppMarkupStatisticsResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AppMarkupStatisticsResp(plain)
	return nil
}

var enumValues_VerifyEmailRespVerifyEmail = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VerifyEmailRespVerifyEmail) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VerifyEmailRespVerifyEmail {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VerifyEmailRespVerifyEmail, v)
	}
	*j = VerifyEmailRespVerifyEmail(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppMarkupStatisticsRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AppMarkupStatisticsRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AppMarkupStatisticsRespMsgType, v)
	}
	*j = AppMarkupStatisticsRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VerifyEmailResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain VerifyEmailResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = VerifyEmailResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppMarkupStatistics) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["app_markup_statistics"]; !ok || v == nil {
		return fmt.Errorf("field app_markup_statistics: required")
	}
	if v, ok := raw["date_from"]; !ok || v == nil {
		return fmt.Errorf("field date_from: required")
	}
	if v, ok := raw["date_to"]; !ok || v == nil {
		return fmt.Errorf("field date_to: required")
	}
	type Plain AppMarkupStatistics
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AppMarkupStatistics(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppMarkupStatisticsAppMarkupStatistics) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AppMarkupStatisticsAppMarkupStatistics {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AppMarkupStatisticsAppMarkupStatistics, v)
	}
	*j = AppMarkupStatisticsAppMarkupStatistics(v)
	return nil
}

var enumValues_WebsiteStatusSubscribe = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusSubscribe) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WebsiteStatusSubscribe {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WebsiteStatusSubscribe, v)
	}
	*j = WebsiteStatusSubscribe(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppMarkupDetailsResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain AppMarkupDetailsResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AppMarkupDetailsResp(plain)
	return nil
}

var enumValues_WebsiteStatusWebsiteStatus = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusWebsiteStatus) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WebsiteStatusWebsiteStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WebsiteStatusWebsiteStatus, v)
	}
	*j = WebsiteStatusWebsiteStatus(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppMarkupDetailsRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AppMarkupDetailsRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AppMarkupDetailsRespMsgType, v)
	}
	*j = AppMarkupDetailsRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatus) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["website_status"]; !ok || v == nil {
		return fmt.Errorf("field website_status: required")
	}
	type Plain WebsiteStatus
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = WebsiteStatus(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppMarkupDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["app_markup_details"]; !ok || v == nil {
		return fmt.Errorf("field app_markup_details: required")
	}
	if v, ok := raw["date_from"]; !ok || v == nil {
		return fmt.Errorf("field date_from: required")
	}
	if v, ok := raw["date_to"]; !ok || v == nil {
		return fmt.Errorf("field date_to: required")
	}
	type Plain AppMarkupDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["limit"]; !ok || v == nil {
		plain.Limit = 1000
	}
	if v, ok := raw["sort"]; !ok || v == nil {
		plain.Sort = "DESC"
	}
	*j = AppMarkupDetails(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppMarkupDetailsSortFieldsElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AppMarkupDetailsSortFieldsElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AppMarkupDetailsSortFieldsElem, v)
	}
	*j = AppMarkupDetailsSortFieldsElem(v)
	return nil
}

var enumValues_WebsiteStatusRespMsgType = []interface{}{
	"website_status",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WebsiteStatusRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WebsiteStatusRespMsgType, v)
	}
	*j = WebsiteStatusRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppMarkupDetailsSort) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AppMarkupDetailsSort {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AppMarkupDetailsSort, v)
	}
	*j = AppMarkupDetailsSort(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppMarkupDetailsDescription) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AppMarkupDetailsDescription {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AppMarkupDetailsDescription, v)
	}
	*j = AppMarkupDetailsDescription(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespSubscription) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	type Plain WebsiteStatusRespSubscription
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = WebsiteStatusRespSubscription(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppMarkupDetailsAppMarkupDetails) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AppMarkupDetailsAppMarkupDetails {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AppMarkupDetailsAppMarkupDetails, v)
	}
	*j = AppMarkupDetailsAppMarkupDetails(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusApiCallLimitsMaxProposalSubscription) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["applies_to"]; !ok || v == nil {
		return fmt.Errorf("field applies_to: required")
	}
	if v, ok := raw["max"]; !ok || v == nil {
		return fmt.Errorf("field max: required")
	}
	type Plain WebsiteStatusRespWebsiteStatusApiCallLimitsMaxProposalSubscription
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = WebsiteStatusRespWebsiteStatusApiCallLimitsMaxProposalSubscription(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppListResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain AppListResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AppListResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestesGeneral) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["applies_to"]; !ok || v == nil {
		return fmt.Errorf("field applies_to: required")
	}
	if v, ok := raw["hourly"]; !ok || v == nil {
		return fmt.Errorf("field hourly: required")
	}
	if v, ok := raw["minutely"]; !ok || v == nil {
		return fmt.Errorf("field minutely: required")
	}
	type Plain WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestesGeneral
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestesGeneral(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppListRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AppListRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AppListRespMsgType, v)
	}
	*j = AppListRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestsOutcome) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["applies_to"]; !ok || v == nil {
		return fmt.Errorf("field applies_to: required")
	}
	if v, ok := raw["hourly"]; !ok || v == nil {
		return fmt.Errorf("field hourly: required")
	}
	if v, ok := raw["minutely"]; !ok || v == nil {
		return fmt.Errorf("field minutely: required")
	}
	type Plain WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestsOutcome
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestsOutcome(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppListRespAppListElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["app_id"]; !ok || v == nil {
		return fmt.Errorf("field app_id: required")
	}
	if v, ok := raw["app_markup_percentage"]; !ok || v == nil {
		return fmt.Errorf("field app_markup_percentage: required")
	}
	if v, ok := raw["appstore"]; !ok || v == nil {
		return fmt.Errorf("field appstore: required")
	}
	if v, ok := raw["github"]; !ok || v == nil {
		return fmt.Errorf("field github: required")
	}
	if v, ok := raw["googleplay"]; !ok || v == nil {
		return fmt.Errorf("field googleplay: required")
	}
	if v, ok := raw["homepage"]; !ok || v == nil {
		return fmt.Errorf("field homepage: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["redirect_uri"]; !ok || v == nil {
		return fmt.Errorf("field redirect_uri: required")
	}
	if v, ok := raw["verification_uri"]; !ok || v == nil {
		return fmt.Errorf("field verification_uri: required")
	}
	type Plain AppListRespAppListElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AppListRespAppListElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestsPricing) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["applies_to"]; !ok || v == nil {
		return fmt.Errorf("field applies_to: required")
	}
	if v, ok := raw["hourly"]; !ok || v == nil {
		return fmt.Errorf("field hourly: required")
	}
	if v, ok := raw["minutely"]; !ok || v == nil {
		return fmt.Errorf("field minutely: required")
	}
	type Plain WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestsPricing
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = WebsiteStatusRespWebsiteStatusApiCallLimitsMaxRequestsPricing(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppList) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["app_list"]; !ok || v == nil {
		return fmt.Errorf("field app_list: required")
	}
	type Plain AppList
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AppList(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusApiCallLimits) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["max_proposal_subscription"]; !ok || v == nil {
		return fmt.Errorf("field max_proposal_subscription: required")
	}
	if v, ok := raw["max_requestes_general"]; !ok || v == nil {
		return fmt.Errorf("field max_requestes_general: required")
	}
	if v, ok := raw["max_requests_outcome"]; !ok || v == nil {
		return fmt.Errorf("field max_requests_outcome: required")
	}
	if v, ok := raw["max_requests_pricing"]; !ok || v == nil {
		return fmt.Errorf("field max_requests_pricing: required")
	}
	type Plain WebsiteStatusRespWebsiteStatusApiCallLimits
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = WebsiteStatusRespWebsiteStatusApiCallLimits(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppListAppList) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AppListAppList {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AppListAppList, v)
	}
	*j = AppListAppList(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppGetResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain AppGetResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AppGetResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppGetRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AppGetRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AppGetRespMsgType, v)
	}
	*j = AppGetRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppGetRespAppGet) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["app_id"]; !ok || v == nil {
		return fmt.Errorf("field app_id: required")
	}
	if v, ok := raw["app_markup_percentage"]; !ok || v == nil {
		return fmt.Errorf("field app_markup_percentage: required")
	}
	if v, ok := raw["appstore"]; !ok || v == nil {
		return fmt.Errorf("field appstore: required")
	}
	if v, ok := raw["github"]; !ok || v == nil {
		return fmt.Errorf("field github: required")
	}
	if v, ok := raw["googleplay"]; !ok || v == nil {
		return fmt.Errorf("field googleplay: required")
	}
	if v, ok := raw["homepage"]; !ok || v == nil {
		return fmt.Errorf("field homepage: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["redirect_uri"]; !ok || v == nil {
		return fmt.Errorf("field redirect_uri: required")
	}
	if v, ok := raw["verification_uri"]; !ok || v == nil {
		return fmt.Errorf("field verification_uri: required")
	}
	type Plain AppGetRespAppGet
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AppGetRespAppGet(plain)
	return nil
}

var enumValues_WebsiteStatusRespWebsiteStatusP2PConfigBlockTradeDisabled = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusP2PConfigBlockTradeDisabled) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WebsiteStatusRespWebsiteStatusP2PConfigBlockTradeDisabled {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WebsiteStatusRespWebsiteStatusP2PConfigBlockTradeDisabled, v)
	}
	*j = WebsiteStatusRespWebsiteStatusP2PConfigBlockTradeDisabled(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppGet) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["app_get"]; !ok || v == nil {
		return fmt.Errorf("field app_get: required")
	}
	type Plain AppGet
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AppGet(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppDeleteResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain AppDeleteResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AppDeleteResp(plain)
	return nil
}

var enumValues_WebsiteStatusRespWebsiteStatusP2PConfigCrossBorderAdsEnabled = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusP2PConfigCrossBorderAdsEnabled) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WebsiteStatusRespWebsiteStatusP2PConfigCrossBorderAdsEnabled {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WebsiteStatusRespWebsiteStatusP2PConfigCrossBorderAdsEnabled, v)
	}
	*j = WebsiteStatusRespWebsiteStatusP2PConfigCrossBorderAdsEnabled(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppDeleteRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_AppDeleteRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_AppDeleteRespMsgType, v)
	}
	*j = AppDeleteRespMsgType(v)
	return nil
}

var enumValues_WebsiteStatusRespWebsiteStatusP2PConfigDisabled = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusP2PConfigDisabled) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WebsiteStatusRespWebsiteStatusP2PConfigDisabled {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WebsiteStatusRespWebsiteStatusP2PConfigDisabled, v)
	}
	*j = WebsiteStatusRespWebsiteStatusP2PConfigDisabled(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *AppDelete) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["app_delete"]; !ok || v == nil {
		return fmt.Errorf("field app_delete: required")
	}
	type Plain AppDelete
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = AppDelete(plain)
	return nil
}

var enumValues_WebsiteStatusRespWebsiteStatusP2PConfigFixedRateAdverts = []interface{}{
	"disabled",
	"enabled",
	"list_only",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusP2PConfigFixedRateAdverts) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WebsiteStatusRespWebsiteStatusP2PConfigFixedRateAdverts {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WebsiteStatusRespWebsiteStatusP2PConfigFixedRateAdverts, v)
	}
	*j = WebsiteStatusRespWebsiteStatusP2PConfigFixedRateAdverts(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ApiTokenResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain ApiTokenResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ApiTokenResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ApiTokenRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ApiTokenRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ApiTokenRespMsgType, v)
	}
	*j = ApiTokenRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ApiTokenRespApiTokenTokensElemScopesElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ApiTokenRespApiTokenTokensElemScopesElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ApiTokenRespApiTokenTokensElemScopesElem, v)
	}
	*j = ApiTokenRespApiTokenTokensElemScopesElem(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ApiTokenRespApiTokenNewToken) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ApiTokenRespApiTokenNewToken {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ApiTokenRespApiTokenNewToken, v)
	}
	*j = ApiTokenRespApiTokenNewToken(v)
	return nil
}

var enumValues_WebsiteStatusRespWebsiteStatusP2PConfigFloatRateAdverts = []interface{}{
	"disabled",
	"enabled",
	"list_only",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusP2PConfigFloatRateAdverts) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WebsiteStatusRespWebsiteStatusP2PConfigFloatRateAdverts {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WebsiteStatusRespWebsiteStatusP2PConfigFloatRateAdverts, v)
	}
	*j = WebsiteStatusRespWebsiteStatusP2PConfigFloatRateAdverts(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ApiTokenRespApiTokenDeleteToken) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ApiTokenRespApiTokenDeleteToken {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ApiTokenRespApiTokenDeleteToken, v)
	}
	*j = ApiTokenRespApiTokenDeleteToken(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ApiToken) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["api_token"]; !ok || v == nil {
		return fmt.Errorf("field api_token: required")
	}
	type Plain ApiToken
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ApiToken(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ApiTokenValidForCurrentIpOnly) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ApiTokenValidForCurrentIpOnly {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ApiTokenValidForCurrentIpOnly, v)
	}
	*j = ApiTokenValidForCurrentIpOnly(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ApiTokenNewTokenScopesElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ApiTokenNewTokenScopesElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ApiTokenNewTokenScopesElem, v)
	}
	*j = ApiTokenNewTokenScopesElem(v)
	return nil
}

var enumValues_WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElemHasAdverts = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElemHasAdverts) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElemHasAdverts {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElemHasAdverts, v)
	}
	*j = WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElemHasAdverts(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ApiTokenApiToken) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ApiTokenApiToken {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ApiTokenApiToken, v)
	}
	*j = ApiTokenApiToken(v)
	return nil
}

var enumValues_WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElemIsDefault = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElemIsDefault) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElemIsDefault {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElemIsDefault, v)
	}
	*j = WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElemIsDefault(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ActiveSymbolsResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain ActiveSymbolsResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ActiveSymbolsResp(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["display_name"]; !ok || v == nil {
		return fmt.Errorf("field display_name: required")
	}
	if v, ok := raw["has_adverts"]; !ok || v == nil {
		return fmt.Errorf("field has_adverts: required")
	}
	if v, ok := raw["symbol"]; !ok || v == nil {
		return fmt.Errorf("field symbol: required")
	}
	type Plain WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = WebsiteStatusRespWebsiteStatusP2PConfigLocalCurrenciesElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ActiveSymbolsRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ActiveSymbolsRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ActiveSymbolsRespMsgType, v)
	}
	*j = ActiveSymbolsRespMsgType(v)
	return nil
}

var enumValues_WebsiteStatusRespWebsiteStatusP2PConfigPaymentMethodsEnabled = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusP2PConfigPaymentMethodsEnabled) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WebsiteStatusRespWebsiteStatusP2PConfigPaymentMethodsEnabled {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WebsiteStatusRespWebsiteStatusP2PConfigPaymentMethodsEnabled, v)
	}
	*j = WebsiteStatusRespWebsiteStatusP2PConfigPaymentMethodsEnabled(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ActiveSymbolsRespActiveSymbolsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["display_name"]; !ok || v == nil {
		return fmt.Errorf("field display_name: required")
	}
	if v, ok := raw["display_order"]; !ok || v == nil {
		return fmt.Errorf("field display_order: required")
	}
	if v, ok := raw["exchange_is_open"]; !ok || v == nil {
		return fmt.Errorf("field exchange_is_open: required")
	}
	if v, ok := raw["is_trading_suspended"]; !ok || v == nil {
		return fmt.Errorf("field is_trading_suspended: required")
	}
	if v, ok := raw["market"]; !ok || v == nil {
		return fmt.Errorf("field market: required")
	}
	if v, ok := raw["market_display_name"]; !ok || v == nil {
		return fmt.Errorf("field market_display_name: required")
	}
	if v, ok := raw["pip"]; !ok || v == nil {
		return fmt.Errorf("field pip: required")
	}
	if v, ok := raw["subgroup"]; !ok || v == nil {
		return fmt.Errorf("field subgroup: required")
	}
	if v, ok := raw["subgroup_display_name"]; !ok || v == nil {
		return fmt.Errorf("field subgroup_display_name: required")
	}
	if v, ok := raw["submarket"]; !ok || v == nil {
		return fmt.Errorf("field submarket: required")
	}
	if v, ok := raw["submarket_display_name"]; !ok || v == nil {
		return fmt.Errorf("field submarket_display_name: required")
	}
	if v, ok := raw["symbol"]; !ok || v == nil {
		return fmt.Errorf("field symbol: required")
	}
	if v, ok := raw["symbol_type"]; !ok || v == nil {
		return fmt.Errorf("field symbol_type: required")
	}
	type Plain ActiveSymbolsRespActiveSymbolsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ActiveSymbolsRespActiveSymbolsElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusP2PConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["adverts_active_limit"]; !ok || v == nil {
		return fmt.Errorf("field adverts_active_limit: required")
	}
	if v, ok := raw["block_trade"]; !ok || v == nil {
		return fmt.Errorf("field block_trade: required")
	}
	if v, ok := raw["cancellation_block_duration"]; !ok || v == nil {
		return fmt.Errorf("field cancellation_block_duration: required")
	}
	if v, ok := raw["cancellation_count_period"]; !ok || v == nil {
		return fmt.Errorf("field cancellation_count_period: required")
	}
	if v, ok := raw["cancellation_grace_period"]; !ok || v == nil {
		return fmt.Errorf("field cancellation_grace_period: required")
	}
	if v, ok := raw["cancellation_limit"]; !ok || v == nil {
		return fmt.Errorf("field cancellation_limit: required")
	}
	if v, ok := raw["cross_border_ads_enabled"]; !ok || v == nil {
		return fmt.Errorf("field cross_border_ads_enabled: required")
	}
	if v, ok := raw["disabled"]; !ok || v == nil {
		return fmt.Errorf("field disabled: required")
	}
	if v, ok := raw["feature_level"]; !ok || v == nil {
		return fmt.Errorf("field feature_level: required")
	}
	if v, ok := raw["fixed_rate_adverts"]; !ok || v == nil {
		return fmt.Errorf("field fixed_rate_adverts: required")
	}
	if v, ok := raw["float_rate_adverts"]; !ok || v == nil {
		return fmt.Errorf("field float_rate_adverts: required")
	}
	if v, ok := raw["float_rate_offset_limit"]; !ok || v == nil {
		return fmt.Errorf("field float_rate_offset_limit: required")
	}
	if v, ok := raw["local_currencies"]; !ok || v == nil {
		return fmt.Errorf("field local_currencies: required")
	}
	if v, ok := raw["maximum_advert_amount"]; !ok || v == nil {
		return fmt.Errorf("field maximum_advert_amount: required")
	}
	if v, ok := raw["maximum_order_amount"]; !ok || v == nil {
		return fmt.Errorf("field maximum_order_amount: required")
	}
	if v, ok := raw["order_daily_limit"]; !ok || v == nil {
		return fmt.Errorf("field order_daily_limit: required")
	}
	if v, ok := raw["order_payment_period"]; !ok || v == nil {
		return fmt.Errorf("field order_payment_period: required")
	}
	if v, ok := raw["payment_methods_enabled"]; !ok || v == nil {
		return fmt.Errorf("field payment_methods_enabled: required")
	}
	if v, ok := raw["review_period"]; !ok || v == nil {
		return fmt.Errorf("field review_period: required")
	}
	if v, ok := raw["supported_currencies"]; !ok || v == nil {
		return fmt.Errorf("field supported_currencies: required")
	}
	type Plain WebsiteStatusRespWebsiteStatusP2PConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = WebsiteStatusRespWebsiteStatusP2PConfig(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ActiveSymbolsRespActiveSymbolsElemIsTradingSuspended) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ActiveSymbolsRespActiveSymbolsElemIsTradingSuspended {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ActiveSymbolsRespActiveSymbolsElemIsTradingSuspended, v)
	}
	*j = ActiveSymbolsRespActiveSymbolsElemIsTradingSuspended(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ActiveSymbolsRespActiveSymbolsElemExchangeIsOpen) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ActiveSymbolsRespActiveSymbolsElemExchangeIsOpen {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ActiveSymbolsRespActiveSymbolsElemExchangeIsOpen, v)
	}
	*j = ActiveSymbolsRespActiveSymbolsElemExchangeIsOpen(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusPaymentAgents) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["initial_deposit_per_country"]; !ok || v == nil {
		return fmt.Errorf("field initial_deposit_per_country: required")
	}
	type Plain WebsiteStatusRespWebsiteStatusPaymentAgents
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = WebsiteStatusRespWebsiteStatusPaymentAgents(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ActiveSymbolsRespActiveSymbolsElemAllowForwardStarting) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ActiveSymbolsRespActiveSymbolsElemAllowForwardStarting {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ActiveSymbolsRespActiveSymbolsElemAllowForwardStarting, v)
	}
	*j = ActiveSymbolsRespActiveSymbolsElemAllowForwardStarting(v)
	return nil
}

var enumValues_WebsiteStatusRespWebsiteStatusSiteStatus = []interface{}{
	"up",
	"down",
	"updating",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatusSiteStatus) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_WebsiteStatusRespWebsiteStatusSiteStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_WebsiteStatusRespWebsiteStatusSiteStatus, v)
	}
	*j = WebsiteStatusRespWebsiteStatusSiteStatus(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ActiveSymbols) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["active_symbols"]; !ok || v == nil {
		return fmt.Errorf("field active_symbols: required")
	}
	type Plain ActiveSymbols
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ActiveSymbols(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ActiveSymbolsProductType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ActiveSymbolsProductType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ActiveSymbolsProductType, v)
	}
	*j = ActiveSymbolsProductType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ActiveSymbolsLandingCompanyShort) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ActiveSymbolsLandingCompanyShort {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ActiveSymbolsLandingCompanyShort, v)
	}
	*j = ActiveSymbolsLandingCompanyShort(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ActiveSymbolsLandingCompany) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ActiveSymbolsLandingCompany {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ActiveSymbolsLandingCompany, v)
	}
	*j = ActiveSymbolsLandingCompany(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusRespWebsiteStatus) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["api_call_limits"]; !ok || v == nil {
		return fmt.Errorf("field api_call_limits: required")
	}
	if v, ok := raw["currencies_config"]; !ok || v == nil {
		return fmt.Errorf("field currencies_config: required")
	}
	type Plain WebsiteStatusRespWebsiteStatus
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = WebsiteStatusRespWebsiteStatus(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ActiveSymbolsActiveSymbols) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ActiveSymbolsActiveSymbols {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ActiveSymbolsActiveSymbols, v)
	}
	*j = ActiveSymbolsActiveSymbols(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebsiteStatusResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain WebsiteStatusResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = WebsiteStatusResp(plain)
	return nil
}
