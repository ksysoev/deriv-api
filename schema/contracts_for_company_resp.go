// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import "reflect"

// Get the list of currently available contracts for a given landing company.
type ContractsForCompanyResp struct {
	// List of available contracts for a given landing company.
	ContractsForCompany *ContractsForCompanyRespContractsForCompany `json:"contracts_for_company,omitempty"`

	// Echo of the request made.
	EchoReq ContractsForCompanyRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType ContractsForCompanyRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// List of available contracts for a given landing company.
type ContractsForCompanyRespContractsForCompany struct {
	// List of available contracts.
	Available []ContractsForCompanyRespContractsForCompanyAvailableElem `json:"available"`

	// Count of contracts available
	HitCount float64 `json:"hit_count"`
}

type ContractsForCompanyRespContractsForCompanyAvailableElem struct {
	// Category of contract barrier.
	BarrierCategory string `json:"barrier_category"`

	// Category of contract.
	ContractCategory string `json:"contract_category"`

	// Display name for the contract category, localized to selected language.
	ContractCategoryDisplay string `json:"contract_category_display"`

	// Display name for the contract, localized to selected language.
	ContractDisplay string `json:"contract_display"`

	// Type of contract.
	ContractType string `json:"contract_type"`

	// Type of sentiment.
	Sentiment string `json:"sentiment"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractsForCompanyRespContractsForCompanyAvailableElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["barrier_category"]; raw != nil && !ok {
		return fmt.Errorf("field barrier_category in ContractsForCompanyRespContractsForCompanyAvailableElem: required")
	}
	if _, ok := raw["contract_category"]; raw != nil && !ok {
		return fmt.Errorf("field contract_category in ContractsForCompanyRespContractsForCompanyAvailableElem: required")
	}
	if _, ok := raw["contract_category_display"]; raw != nil && !ok {
		return fmt.Errorf("field contract_category_display in ContractsForCompanyRespContractsForCompanyAvailableElem: required")
	}
	if _, ok := raw["contract_display"]; raw != nil && !ok {
		return fmt.Errorf("field contract_display in ContractsForCompanyRespContractsForCompanyAvailableElem: required")
	}
	if _, ok := raw["contract_type"]; raw != nil && !ok {
		return fmt.Errorf("field contract_type in ContractsForCompanyRespContractsForCompanyAvailableElem: required")
	}
	if _, ok := raw["sentiment"]; raw != nil && !ok {
		return fmt.Errorf("field sentiment in ContractsForCompanyRespContractsForCompanyAvailableElem: required")
	}
	type Plain ContractsForCompanyRespContractsForCompanyAvailableElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ContractsForCompanyRespContractsForCompanyAvailableElem(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractsForCompanyRespContractsForCompany) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["available"]; raw != nil && !ok {
		return fmt.Errorf("field available in ContractsForCompanyRespContractsForCompany: required")
	}
	if _, ok := raw["hit_count"]; raw != nil && !ok {
		return fmt.Errorf("field hit_count in ContractsForCompanyRespContractsForCompany: required")
	}
	type Plain ContractsForCompanyRespContractsForCompany
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Available != nil && len(plain.Available) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "available", 1)
	}
	*j = ContractsForCompanyRespContractsForCompany(plain)
	return nil
}

// Echo of the request made.
type ContractsForCompanyRespEchoReq map[string]interface{}

type ContractsForCompanyRespMsgType string

const ContractsForCompanyRespMsgTypeContractsForCompany ContractsForCompanyRespMsgType = "contracts_for_company"

var enumValues_ContractsForCompanyRespMsgType = []interface{}{
	"contracts_for_company",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractsForCompanyRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ContractsForCompanyRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ContractsForCompanyRespMsgType, v)
	}
	*j = ContractsForCompanyRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractsForCompanyResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["echo_req"]; raw != nil && !ok {
		return fmt.Errorf("field echo_req in ContractsForCompanyResp: required")
	}
	if _, ok := raw["msg_type"]; raw != nil && !ok {
		return fmt.Errorf("field msg_type in ContractsForCompanyResp: required")
	}
	type Plain ContractsForCompanyResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ContractsForCompanyResp(plain)
	return nil
}
