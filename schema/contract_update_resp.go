// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import "reflect"

// Contains the update status of the request
type ContractUpdateRespContractUpdate struct {
	// The target spot price where the contract will be closed automatically at the
	// loss specified by the user.
	StopLoss *ContractUpdateRespContractUpdateStopLoss `json:"stop_loss,omitempty"`

	// The target spot price where the contract will be closed automatically at the
	// profit specified by the user.
	TakeProfit *ContractUpdateRespContractUpdateTakeProfit `json:"take_profit,omitempty"`
}

// The target spot price where the contract will be closed automatically at the
// loss specified by the user.
type ContractUpdateRespContractUpdateStopLoss struct {
	// Localized display name
	DisplayName *string `json:"display_name,omitempty"`

	// Stop loss amount
	OrderAmount *float64 `json:"order_amount,omitempty"`

	// Stop loss order epoch
	OrderDate *int `json:"order_date,omitempty"`

	// Stop loss pip-sized barrier value
	Value *string `json:"value,omitempty"`
}

// The target spot price where the contract will be closed automatically at the
// profit specified by the user.
type ContractUpdateRespContractUpdateTakeProfit struct {
	// Localized display name
	DisplayName *string `json:"display_name,omitempty"`

	// Take profit amount
	OrderAmount *float64 `json:"order_amount,omitempty"`

	// Take profit order epoch
	OrderDate *int `json:"order_date,omitempty"`

	// Take profit pip-sized barrier value
	Value *string `json:"value,omitempty"`
}

// Echo of the request made.
type ContractUpdateRespEchoReq map[string]interface{}

type ContractUpdateRespMsgType string

var enumValues_ContractUpdateRespMsgType = []interface{}{
	"contract_update",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractUpdateRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ContractUpdateRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ContractUpdateRespMsgType, v)
	}
	*j = ContractUpdateRespMsgType(v)
	return nil
}

// Contract update status
type ContractUpdateResp struct {
	// Contains the update status of the request
	ContractUpdate *ContractUpdateRespContractUpdate `json:"contract_update,omitempty"`

	// Echo of the request made.
	EchoReq ContractUpdateRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType ContractUpdateRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

const ContractUpdateRespMsgTypeContractUpdate ContractUpdateRespMsgType = "contract_update"

// UnmarshalJSON implements json.Unmarshaler.
func (j *ContractUpdateResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req in ContractUpdateResp: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type in ContractUpdateResp: required")
	}
	type Plain ContractUpdateResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ContractUpdateResp(plain)
	return nil
}
