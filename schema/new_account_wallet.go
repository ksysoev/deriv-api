// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import "reflect"

// Create a new account real-money wallet account.
type NewAccountWallet struct {
	// Show whether client has accepted risk disclaimer.
	AcceptRisk *NewAccountWalletAcceptRisk `json:"accept_risk,omitempty"`

	// [Optional] Purpose and reason for requesting the account opening.
	AccountOpeningReason *NewAccountWalletAccountOpeningReason `json:"account_opening_reason,omitempty"`

	// To set the wallets type - only doughflow and crptyo wallets are allowed for
	// initial phase, other types will be added later
	AccountType NewAccountWalletAccountType `json:"account_type"`

	// [Optional] Within 35 characters.
	AddressCity *string `json:"address_city,omitempty"`

	// [Optional] Mailing address.
	AddressLine1 *string `json:"address_line_1,omitempty"`

	// [Optional] Within 70 characters.
	AddressLine2 *string `json:"address_line_2,omitempty"`

	// [Optional] Within 20 characters and may not contain '+'.
	AddressPostcode *string `json:"address_postcode,omitempty"`

	// [Optional] Possible value receive from `states_list` call.
	AddressState *string `json:"address_state,omitempty"`

	// [Optional] Affiliate token, within 32 characters.
	AffiliateToken *string `json:"affiliate_token,omitempty"`

	// [Optional] The phone's calling country code. Don't include the `+` sign. Up to
	// 4 digits.
	CallingCountryCode *string `json:"calling_country_code,omitempty"`

	// [Optional] Country of legal citizenship, 2-letter country code. Possible value
	// receive from `residence_list` call.
	Citizen *string `json:"citizen,omitempty"`

	// [Optional] Indicates whether this is for a client requesting an account with
	// professional status.
	ClientType NewAccountWalletClientType `json:"client_type,omitempty"`

	// To set currency of the account. List of supported currencies can be acquired
	// with `payout_currencies` call.
	Currency string `json:"currency"`

	// [Optional] Date of birth format: `yyyy-mm-dd`.
	DateOfBirth *string `json:"date_of_birth,omitempty"`

	// Employment Status.
	EmploymentStatus *string `json:"employment_status,omitempty"`

	// [Optional] Indicates client's self-declaration of FATCA.
	FatcaDeclaration *NewAccountWalletFatcaDeclaration `json:"fatca_declaration,omitempty"`

	// Required for maltainvest
	FinancialAssessment NewAccountWalletFinancialAssessment `json:"financial_assessment,omitempty"`

	// [Optional] Within 1-50 characters, use only letters, spaces, hyphens,
	// full-stops or apostrophes.
	FirstName *string `json:"first_name,omitempty"`

	// [Optional] Set the landing company of the wallet. Default value is 'svg' if
	// company not provided
	LandingCompanyShort *NewAccountWalletLandingCompanyShort `json:"landing_company_short,omitempty"`

	// [Optional] Within 1-50 characters, use only letters, spaces, hyphens,
	// full-stops or apostrophes.
	LastName *string `json:"last_name,omitempty"`

	// [Optional] The login id of the user. Mandatory when multiple tokens were
	// provided during authorize.
	Loginid *string `json:"loginid,omitempty"`

	// Must be `1`
	NewAccountWallet NewAccountWalletNewAccountWallet `json:"new_account_wallet"`

	// [Optional] Indicates client's self-declaration of not being a PEP/RCA
	// (Politically Exposed Person/Relatives and Close Associates).
	NonPepDeclaration *int `json:"non_pep_declaration,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field.
	Passthrough NewAccountWalletPassthrough `json:"passthrough,omitempty"`

	// [Optional] The phone's national format, don't include the `+` sign nor the
	// calling country code. Up to 15 digits are allowed.
	Phone *string `json:"phone,omitempty"`

	// [Optional] Place of birth, 2-letter country code.
	PlaceOfBirth *string `json:"place_of_birth,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// 2-letter country code, possible value receive from `residence_list` call.
	Residence *string `json:"residence,omitempty"`

	// [Optional] Indicates client's self declaration for opening account under own
	// initiative, must be 1
	ResidentSelfDeclaration *NewAccountWalletResidentSelfDeclaration `json:"resident_self_declaration,omitempty"`

	// Accept any value in enum list.
	Salutation *NewAccountWalletSalutation `json:"salutation,omitempty"`

	// Tax identification number. Only applicable for real money account. Required for
	// `maltainvest` landing company.
	TaxIdentificationNumber *string `json:"tax_identification_number,omitempty"`

	// Residence for tax purpose. Comma separated iso country code if multiple
	// jurisdictions. Only applicable for real money account. Required for
	// `maltainvest` landing company.
	TaxResidence *string `json:"tax_residence,omitempty"`

	// [Optional] Whether the client has skipped the TIN form. Only applicable for
	// real money account.
	TinSkipped *NewAccountWalletTinSkipped `json:"tin_skipped,omitempty"`

	// The tnc acceptance status of the user.
	TncAcceptance *NewAccountWalletTncAcceptance `json:"tnc_acceptance,omitempty"`
}

type NewAccountWalletAcceptRisk int

var enumValues_NewAccountWalletAcceptRisk = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountWalletAcceptRisk) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountWalletAcceptRisk {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountWalletAcceptRisk, v)
	}
	*j = NewAccountWalletAcceptRisk(v)
	return nil
}

type NewAccountWalletAccountOpeningReason string

const NewAccountWalletAccountOpeningReasonAdditionalRevenue NewAccountWalletAccountOpeningReason = "Additional revenue"
const NewAccountWalletAccountOpeningReasonHedging NewAccountWalletAccountOpeningReason = "Hedging"
const NewAccountWalletAccountOpeningReasonIncomeEarning NewAccountWalletAccountOpeningReason = "Income Earning"
const NewAccountWalletAccountOpeningReasonPeerToPeerExchange NewAccountWalletAccountOpeningReason = "Peer-to-peer exchange"
const NewAccountWalletAccountOpeningReasonSavings NewAccountWalletAccountOpeningReason = "Savings"
const NewAccountWalletAccountOpeningReasonSpeculative NewAccountWalletAccountOpeningReason = "Speculative"

var enumValues_NewAccountWalletAccountOpeningReason = []interface{}{
	"Speculative",
	"Income Earning",
	"Hedging",
	"Peer-to-peer exchange",
	"Additional revenue",
	"Savings",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountWalletAccountOpeningReason) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountWalletAccountOpeningReason {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountWalletAccountOpeningReason, v)
	}
	*j = NewAccountWalletAccountOpeningReason(v)
	return nil
}

type NewAccountWalletAccountType string

const NewAccountWalletAccountTypeCrypto NewAccountWalletAccountType = "crypto"
const NewAccountWalletAccountTypeDoughflow NewAccountWalletAccountType = "doughflow"

var enumValues_NewAccountWalletAccountType = []interface{}{
	"doughflow",
	"crypto",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountWalletAccountType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountWalletAccountType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountWalletAccountType, v)
	}
	*j = NewAccountWalletAccountType(v)
	return nil
}

type NewAccountWalletClientType string

const NewAccountWalletClientTypeProfessional NewAccountWalletClientType = "professional"
const NewAccountWalletClientTypeRetail NewAccountWalletClientType = "retail"

var enumValues_NewAccountWalletClientType = []interface{}{
	"professional",
	"retail",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountWalletClientType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountWalletClientType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountWalletClientType, v)
	}
	*j = NewAccountWalletClientType(v)
	return nil
}

type NewAccountWalletFatcaDeclaration int

var enumValues_NewAccountWalletFatcaDeclaration = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountWalletFatcaDeclaration) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountWalletFatcaDeclaration {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountWalletFatcaDeclaration, v)
	}
	*j = NewAccountWalletFatcaDeclaration(v)
	return nil
}

// Required for maltainvest
type NewAccountWalletFinancialAssessment map[string]interface{}

type NewAccountWalletLandingCompanyShort string

const NewAccountWalletLandingCompanyShortMaltainvest NewAccountWalletLandingCompanyShort = "maltainvest"
const NewAccountWalletLandingCompanyShortSvg NewAccountWalletLandingCompanyShort = "svg"

var enumValues_NewAccountWalletLandingCompanyShort = []interface{}{
	"maltainvest",
	"svg",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountWalletLandingCompanyShort) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountWalletLandingCompanyShort {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountWalletLandingCompanyShort, v)
	}
	*j = NewAccountWalletLandingCompanyShort(v)
	return nil
}

type NewAccountWalletNewAccountWallet int

var enumValues_NewAccountWalletNewAccountWallet = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountWalletNewAccountWallet) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountWalletNewAccountWallet {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountWalletNewAccountWallet, v)
	}
	*j = NewAccountWalletNewAccountWallet(v)
	return nil
}

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field.
type NewAccountWalletPassthrough map[string]interface{}

type NewAccountWalletResidentSelfDeclaration int

var enumValues_NewAccountWalletResidentSelfDeclaration = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountWalletResidentSelfDeclaration) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountWalletResidentSelfDeclaration {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountWalletResidentSelfDeclaration, v)
	}
	*j = NewAccountWalletResidentSelfDeclaration(v)
	return nil
}

type NewAccountWalletSalutation string

const NewAccountWalletSalutationMiss NewAccountWalletSalutation = "Miss"
const NewAccountWalletSalutationMr NewAccountWalletSalutation = "Mr"
const NewAccountWalletSalutationMrs NewAccountWalletSalutation = "Mrs"
const NewAccountWalletSalutationMs NewAccountWalletSalutation = "Ms"

var enumValues_NewAccountWalletSalutation = []interface{}{
	"Mr",
	"Ms",
	"Miss",
	"Mrs",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountWalletSalutation) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountWalletSalutation {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountWalletSalutation, v)
	}
	*j = NewAccountWalletSalutation(v)
	return nil
}

type NewAccountWalletTinSkipped int

var enumValues_NewAccountWalletTinSkipped = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountWalletTinSkipped) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountWalletTinSkipped {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountWalletTinSkipped, v)
	}
	*j = NewAccountWalletTinSkipped(v)
	return nil
}

type NewAccountWalletTncAcceptance int

var enumValues_NewAccountWalletTncAcceptance = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountWalletTncAcceptance) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NewAccountWalletTncAcceptance {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NewAccountWalletTncAcceptance, v)
	}
	*j = NewAccountWalletTncAcceptance(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NewAccountWallet) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["account_type"]; raw != nil && !ok {
		return fmt.Errorf("field account_type in NewAccountWallet: required")
	}
	if _, ok := raw["currency"]; raw != nil && !ok {
		return fmt.Errorf("field currency in NewAccountWallet: required")
	}
	if _, ok := raw["new_account_wallet"]; raw != nil && !ok {
		return fmt.Errorf("field new_account_wallet in NewAccountWallet: required")
	}
	type Plain NewAccountWallet
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["client_type"]; !ok || v == nil {
		plain.ClientType = "retail"
	}
	*j = NewAccountWallet(plain)
	return nil
}
