// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import "reflect"

// This call manages API tokens
type ApiToken struct {
	// Must be `1`
	ApiToken ApiTokenApiToken `json:"api_token"`

	// [Optional] The token to remove.
	DeleteToken *string `json:"delete_token,omitempty"`

	// [Optional] The name of the created token.
	NewToken *string `json:"new_token,omitempty"`

	// [Optional] List of permission scopes to provide with the token.
	NewTokenScopes []ApiTokenNewTokenScopesElem `json:"new_token_scopes,omitempty"`

	// [Optional] Used to pass data through the websocket, which may be retrieved via
	// the `echo_req` output field. Maximum size is 3500 bytes.
	Passthrough ApiTokenPassthrough `json:"passthrough,omitempty"`

	// [Optional] Used to map request to response.
	ReqId *int `json:"req_id,omitempty"`

	// [Optional] If you set this parameter during token creation, then the token
	// created will only work for the IP address that was used to create the token
	ValidForCurrentIpOnly *ApiTokenValidForCurrentIpOnly `json:"valid_for_current_ip_only,omitempty"`
}

type ApiTokenApiToken int

type ApiTokenNewTokenScopesElem string

const ApiTokenNewTokenScopesElemAdmin ApiTokenNewTokenScopesElem = "admin"
const ApiTokenNewTokenScopesElemPayments ApiTokenNewTokenScopesElem = "payments"
const ApiTokenNewTokenScopesElemRead ApiTokenNewTokenScopesElem = "read"
const ApiTokenNewTokenScopesElemTrade ApiTokenNewTokenScopesElem = "trade"
const ApiTokenNewTokenScopesElemTradingInformation ApiTokenNewTokenScopesElem = "trading_information"

// [Optional] Used to pass data through the websocket, which may be retrieved via
// the `echo_req` output field. Maximum size is 3500 bytes.
type ApiTokenPassthrough map[string]interface{}

type ApiTokenValidForCurrentIpOnly int

// UnmarshalJSON implements json.Unmarshaler.
func (j *ApiTokenNewTokenScopesElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ApiTokenNewTokenScopesElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ApiTokenNewTokenScopesElem, v)
	}
	*j = ApiTokenNewTokenScopesElem(v)
	return nil
}

var enumValues_ApiTokenNewTokenScopesElem = []interface{}{
	"read",
	"trade",
	"trading_information",
	"payments",
	"admin",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ApiTokenApiToken) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ApiTokenApiToken {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ApiTokenApiToken, v)
	}
	*j = ApiTokenApiToken(v)
	return nil
}

var enumValues_ApiTokenValidForCurrentIpOnly = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ApiTokenValidForCurrentIpOnly) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ApiTokenValidForCurrentIpOnly {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ApiTokenValidForCurrentIpOnly, v)
	}
	*j = ApiTokenValidForCurrentIpOnly(v)
	return nil
}

var enumValues_ApiTokenApiToken = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ApiToken) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["api_token"]; !ok || v == nil {
		return fmt.Errorf("field api_token in ApiToken: required")
	}
	type Plain ApiToken
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ApiToken(plain)
	return nil
}
