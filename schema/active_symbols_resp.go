// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import "reflect"

// UnmarshalJSON implements json.Unmarshaler.
func (j *ActiveSymbolsRespActiveSymbolsElemIsTradingSuspended) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ActiveSymbolsRespActiveSymbolsElemIsTradingSuspended {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ActiveSymbolsRespActiveSymbolsElemIsTradingSuspended, v)
	}
	*j = ActiveSymbolsRespActiveSymbolsElemIsTradingSuspended(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ActiveSymbolsRespActiveSymbolsElemAllowForwardStarting) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ActiveSymbolsRespActiveSymbolsElemAllowForwardStarting {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ActiveSymbolsRespActiveSymbolsElemAllowForwardStarting, v)
	}
	*j = ActiveSymbolsRespActiveSymbolsElemAllowForwardStarting(v)
	return nil
}

// The information about each symbol.
type ActiveSymbolsRespActiveSymbolsElem struct {
	// `1` if the symbol is tradable in a forward starting contract, `0` if not.
	AllowForwardStarting *ActiveSymbolsRespActiveSymbolsElemAllowForwardStarting `json:"allow_forward_starting,omitempty"`

	// Amount the data feed is delayed (in minutes) due to Exchange licensing
	// requirements. Only returned on `full` active symbols call.
	DelayAmount *int `json:"delay_amount,omitempty"`

	// Display name.
	DisplayName string `json:"display_name"`

	// Display order.
	DisplayOrder int `json:"display_order"`

	// `1` if market is currently open, `0` if closed.
	ExchangeIsOpen ActiveSymbolsRespActiveSymbolsElemExchangeIsOpen `json:"exchange_is_open"`

	// Exchange name (for underlyings listed on a Stock Exchange). Only returned on
	// `full` active symbols call.
	ExchangeName *string `json:"exchange_name,omitempty"`

	// Intraday interval minutes. Only returned on `full` active symbols call.
	IntradayIntervalMinutes *int `json:"intraday_interval_minutes,omitempty"`

	// `1` indicates that trading is currently suspended, `0` if not.
	IsTradingSuspended ActiveSymbolsRespActiveSymbolsElemIsTradingSuspended `json:"is_trading_suspended"`

	// Market category (forex, indices, etc).
	Market string `json:"market"`

	// Translated market name.
	MarketDisplayName string `json:"market_display_name"`

	// Pip size (i.e. minimum fluctuation amount).
	Pip float64 `json:"pip"`

	// For stock indices, the underlying currency for that instrument. Only returned
	// on `full` active symbols call.
	QuotedCurrencySymbol *string `json:"quoted_currency_symbol,omitempty"`

	// Latest spot price of the underlying. Only returned on `full` active symbols
	// call.
	Spot *float64 `json:"spot,omitempty"`

	// Number of seconds elapsed since the last spot price. Only returned on `full`
	// active symbols call.
	SpotAge *string `json:"spot_age,omitempty"`

	// Daily percentage for a symbol. Only returned on 'full' active symbols call.
	SpotPercentageChange *string `json:"spot_percentage_change,omitempty"`

	// Latest spot epoch time. Only returned on `full` active symbols call.
	SpotTime *string `json:"spot_time,omitempty"`

	// Subgroup name.
	Subgroup string `json:"subgroup"`

	// Translated subgroup name.
	SubgroupDisplayName string `json:"subgroup_display_name"`

	// Submarket name.
	Submarket string `json:"submarket"`

	// Translated submarket name.
	SubmarketDisplayName string `json:"submarket_display_name"`

	// The symbol code for this underlying.
	Symbol string `json:"symbol"`

	// Symbol type (forex, commodities, etc).
	SymbolType string `json:"symbol_type"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ActiveSymbolsRespActiveSymbolsElem) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["display_name"]; !ok || v == nil {
		return fmt.Errorf("field display_name in ActiveSymbolsRespActiveSymbolsElem: required")
	}
	if v, ok := raw["display_order"]; !ok || v == nil {
		return fmt.Errorf("field display_order in ActiveSymbolsRespActiveSymbolsElem: required")
	}
	if v, ok := raw["exchange_is_open"]; !ok || v == nil {
		return fmt.Errorf("field exchange_is_open in ActiveSymbolsRespActiveSymbolsElem: required")
	}
	if v, ok := raw["is_trading_suspended"]; !ok || v == nil {
		return fmt.Errorf("field is_trading_suspended in ActiveSymbolsRespActiveSymbolsElem: required")
	}
	if v, ok := raw["market"]; !ok || v == nil {
		return fmt.Errorf("field market in ActiveSymbolsRespActiveSymbolsElem: required")
	}
	if v, ok := raw["market_display_name"]; !ok || v == nil {
		return fmt.Errorf("field market_display_name in ActiveSymbolsRespActiveSymbolsElem: required")
	}
	if v, ok := raw["pip"]; !ok || v == nil {
		return fmt.Errorf("field pip in ActiveSymbolsRespActiveSymbolsElem: required")
	}
	if v, ok := raw["subgroup"]; !ok || v == nil {
		return fmt.Errorf("field subgroup in ActiveSymbolsRespActiveSymbolsElem: required")
	}
	if v, ok := raw["subgroup_display_name"]; !ok || v == nil {
		return fmt.Errorf("field subgroup_display_name in ActiveSymbolsRespActiveSymbolsElem: required")
	}
	if v, ok := raw["submarket"]; !ok || v == nil {
		return fmt.Errorf("field submarket in ActiveSymbolsRespActiveSymbolsElem: required")
	}
	if v, ok := raw["submarket_display_name"]; !ok || v == nil {
		return fmt.Errorf("field submarket_display_name in ActiveSymbolsRespActiveSymbolsElem: required")
	}
	if v, ok := raw["symbol"]; !ok || v == nil {
		return fmt.Errorf("field symbol in ActiveSymbolsRespActiveSymbolsElem: required")
	}
	if v, ok := raw["symbol_type"]; !ok || v == nil {
		return fmt.Errorf("field symbol_type in ActiveSymbolsRespActiveSymbolsElem: required")
	}
	type Plain ActiveSymbolsRespActiveSymbolsElem
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ActiveSymbolsRespActiveSymbolsElem(plain)
	return nil
}

var enumValues_ActiveSymbolsRespActiveSymbolsElemExchangeIsOpen = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ActiveSymbolsRespActiveSymbolsElemExchangeIsOpen) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ActiveSymbolsRespActiveSymbolsElemExchangeIsOpen {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ActiveSymbolsRespActiveSymbolsElemExchangeIsOpen, v)
	}
	*j = ActiveSymbolsRespActiveSymbolsElemExchangeIsOpen(v)
	return nil
}

type ActiveSymbolsRespActiveSymbolsElemIsTradingSuspended int

var enumValues_ActiveSymbolsRespActiveSymbolsElemIsTradingSuspended = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ActiveSymbolsResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req in ActiveSymbolsResp: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type in ActiveSymbolsResp: required")
	}
	type Plain ActiveSymbolsResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ActiveSymbolsResp(plain)
	return nil
}

var enumValues_ActiveSymbolsRespActiveSymbolsElemAllowForwardStarting = []interface{}{
	0,
	1,
}

type ActiveSymbolsRespActiveSymbolsElemExchangeIsOpen int

// Echo of the request made.
type ActiveSymbolsRespEchoReq map[string]interface{}

type ActiveSymbolsRespMsgType string

var enumValues_ActiveSymbolsRespMsgType = []interface{}{
	"active_symbols",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ActiveSymbolsRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ActiveSymbolsRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ActiveSymbolsRespMsgType, v)
	}
	*j = ActiveSymbolsRespMsgType(v)
	return nil
}

const ActiveSymbolsRespMsgTypeActiveSymbols ActiveSymbolsRespMsgType = "active_symbols"

// A message containing the list of active symbols.
type ActiveSymbolsResp struct {
	// List of active symbols.
	ActiveSymbols []ActiveSymbolsRespActiveSymbolsElem `json:"active_symbols,omitempty"`

	// Echo of the request made.
	EchoReq ActiveSymbolsRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType ActiveSymbolsRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

type ActiveSymbolsRespActiveSymbolsElemAllowForwardStarting int
