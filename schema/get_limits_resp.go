// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "fmt"
import "reflect"
import "encoding/json"

// Echo of the request made.
type GetLimitsRespEchoReq map[string]interface{}

// Trading limits of real account user
type GetLimitsRespGetLimits struct {
	// Maximum account cash balance
	AccountBalance interface{} `json:"account_balance,omitempty"`

	// Cumulative daily transfer limits
	DailyCumulativeAmountTransfers GetLimitsRespGetLimitsDailyCumulativeAmountTransfers `json:"daily_cumulative_amount_transfers,omitempty"`

	// Daily transfers
	DailyTransfers GetLimitsRespGetLimitsDailyTransfers `json:"daily_transfers,omitempty"`

	// Maximum daily turnover
	DailyTurnover *float64 `json:"daily_turnover,omitempty"`

	// Lifetime withdrawal limit
	LifetimeLimit *float64 `json:"lifetime_limit,omitempty"`

	// Contains limitation information for each market.
	MarketSpecific GetLimitsRespGetLimitsMarketSpecific `json:"market_specific,omitempty"`

	// Number of days for num_of_days_limit withdrawal limit
	NumOfDays *int `json:"num_of_days,omitempty"`

	// Withdrawal limit for num_of_days days
	NumOfDaysLimit *float64 `json:"num_of_days_limit,omitempty"`

	// Maximum number of open positions
	OpenPositions *int `json:"open_positions,omitempty"`

	// Maximum aggregate payouts on open positions
	Payout *float64 `json:"payout,omitempty"`

	// Maximum payout for each symbol based on different barrier types.
	PayoutPerSymbol interface{} `json:"payout_per_symbol,omitempty"`

	// Maximum aggregate payouts on open positions per symbol and contract type. This
	// limit can be exceeded up to the overall payout limit if there is no prior open
	// position.
	PayoutPerSymbolAndContractType *float64 `json:"payout_per_symbol_and_contract_type,omitempty"`

	// Amount left to reach withdrawal limit
	Remainder *float64 `json:"remainder,omitempty"`

	// Total withdrawal for num_of_days days
	WithdrawalForXDaysMonetary *float64 `json:"withdrawal_for_x_days_monetary,omitempty"`

	// Total withdrawal since inception
	WithdrawalSinceInceptionMonetary *float64 `json:"withdrawal_since_inception_monetary,omitempty"`
}

// Cumulative daily transfer limits
type GetLimitsRespGetLimitsDailyCumulativeAmountTransfers map[string]interface{}

// Daily transfers
type GetLimitsRespGetLimitsDailyTransfers map[string]interface{}

// Contains limitation information for each market.
type GetLimitsRespGetLimitsMarketSpecific map[string]interface{}

type GetLimitsRespMsgType string

var enumValues_GetLimitsRespMsgType = []interface{}{
	"get_limits",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetLimitsRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GetLimitsRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GetLimitsRespMsgType, v)
	}
	*j = GetLimitsRespMsgType(v)
	return nil
}

// Trading and Withdrawal Limits
type GetLimitsResp struct {
	// Echo of the request made.
	EchoReq GetLimitsRespEchoReq `json:"echo_req"`

	// Trading limits of real account user
	GetLimits *GetLimitsRespGetLimits `json:"get_limits,omitempty"`

	// Action name of the request made.
	MsgType GetLimitsRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

const GetLimitsRespMsgTypeGetLimits GetLimitsRespMsgType = "get_limits"

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetLimitsResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain GetLimitsResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetLimitsResp(plain)
	return nil
}
