// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import "reflect"

// Trading and Withdrawal Limits
type GetLimitsResp struct {
	// Echo of the request made.
	EchoReq GetLimitsRespEchoReq `json:"echo_req"`

	// Trading limits of real account user
	GetLimits *GetLimitsRespGetLimits `json:"get_limits,omitempty"`

	// Action name of the request made.
	MsgType GetLimitsRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// Echo of the request made.
type GetLimitsRespEchoReq map[string]interface{}

// Trading limits of real account user
type GetLimitsRespGetLimits struct {
	// Maximum account cash balance
	AccountBalance *float64 `json:"account_balance,omitempty"`

	// Cumulative daily transfer limits
	DailyCumulativeAmountTransfers GetLimitsRespGetLimitsDailyCumulativeAmountTransfers `json:"daily_cumulative_amount_transfers,omitempty"`

	// Daily transfers
	DailyTransfers GetLimitsRespGetLimitsDailyTransfers `json:"daily_transfers,omitempty"`

	// Maximum daily turnover
	DailyTurnover *float64 `json:"daily_turnover,omitempty"`

	// Lifetime withdrawal limit
	LifetimeLimit *float64 `json:"lifetime_limit,omitempty"`

	// Lifetime transfer limits. Only present when applicable to the current accout.
	LifetimeTransfers *GetLimitsRespGetLimitsLifetimeTransfers `json:"lifetime_transfers,omitempty"`

	// Contains limitation information for each market.
	MarketSpecific GetLimitsRespGetLimitsMarketSpecific `json:"market_specific,omitempty"`

	// Number of days for num_of_days_limit withdrawal limit
	NumOfDays *int `json:"num_of_days,omitempty"`

	// Withdrawal limit for num_of_days days
	NumOfDaysLimit *float64 `json:"num_of_days_limit,omitempty"`

	// Maximum number of open positions
	OpenPositions *int `json:"open_positions,omitempty"`

	// Maximum aggregate payouts on open positions
	Payout *float64 `json:"payout,omitempty"`

	// Maximum payout for each symbol based on different barrier types.
	PayoutPerSymbol *GetLimitsRespGetLimitsPayoutPerSymbol `json:"payout_per_symbol,omitempty"`

	// Maximum aggregate payouts on open positions per symbol and contract type. This
	// limit can be exceeded up to the overall payout limit if there is no prior open
	// position.
	PayoutPerSymbolAndContractType *float64 `json:"payout_per_symbol_and_contract_type,omitempty"`

	// Amount left to reach withdrawal limit
	Remainder *float64 `json:"remainder,omitempty"`

	// Total withdrawal for num_of_days days
	WithdrawalForXDaysMonetary *float64 `json:"withdrawal_for_x_days_monetary,omitempty"`

	// Total withdrawal since inception
	WithdrawalSinceInceptionMonetary *float64 `json:"withdrawal_since_inception_monetary,omitempty"`
}

// Cumulative daily transfer limits
type GetLimitsRespGetLimitsDailyCumulativeAmountTransfers map[string]interface{}

// Daily transfers
type GetLimitsRespGetLimitsDailyTransfers map[string]interface{}

// Lifetime transfer limits. Only present when applicable to the current accout.
type GetLimitsRespGetLimitsLifetimeTransfers struct {
	// Lifetime transfer limit for crypto to crypto currencies.
	CryptoToCrypto *GetLimitsRespGetLimitsLifetimeTransfersCryptoToCrypto `json:"crypto_to_crypto,omitempty"`

	// Lifetime transfer limit for crypto to fiat currencies.
	CryptoToFiat *GetLimitsRespGetLimitsLifetimeTransfersCryptoToFiat `json:"crypto_to_fiat,omitempty"`

	// Lifetime transfer limit for fiat to crypto currencies.
	FiatToCrypto *GetLimitsRespGetLimitsLifetimeTransfersFiatToCrypto `json:"fiat_to_crypto,omitempty"`
}

// Lifetime transfer limit for crypto to crypto currencies.
type GetLimitsRespGetLimitsLifetimeTransfersCryptoToCrypto struct {
	// Total limit in client's currency.
	Allowed *float64 `json:"allowed,omitempty"`

	// Remaining limit in client's currency.
	Available *float64 `json:"available,omitempty"`
}

// Lifetime transfer limit for crypto to fiat currencies.
type GetLimitsRespGetLimitsLifetimeTransfersCryptoToFiat struct {
	// Total limit in client's currency.
	Allowed *float64 `json:"allowed,omitempty"`

	// Remaining limit in client's currency.
	Available *float64 `json:"available,omitempty"`
}

// Lifetime transfer limit for fiat to crypto currencies.
type GetLimitsRespGetLimitsLifetimeTransfersFiatToCrypto struct {
	// Total limit in client's currency.
	Allowed *float64 `json:"allowed,omitempty"`

	// Remaining limit in client's currency.
	Available *float64 `json:"available,omitempty"`
}

// Contains limitation information for each market.
type GetLimitsRespGetLimitsMarketSpecific map[string]interface{}

// Maximum payout for each symbol based on different barrier types.
type GetLimitsRespGetLimitsPayoutPerSymbol struct {
	// Maximum aggregate payouts on open positions per symbol for contracts where
	// barrier is same as entry spot.
	Atm *float64 `json:"atm,omitempty"`

	// Maximum aggregate payouts on open positions per symbol for contract where
	// barrier is different from entry spot.
	NonAtm *GetLimitsRespGetLimitsPayoutPerSymbolNonAtm `json:"non_atm,omitempty"`
}

// Maximum aggregate payouts on open positions per symbol for contract where
// barrier is different from entry spot.
type GetLimitsRespGetLimitsPayoutPerSymbolNonAtm struct {
	// Maximum aggregate payouts on open positions per symbol for contract where
	// barrier is different from entry spot and duration is less than and equal to
	// seven days
	LessThanSevenDays *float64 `json:"less_than_seven_days,omitempty"`

	// Maximum aggregate payouts on open positions per symbol for contract where
	// barrier is different from entry spot and duration is more to seven days
	MoreThanSevenDays *float64 `json:"more_than_seven_days,omitempty"`
}

var enumValues_GetLimitsRespMsgType = []interface{}{
	"get_limits",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetLimitsRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GetLimitsRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GetLimitsRespMsgType, v)
	}
	*j = GetLimitsRespMsgType(v)
	return nil
}

type GetLimitsRespMsgType string

const GetLimitsRespMsgTypeGetLimits GetLimitsRespMsgType = "get_limits"

// UnmarshalJSON implements json.Unmarshaler.
func (j *GetLimitsResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req in GetLimitsResp: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type in GetLimitsResp: required")
	}
	type Plain GetLimitsResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = GetLimitsResp(plain)
	return nil
}
