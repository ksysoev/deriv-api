// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import "reflect"

// Echo of the request made.
type P2PAdvertInfoRespEchoReq map[string]interface{}

type P2PAdvertInfoRespMsgType string

var enumValues_P2PAdvertInfoRespMsgType = []interface{}{
	"p2p_advert_info",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertInfoRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertInfoRespMsgType, v)
	}
	*j = P2PAdvertInfoRespMsgType(v)
	return nil
}

const P2PAdvertInfoRespMsgTypeP2PAdvertInfo P2PAdvertInfoRespMsgType = "p2p_advert_info"

type P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsBlocked int

var enumValues_P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsBlocked = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsBlocked) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsBlocked {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsBlocked, v)
	}
	*j = P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsBlocked(v)
	return nil
}

type P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsFavourite int

var enumValues_P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsFavourite = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsFavourite) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsFavourite {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsFavourite, v)
	}
	*j = P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsFavourite(v)
	return nil
}

type P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsOnline int

var enumValues_P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsOnline = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsOnline) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsOnline {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsOnline, v)
	}
	*j = P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsOnline(v)
	return nil
}

type P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsRecommended struct {
	Value interface{}
}

var enumValues_P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsRecommended = []interface{}{
	nil,
	0.0,
	1.0,
}

// MarshalJSON implements json.Marshaler.
func (j *P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsRecommended) MarshalJSON() ([]byte, error) {
	return json.Marshal(j.Value)
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsRecommended) UnmarshalJSON(b []byte) error {
	var v struct {
		Value interface{}
	}
	if err := json.Unmarshal(b, &v.Value); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsRecommended {
		if reflect.DeepEqual(v.Value, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsRecommended, v.Value)
	}
	*j = P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsRecommended(v)
	return nil
}

// Details of the advertiser for this advert.
type P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetails struct {
	// The total number of orders completed in the past 30 days.
	CompletedOrdersCount int `json:"completed_orders_count"`

	// The advertiser's first name.
	FirstName *string `json:"first_name,omitempty"`

	// The advertiser's unique identifier.
	Id string `json:"id"`

	// Indicates that the advertiser is blocked by the current user.
	IsBlocked *P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsBlocked `json:"is_blocked,omitempty"`

	// Indicates that the advertiser is a favourite of the current user.
	IsFavourite *P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsFavourite `json:"is_favourite,omitempty"`

	// Indicates if the advertiser is currently online.
	IsOnline P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsOnline `json:"is_online"`

	// Indicates that the advertiser was recommended in the most recent review by the
	// current user.
	IsRecommended *P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetailsIsRecommended `json:"is_recommended,omitempty"`

	// The advertiser's last name.
	LastName *string `json:"last_name,omitempty"`

	// Epoch of the latest time the advertiser was online, up to 6 months.
	LastOnlineTime *int `json:"last_online_time"`

	// The advertiser's displayed name.
	Name string `json:"name"`

	// Average rating of the advertiser, range is 1-5.
	RatingAverage *float64 `json:"rating_average"`

	// Number of ratings given to the advertiser.
	RatingCount int `json:"rating_count"`

	// Percentage of users who have recommended the advertiser.
	RecommendedAverage *float64 `json:"recommended_average"`

	// Number of times the advertiser has been recommended.
	RecommendedCount *int `json:"recommended_count"`

	// The percentage of successfully completed orders made by or placed against the
	// advertiser within the past 30 days.
	TotalCompletionRate *float64 `json:"total_completion_rate"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["completed_orders_count"]; !ok || v == nil {
		return fmt.Errorf("field completed_orders_count in P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetails: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id in P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetails: required")
	}
	if v, ok := raw["is_online"]; !ok || v == nil {
		return fmt.Errorf("field is_online in P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetails: required")
	}
	if v, ok := raw["last_online_time"]; !ok || v == nil {
		return fmt.Errorf("field last_online_time in P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetails: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetails: required")
	}
	if v, ok := raw["rating_average"]; !ok || v == nil {
		return fmt.Errorf("field rating_average in P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetails: required")
	}
	if v, ok := raw["rating_count"]; !ok || v == nil {
		return fmt.Errorf("field rating_count in P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetails: required")
	}
	if v, ok := raw["recommended_average"]; !ok || v == nil {
		return fmt.Errorf("field recommended_average in P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetails: required")
	}
	if v, ok := raw["recommended_count"]; !ok || v == nil {
		return fmt.Errorf("field recommended_count in P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetails: required")
	}
	if v, ok := raw["total_completion_rate"]; !ok || v == nil {
		return fmt.Errorf("field total_completion_rate in P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetails: required")
	}
	type Plain P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetails(plain)
	return nil
}

type P2PAdvertInfoRespP2PAdvertInfoBlockTrade int

var enumValues_P2PAdvertInfoRespP2PAdvertInfoBlockTrade = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespP2PAdvertInfoBlockTrade) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertInfoRespP2PAdvertInfoBlockTrade {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertInfoRespP2PAdvertInfoBlockTrade, v)
	}
	*j = P2PAdvertInfoRespP2PAdvertInfoBlockTrade(v)
	return nil
}

type P2PAdvertInfoRespP2PAdvertInfoCounterpartyType string

var enumValues_P2PAdvertInfoRespP2PAdvertInfoCounterpartyType = []interface{}{
	"buy",
	"sell",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespP2PAdvertInfoCounterpartyType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertInfoRespP2PAdvertInfoCounterpartyType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertInfoRespP2PAdvertInfoCounterpartyType, v)
	}
	*j = P2PAdvertInfoRespP2PAdvertInfoCounterpartyType(v)
	return nil
}

const P2PAdvertInfoRespP2PAdvertInfoCounterpartyTypeBuy P2PAdvertInfoRespP2PAdvertInfoCounterpartyType = "buy"
const P2PAdvertInfoRespP2PAdvertInfoCounterpartyTypeSell P2PAdvertInfoRespP2PAdvertInfoCounterpartyType = "sell"

type P2PAdvertInfoRespP2PAdvertInfoDeleted int

var enumValues_P2PAdvertInfoRespP2PAdvertInfoDeleted = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespP2PAdvertInfoDeleted) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertInfoRespP2PAdvertInfoDeleted {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertInfoRespP2PAdvertInfoDeleted, v)
	}
	*j = P2PAdvertInfoRespP2PAdvertInfoDeleted(v)
	return nil
}

type P2PAdvertInfoRespP2PAdvertInfoEligibilityStatusElem string

var enumValues_P2PAdvertInfoRespP2PAdvertInfoEligibilityStatusElem = []interface{}{
	"completion_rate",
	"country",
	"join_date",
	"rating_average",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespP2PAdvertInfoEligibilityStatusElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertInfoRespP2PAdvertInfoEligibilityStatusElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertInfoRespP2PAdvertInfoEligibilityStatusElem, v)
	}
	*j = P2PAdvertInfoRespP2PAdvertInfoEligibilityStatusElem(v)
	return nil
}

const P2PAdvertInfoRespP2PAdvertInfoEligibilityStatusElemCompletionRate P2PAdvertInfoRespP2PAdvertInfoEligibilityStatusElem = "completion_rate"
const P2PAdvertInfoRespP2PAdvertInfoEligibilityStatusElemCountry P2PAdvertInfoRespP2PAdvertInfoEligibilityStatusElem = "country"
const P2PAdvertInfoRespP2PAdvertInfoEligibilityStatusElemJoinDate P2PAdvertInfoRespP2PAdvertInfoEligibilityStatusElem = "join_date"
const P2PAdvertInfoRespP2PAdvertInfoEligibilityStatusElemRatingAverage P2PAdvertInfoRespP2PAdvertInfoEligibilityStatusElem = "rating_average"

type P2PAdvertInfoRespP2PAdvertInfoIsActive int

var enumValues_P2PAdvertInfoRespP2PAdvertInfoIsActive = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespP2PAdvertInfoIsActive) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertInfoRespP2PAdvertInfoIsActive {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertInfoRespP2PAdvertInfoIsActive, v)
	}
	*j = P2PAdvertInfoRespP2PAdvertInfoIsActive(v)
	return nil
}

type P2PAdvertInfoRespP2PAdvertInfoIsEligible int

var enumValues_P2PAdvertInfoRespP2PAdvertInfoIsEligible = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespP2PAdvertInfoIsEligible) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertInfoRespP2PAdvertInfoIsEligible {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertInfoRespP2PAdvertInfoIsEligible, v)
	}
	*j = P2PAdvertInfoRespP2PAdvertInfoIsEligible(v)
	return nil
}

type P2PAdvertInfoRespP2PAdvertInfoIsVisible int

var enumValues_P2PAdvertInfoRespP2PAdvertInfoIsVisible = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespP2PAdvertInfoIsVisible) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertInfoRespP2PAdvertInfoIsVisible {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertInfoRespP2PAdvertInfoIsVisible, v)
	}
	*j = P2PAdvertInfoRespP2PAdvertInfoIsVisible(v)
	return nil
}

// Details of available payment methods (sell adverts only).
type P2PAdvertInfoRespP2PAdvertInfoPaymentMethodDetails map[string]interface{}

type P2PAdvertInfoRespP2PAdvertInfoRateType string

var enumValues_P2PAdvertInfoRespP2PAdvertInfoRateType = []interface{}{
	"fixed",
	"float",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespP2PAdvertInfoRateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertInfoRespP2PAdvertInfoRateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertInfoRespP2PAdvertInfoRateType, v)
	}
	*j = P2PAdvertInfoRespP2PAdvertInfoRateType(v)
	return nil
}

const P2PAdvertInfoRespP2PAdvertInfoRateTypeFixed P2PAdvertInfoRespP2PAdvertInfoRateType = "fixed"
const P2PAdvertInfoRespP2PAdvertInfoRateTypeFloat P2PAdvertInfoRespP2PAdvertInfoRateType = "float"

type P2PAdvertInfoRespP2PAdvertInfoType string

var enumValues_P2PAdvertInfoRespP2PAdvertInfoType = []interface{}{
	"buy",
	"sell",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespP2PAdvertInfoType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertInfoRespP2PAdvertInfoType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertInfoRespP2PAdvertInfoType, v)
	}
	*j = P2PAdvertInfoRespP2PAdvertInfoType(v)
	return nil
}

const P2PAdvertInfoRespP2PAdvertInfoTypeBuy P2PAdvertInfoRespP2PAdvertInfoType = "buy"
const P2PAdvertInfoRespP2PAdvertInfoTypeSell P2PAdvertInfoRespP2PAdvertInfoType = "sell"

type P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem string

var enumValues_P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem = []interface{}{
	"advert_inactive",
	"advert_max_limit",
	"advert_min_limit",
	"advert_remaining",
	"advertiser_ads_paused",
	"advertiser_approval",
	"advertiser_balance",
	"advertiser_block_trade_ineligible",
	"advertiser_daily_limit",
	"advertiser_temp_ban",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem, v)
	}
	*j = P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem(v)
	return nil
}

// P2P advert information.
type P2PAdvertInfoRespP2PAdvertInfo struct {
	// Currency for this advert. This is the system currency to be transferred between
	// advertiser and client.
	AccountCurrency *string `json:"account_currency,omitempty"`

	// The number of active orders against this advert.
	ActiveOrders *int `json:"active_orders,omitempty"`

	// Details of the advertiser for this advert.
	AdvertiserDetails *P2PAdvertInfoRespP2PAdvertInfoAdvertiserDetails `json:"advertiser_details,omitempty"`

	// The total amount specified in advert, in `account_currency`. It is only visible
	// to the advert owner.
	Amount *float64 `json:"amount,omitempty"`

	// The total amount specified in advert, in `account_currency`, formatted to
	// appropriate decimal places. It is only visible to the advert owner.
	AmountDisplay *string `json:"amount_display,omitempty"`

	// Indicates if this is block trade advert or not.
	BlockTrade *P2PAdvertInfoRespP2PAdvertInfoBlockTrade `json:"block_trade,omitempty"`

	// Advertiser contact information. Only applicable for 'sell adverts'.
	ContactInfo *string `json:"contact_info,omitempty"`

	// Type of transaction from the opposite party's perspective.
	CounterpartyType *P2PAdvertInfoRespP2PAdvertInfoCounterpartyType `json:"counterparty_type,omitempty"`

	// The target country code of the advert.
	Country *string `json:"country,omitempty"`

	// The advert creation time in epoch.
	CreatedTime *int `json:"created_time,omitempty"`

	// Days until automatic inactivation of this ad, if no activity occurs.
	DaysUntilArchive *int `json:"days_until_archive,omitempty"`

	// Indicates that the advert has been deleted.
	Deleted *P2PAdvertInfoRespP2PAdvertInfoDeleted `json:"deleted,omitempty"`

	// General information about the advert.
	Description *string `json:"description,omitempty"`

	// Conversion rate from account currency to local currency, using current market
	// rate if applicable.
	EffectiveRate *float64 `json:"effective_rate,omitempty"`

	// Conversion rate from account currency to local currency, using current market
	// rate if applicable, formatted to appropriate decimal places.
	EffectiveRateDisplay *string `json:"effective_rate_display,omitempty"`

	// Reasons why the counterparty terms do not allow the current user to place
	// orders against this advert. Possible values:
	// - `completion_rate`: current user's 30 day completion rate is less than
	// `min_completion_rate`.
	// - `country`: current user's residence is not in `eligible_countries`.
	// - `join_date`: current user registered on P2P less than `min_join_days` in the
	// past.
	// - `rating`: current user's average review rating is less than `min_rating`.
	EligibilityStatus []P2PAdvertInfoRespP2PAdvertInfoEligibilityStatusElem `json:"eligibility_status,omitempty"`

	// 2 letter country codes. Counterparties who do not live in these countries are
	// not allowed to place orders against this advert.
	EligibleCountries []string `json:"eligible_countries,omitempty"`

	// The unique identifier for this advert.
	Id *string `json:"id,omitempty"`

	// The activation status of the advert.
	IsActive *P2PAdvertInfoRespP2PAdvertInfoIsActive `json:"is_active,omitempty"`

	// Indicates that the current user meets the counterparty terms for placing orders
	// against this advert.
	IsEligible P2PAdvertInfoRespP2PAdvertInfoIsEligible `json:"is_eligible,omitempty"`

	// Indicates that this advert will appear on the main advert list. It is only
	// visible to the advert owner.
	IsVisible P2PAdvertInfoRespP2PAdvertInfoIsVisible `json:"is_visible,omitempty"`

	// Local currency for this advert. This is the form of payment to be arranged
	// directly between advertiser and client.
	LocalCurrency *string `json:"local_currency,omitempty"`

	// Maximum order amount specified in advert, in `account_currency`. It is only
	// visible for advertisers.
	MaxOrderAmount *float64 `json:"max_order_amount,omitempty"`

	// Maximum order amount specified in advert, in `account_currency`, formatted to
	// appropriate decimal places. It is only visible to the advert owner.
	MaxOrderAmountDisplay *string `json:"max_order_amount_display,omitempty"`

	// Maximum order amount at this time, in `account_currency`.
	MaxOrderAmountLimit *float64 `json:"max_order_amount_limit,omitempty"`

	// Maximum order amount at this time, in `account_currency`, formatted to
	// appropriate decimal places.
	MaxOrderAmountLimitDisplay *string `json:"max_order_amount_limit_display,omitempty"`

	// Counterparties who have a 30 day completion rate less than this value are not
	// allowed to place orders against this advert.
	MinCompletionRate *float64 `json:"min_completion_rate,omitempty"`

	// Counterparties who joined less than this number of days ago are not allowed to
	// place orders against this advert.
	MinJoinDays *int `json:"min_join_days,omitempty"`

	// Minimum order amount specified in advert, in `account_currency`. It is only
	// visible for advertisers.
	MinOrderAmount *float64 `json:"min_order_amount,omitempty"`

	// Minimum order amount specified in advert, in `account_currency`, formatted to
	// appropriate decimal places. It is only visible to the advert owner.
	MinOrderAmountDisplay *string `json:"min_order_amount_display,omitempty"`

	// Minimum order amount at this time, in `account_currency`.
	MinOrderAmountLimit *float64 `json:"min_order_amount_limit,omitempty"`

	// Minimum order amount at this time, in `account_currency`, formatted to
	// appropriate decimal places.
	MinOrderAmountLimitDisplay *string `json:"min_order_amount_limit_display,omitempty"`

	// Counterparties who have an average rating less than this value are not allowed
	// to place orders against this advert.
	MinRating *float64 `json:"min_rating,omitempty"`

	// Expiry period (seconds) for order created against this ad.
	OrderExpiryPeriod *int `json:"order_expiry_period,omitempty"`

	// Payment instructions. Only applicable for 'sell adverts'.
	PaymentInfo *string `json:"payment_info,omitempty"`

	// Payment method name (deprecated).
	PaymentMethod *string `json:"payment_method,omitempty"`

	// Details of available payment methods (sell adverts only).
	PaymentMethodDetails P2PAdvertInfoRespP2PAdvertInfoPaymentMethodDetails `json:"payment_method_details,omitempty"`

	// Names of supported payment methods.
	PaymentMethodNames []string `json:"payment_method_names,omitempty"`

	// Cost of the advert in local currency.
	Price *float64 `json:"price,omitempty"`

	// Cost of the advert in local currency, formatted to appropriate decimal places.
	PriceDisplay *string `json:"price_display,omitempty"`

	// Conversion rate from advertiser's account currency to `local_currency`. An
	// absolute rate value (fixed), or percentage offset from current market rate
	// (floating).
	Rate *float64 `json:"rate,omitempty"`

	// Conversion rate formatted to appropriate decimal places.
	RateDisplay *string `json:"rate_display,omitempty"`

	// Type of rate, fixed or floating.
	RateType *P2PAdvertInfoRespP2PAdvertInfoRateType `json:"rate_type,omitempty"`

	// Amount currently available for orders, in `account_currency`. It is only
	// visible for advertisers.
	RemainingAmount *float64 `json:"remaining_amount,omitempty"`

	// Amount currently available for orders, in `account_currency`, formatted to
	// appropriate decimal places. It is only visible to the advert owner.
	RemainingAmountDisplay *string `json:"remaining_amount_display,omitempty"`

	// Whether this is a buy or a sell.
	Type *P2PAdvertInfoRespP2PAdvertInfoType `json:"type,omitempty"`

	// Reasons why an advert is not visible, only visible to the advert owner.
	// Possible values:
	// - `advert_inactive`: the advert is set inactive.
	// - `advert_max_limit`: the minimum order amount exceeds the system maximum
	// order.
	// - `advert_min_limit`: the maximum order amount is too small to be shown on the
	// advert list.
	// - `advert_remaining`: the remaining amount of the advert is below the minimum
	// order.
	// - `advertiser_ads_paused`: the advertiser has paused all adverts.
	// - `advertiser_approval`: the advertiser's proof of identity is not verified.
	// - `advertiser_balance`: the advertiser's P2P balance is less than the minimum
	// order.
	// - `advertiser_block_trade_ineligible`: the advertiser is not currently eligible
	// for block trading.
	// - `advertiser_daily_limit`: the advertiser's remaining daily limit is less than
	// the minimum order.
	// - `advertiser_temp_ban`: the advertiser is temporarily banned from P2P.
	VisibilityStatus []P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem `json:"visibility_status,omitempty"`
}

const P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElemAdvertInactive P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem = "advert_inactive"
const P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElemAdvertMaxLimit P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem = "advert_max_limit"
const P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElemAdvertMinLimit P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem = "advert_min_limit"
const P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElemAdvertRemaining P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem = "advert_remaining"
const P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElemAdvertiserAdsPaused P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem = "advertiser_ads_paused"
const P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElemAdvertiserApproval P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem = "advertiser_approval"
const P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElemAdvertiserBalance P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem = "advertiser_balance"
const P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElemAdvertiserBlockTradeIneligible P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem = "advertiser_block_trade_ineligible"
const P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElemAdvertiserDailyLimit P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem = "advertiser_daily_limit"
const P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElemAdvertiserTempBan P2PAdvertInfoRespP2PAdvertInfoVisibilityStatusElem = "advertiser_temp_ban"

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespP2PAdvertInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain P2PAdvertInfoRespP2PAdvertInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["is_eligible"]; !ok || v == nil {
		plain.IsEligible = 0.0
	}
	if v, ok := raw["is_visible"]; !ok || v == nil {
		plain.IsVisible = 0.0
	}
	*j = P2PAdvertInfoRespP2PAdvertInfo(plain)
	return nil
}

// For subscription requests only.
type P2PAdvertInfoRespSubscription struct {
	// A per-connection unique identifier. Can be passed to the `forget` API call to
	// unsubscribe.
	Id string `json:"id"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoRespSubscription) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id in P2PAdvertInfoRespSubscription: required")
	}
	type Plain P2PAdvertInfoRespSubscription
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertInfoRespSubscription(plain)
	return nil
}

// Returns information about the given advert ID.
type P2PAdvertInfoResp struct {
	// Echo of the request made.
	EchoReq P2PAdvertInfoRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType P2PAdvertInfoRespMsgType `json:"msg_type"`

	// P2P advert information.
	P2PAdvertInfo *P2PAdvertInfoRespP2PAdvertInfo `json:"p2p_advert_info,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// For subscription requests only.
	Subscription *P2PAdvertInfoRespSubscription `json:"subscription,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertInfoResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req in P2PAdvertInfoResp: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type in P2PAdvertInfoResp: required")
	}
	type Plain P2PAdvertInfoResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertInfoResp(plain)
	return nil
}
