// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import "reflect"

// A message with Residence List
type ResidenceListResp struct {
	// Echo of the request made.
	EchoReq ResidenceListRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType ResidenceListRespMsgType `json:"msg_type"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// List of countries for account opening
	ResidenceList []ResidenceListRespResidenceListElem `json:"residence_list,omitempty"`
}

// Echo of the request made.
type ResidenceListRespEchoReq map[string]interface{}

type ResidenceListRespMsgType string

const ResidenceListRespMsgTypeResidenceList ResidenceListRespMsgType = "residence_list"

var enumValues_ResidenceListRespMsgType = []interface{}{
	"residence_list",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResidenceListRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ResidenceListRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ResidenceListRespMsgType, v)
	}
	*j = ResidenceListRespMsgType(v)
	return nil
}

type ResidenceListRespResidenceListElem struct {
	// Flag which indicates whether self declaration is required for account opening
	AccountOpeningSelfDeclarationRequired *ResidenceListRespResidenceListElemAccountOpeningSelfDeclarationRequired `json:"account_opening_self_declaration_required,omitempty"`

	// Disabled.
	Disabled *string `json:"disabled,omitempty"`

	// Information about identity options available
	Identity *ResidenceListRespResidenceListElemIdentity `json:"identity,omitempty"`

	// IDD code of country
	PhoneIdd *string `json:"phone_idd,omitempty"`

	// Selected.
	Selected *string `json:"selected,omitempty"`

	// Country full name
	Text *string `json:"text,omitempty"`

	// Country tax identifier format
	TinFormat []string `json:"tin_format,omitempty"`

	// 2-letter country code
	Value *string `json:"value,omitempty"`

	// Flag which indicates whether wallet signup is available in this country
	WalletSignup *ResidenceListRespResidenceListElemWalletSignup `json:"wallet_signup,omitempty"`
}

type ResidenceListRespResidenceListElemAccountOpeningSelfDeclarationRequired int

var enumValues_ResidenceListRespResidenceListElemAccountOpeningSelfDeclarationRequired = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResidenceListRespResidenceListElemAccountOpeningSelfDeclarationRequired) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ResidenceListRespResidenceListElemAccountOpeningSelfDeclarationRequired {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ResidenceListRespResidenceListElemAccountOpeningSelfDeclarationRequired, v)
	}
	*j = ResidenceListRespResidenceListElemAccountOpeningSelfDeclarationRequired(v)
	return nil
}

// Information about identity options available
type ResidenceListRespResidenceListElemIdentity struct {
	// Identity services configuration
	Services *ResidenceListRespResidenceListElemIdentityServices `json:"services,omitempty"`
}

// Identity services configuration
type ResidenceListRespResidenceListElemIdentityServices struct {
	// IDV configuration
	Idv *ResidenceListRespResidenceListElemIdentityServicesIdv `json:"idv,omitempty"`

	// Onfido configuration
	Onfido *ResidenceListRespResidenceListElemIdentityServicesOnfido `json:"onfido,omitempty"`
}

// IDV configuration
type ResidenceListRespResidenceListElemIdentityServicesIdv struct {
	// Documents supported by the IDV service in this country
	DocumentsSupported ResidenceListRespResidenceListElemIdentityServicesIdvDocumentsSupported `json:"documents_supported,omitempty"`

	// Flag which indicates whether this country has IDV visual samples
	HasVisualSample *ResidenceListRespResidenceListElemIdentityServicesIdvHasVisualSample `json:"has_visual_sample,omitempty"`

	// Flag which indicates whether IDV is available in this country
	IsCountrySupported *ResidenceListRespResidenceListElemIdentityServicesIdvIsCountrySupported `json:"is_country_supported,omitempty"`
}

// Documents supported by the IDV service in this country
type ResidenceListRespResidenceListElemIdentityServicesIdvDocumentsSupported map[string]interface{}

type ResidenceListRespResidenceListElemIdentityServicesIdvHasVisualSample int

var enumValues_ResidenceListRespResidenceListElemIdentityServicesIdvHasVisualSample = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResidenceListRespResidenceListElemIdentityServicesIdvHasVisualSample) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ResidenceListRespResidenceListElemIdentityServicesIdvHasVisualSample {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ResidenceListRespResidenceListElemIdentityServicesIdvHasVisualSample, v)
	}
	*j = ResidenceListRespResidenceListElemIdentityServicesIdvHasVisualSample(v)
	return nil
}

type ResidenceListRespResidenceListElemIdentityServicesIdvIsCountrySupported int

var enumValues_ResidenceListRespResidenceListElemIdentityServicesIdvIsCountrySupported = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResidenceListRespResidenceListElemIdentityServicesIdvIsCountrySupported) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ResidenceListRespResidenceListElemIdentityServicesIdvIsCountrySupported {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ResidenceListRespResidenceListElemIdentityServicesIdvIsCountrySupported, v)
	}
	*j = ResidenceListRespResidenceListElemIdentityServicesIdvIsCountrySupported(v)
	return nil
}

// Onfido configuration
type ResidenceListRespResidenceListElemIdentityServicesOnfido struct {
	// Documents supported by the IDV service in this country
	DocumentsSupported ResidenceListRespResidenceListElemIdentityServicesOnfidoDocumentsSupported `json:"documents_supported,omitempty"`

	// Flag which indicates whether Onfido is available in this country
	IsCountrySupported *ResidenceListRespResidenceListElemIdentityServicesOnfidoIsCountrySupported `json:"is_country_supported,omitempty"`
}

// Documents supported by the IDV service in this country
type ResidenceListRespResidenceListElemIdentityServicesOnfidoDocumentsSupported map[string]interface{}

type ResidenceListRespResidenceListElemIdentityServicesOnfidoIsCountrySupported int

var enumValues_ResidenceListRespResidenceListElemIdentityServicesOnfidoIsCountrySupported = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResidenceListRespResidenceListElemIdentityServicesOnfidoIsCountrySupported) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ResidenceListRespResidenceListElemIdentityServicesOnfidoIsCountrySupported {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ResidenceListRespResidenceListElemIdentityServicesOnfidoIsCountrySupported, v)
	}
	*j = ResidenceListRespResidenceListElemIdentityServicesOnfidoIsCountrySupported(v)
	return nil
}

type ResidenceListRespResidenceListElemWalletSignup int

var enumValues_ResidenceListRespResidenceListElemWalletSignup = []interface{}{
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResidenceListRespResidenceListElemWalletSignup) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ResidenceListRespResidenceListElemWalletSignup {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ResidenceListRespResidenceListElemWalletSignup, v)
	}
	*j = ResidenceListRespResidenceListElemWalletSignup(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResidenceListResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["echo_req"]; raw != nil && !ok {
		return fmt.Errorf("field echo_req in ResidenceListResp: required")
	}
	if _, ok := raw["msg_type"]; raw != nil && !ok {
		return fmt.Errorf("field msg_type in ResidenceListResp: required")
	}
	type Plain ResidenceListResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ResidenceListResp(plain)
	return nil
}
