// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "encoding/json"
import "fmt"
import "reflect"

// Echo of the request made.
type P2PAdvertCreateRespEchoReq map[string]interface{}

type P2PAdvertCreateRespMsgType string

var enumValues_P2PAdvertCreateRespMsgType = []interface{}{
	"p2p_advert_create",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreateRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertCreateRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertCreateRespMsgType, v)
	}
	*j = P2PAdvertCreateRespMsgType(v)
	return nil
}

const P2PAdvertCreateRespMsgTypeP2PAdvertCreate P2PAdvertCreateRespMsgType = "p2p_advert_create"

type P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetailsIsOnline int

var enumValues_P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetailsIsOnline = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetailsIsOnline) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetailsIsOnline {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetailsIsOnline, v)
	}
	*j = P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetailsIsOnline(v)
	return nil
}

// Details of the advertiser for this advert.
type P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetails struct {
	// The total number of orders completed in the past 30 days.
	CompletedOrdersCount int `json:"completed_orders_count"`

	// The advertiser's first name.
	FirstName *string `json:"first_name,omitempty"`

	// The advertiser's unique identifier.
	Id string `json:"id"`

	// Indicates if the advertiser is currently online.
	IsOnline P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetailsIsOnline `json:"is_online"`

	// The advertiser's last name.
	LastName *string `json:"last_name,omitempty"`

	// Epoch of the latest time the advertiser was online, up to 6 months.
	LastOnlineTime *int `json:"last_online_time"`

	// The advertiser's displayed name.
	Name string `json:"name"`

	// Average rating of the advertiser, range is 1-5.
	RatingAverage *float64 `json:"rating_average"`

	// Number of ratings given to the advertiser.
	RatingCount int `json:"rating_count"`

	// Percentage of users who have recommended the advertiser.
	RecommendedAverage *float64 `json:"recommended_average"`

	// Number of times the advertiser has been recommended.
	RecommendedCount *int `json:"recommended_count"`

	// The percentage of successfully completed orders made by or placed against the
	// advertiser within the past 30 days.
	TotalCompletionRate *float64 `json:"total_completion_rate"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetails) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["completed_orders_count"]; !ok || v == nil {
		return fmt.Errorf("field completed_orders_count in P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetails: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id in P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetails: required")
	}
	if v, ok := raw["is_online"]; !ok || v == nil {
		return fmt.Errorf("field is_online in P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetails: required")
	}
	if v, ok := raw["last_online_time"]; !ok || v == nil {
		return fmt.Errorf("field last_online_time in P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetails: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetails: required")
	}
	if v, ok := raw["rating_average"]; !ok || v == nil {
		return fmt.Errorf("field rating_average in P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetails: required")
	}
	if v, ok := raw["rating_count"]; !ok || v == nil {
		return fmt.Errorf("field rating_count in P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetails: required")
	}
	if v, ok := raw["recommended_average"]; !ok || v == nil {
		return fmt.Errorf("field recommended_average in P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetails: required")
	}
	if v, ok := raw["recommended_count"]; !ok || v == nil {
		return fmt.Errorf("field recommended_count in P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetails: required")
	}
	if v, ok := raw["total_completion_rate"]; !ok || v == nil {
		return fmt.Errorf("field total_completion_rate in P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetails: required")
	}
	type Plain P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetails
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetails(plain)
	return nil
}

type P2PAdvertCreateRespP2PAdvertCreateBlockTrade int

var enumValues_P2PAdvertCreateRespP2PAdvertCreateBlockTrade = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreateRespP2PAdvertCreateBlockTrade) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertCreateRespP2PAdvertCreateBlockTrade {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertCreateRespP2PAdvertCreateBlockTrade, v)
	}
	*j = P2PAdvertCreateRespP2PAdvertCreateBlockTrade(v)
	return nil
}

type P2PAdvertCreateRespP2PAdvertCreateCounterpartyType string

var enumValues_P2PAdvertCreateRespP2PAdvertCreateCounterpartyType = []interface{}{
	"buy",
	"sell",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreateRespP2PAdvertCreateCounterpartyType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertCreateRespP2PAdvertCreateCounterpartyType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertCreateRespP2PAdvertCreateCounterpartyType, v)
	}
	*j = P2PAdvertCreateRespP2PAdvertCreateCounterpartyType(v)
	return nil
}

const P2PAdvertCreateRespP2PAdvertCreateCounterpartyTypeBuy P2PAdvertCreateRespP2PAdvertCreateCounterpartyType = "buy"
const P2PAdvertCreateRespP2PAdvertCreateCounterpartyTypeSell P2PAdvertCreateRespP2PAdvertCreateCounterpartyType = "sell"

type P2PAdvertCreateRespP2PAdvertCreateIsActive int

var enumValues_P2PAdvertCreateRespP2PAdvertCreateIsActive = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreateRespP2PAdvertCreateIsActive) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertCreateRespP2PAdvertCreateIsActive {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertCreateRespP2PAdvertCreateIsActive, v)
	}
	*j = P2PAdvertCreateRespP2PAdvertCreateIsActive(v)
	return nil
}

type P2PAdvertCreateRespP2PAdvertCreateIsVisible int

var enumValues_P2PAdvertCreateRespP2PAdvertCreateIsVisible = []interface{}{
	0,
	1,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreateRespP2PAdvertCreateIsVisible) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertCreateRespP2PAdvertCreateIsVisible {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertCreateRespP2PAdvertCreateIsVisible, v)
	}
	*j = P2PAdvertCreateRespP2PAdvertCreateIsVisible(v)
	return nil
}

type P2PAdvertCreateRespP2PAdvertCreateOrderExpiryPeriod int

var enumValues_P2PAdvertCreateRespP2PAdvertCreateOrderExpiryPeriod = []interface{}{
	900,
	1800,
	2700,
	3600,
	5400,
	7200,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreateRespP2PAdvertCreateOrderExpiryPeriod) UnmarshalJSON(b []byte) error {
	var v int
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertCreateRespP2PAdvertCreateOrderExpiryPeriod {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertCreateRespP2PAdvertCreateOrderExpiryPeriod, v)
	}
	*j = P2PAdvertCreateRespP2PAdvertCreateOrderExpiryPeriod(v)
	return nil
}

// Details of available payment methods (sell adverts only).
type P2PAdvertCreateRespP2PAdvertCreatePaymentMethodDetails map[string]interface{}

type P2PAdvertCreateRespP2PAdvertCreateRateType string

var enumValues_P2PAdvertCreateRespP2PAdvertCreateRateType = []interface{}{
	"fixed",
	"float",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreateRespP2PAdvertCreateRateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertCreateRespP2PAdvertCreateRateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertCreateRespP2PAdvertCreateRateType, v)
	}
	*j = P2PAdvertCreateRespP2PAdvertCreateRateType(v)
	return nil
}

const P2PAdvertCreateRespP2PAdvertCreateRateTypeFixed P2PAdvertCreateRespP2PAdvertCreateRateType = "fixed"
const P2PAdvertCreateRespP2PAdvertCreateRateTypeFloat P2PAdvertCreateRespP2PAdvertCreateRateType = "float"

type P2PAdvertCreateRespP2PAdvertCreateType string

var enumValues_P2PAdvertCreateRespP2PAdvertCreateType = []interface{}{
	"buy",
	"sell",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreateRespP2PAdvertCreateType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertCreateRespP2PAdvertCreateType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertCreateRespP2PAdvertCreateType, v)
	}
	*j = P2PAdvertCreateRespP2PAdvertCreateType(v)
	return nil
}

const P2PAdvertCreateRespP2PAdvertCreateTypeBuy P2PAdvertCreateRespP2PAdvertCreateType = "buy"
const P2PAdvertCreateRespP2PAdvertCreateTypeSell P2PAdvertCreateRespP2PAdvertCreateType = "sell"

type P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem string

var enumValues_P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem = []interface{}{
	"advert_inactive",
	"advert_max_limit",
	"advert_min_limit",
	"advert_remaining",
	"advertiser_ads_paused",
	"advertiser_approval",
	"advertiser_balance",
	"advertiser_block_trade_ineligible",
	"advertiser_daily_limit",
	"advertiser_temp_ban",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem, v)
	}
	*j = P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem(v)
	return nil
}

// The information of the created P2P advert.
type P2PAdvertCreateRespP2PAdvertCreate struct {
	// Currency for this advert. This is the system currency to be transferred between
	// advertiser and client.
	AccountCurrency string `json:"account_currency"`

	// The number of active orders against this advert.
	ActiveOrders int `json:"active_orders"`

	// Details of the advertiser for this advert.
	AdvertiserDetails P2PAdvertCreateRespP2PAdvertCreateAdvertiserDetails `json:"advertiser_details"`

	// The total amount specified in advert, in `account_currency`.
	Amount float64 `json:"amount"`

	// The total amount specified in advert, in `account_currency`, formatted to
	// appropriate decimal places.
	AmountDisplay string `json:"amount_display"`

	// Indicates if this is block trade advert or not.
	BlockTrade P2PAdvertCreateRespP2PAdvertCreateBlockTrade `json:"block_trade"`

	// Advertiser contact information. Only applicable for 'sell adverts'.
	ContactInfo *string `json:"contact_info,omitempty"`

	// Type of transaction from the opposite party's perspective.
	CounterpartyType P2PAdvertCreateRespP2PAdvertCreateCounterpartyType `json:"counterparty_type"`

	// The target country code of the advert.
	Country string `json:"country"`

	// The advert creation time in epoch.
	CreatedTime int `json:"created_time"`

	// General information about the advert.
	Description string `json:"description"`

	// Conversion rate from account currency to local currency, using current market
	// rate if applicable.
	EffectiveRate *float64 `json:"effective_rate"`

	// Conversion rate from account currency to local currency, using current market
	// rate if applicable, formatted to appropriate decimal places.
	EffectiveRateDisplay *string `json:"effective_rate_display"`

	// The unique identifier for this advert.
	Id string `json:"id"`

	// The activation status of the advert.
	IsActive P2PAdvertCreateRespP2PAdvertCreateIsActive `json:"is_active"`

	// Indicates that this advert will appear on the main advert list.
	IsVisible P2PAdvertCreateRespP2PAdvertCreateIsVisible `json:"is_visible"`

	// Local currency for this advert. This is the form of payment to be arranged
	// directly between advertiser and client.
	LocalCurrency string `json:"local_currency"`

	// Maximum order amount specified in advert, in `account_currency`.
	MaxOrderAmount float64 `json:"max_order_amount"`

	// Maximum order amount specified in advert, in `account_currency`, formatted to
	// appropriate decimal places.
	MaxOrderAmountDisplay string `json:"max_order_amount_display"`

	// Maximum order amount at this time, in `account_currency`.
	MaxOrderAmountLimit float64 `json:"max_order_amount_limit"`

	// Maximum order amount at this time, in `account_currency`, formatted to
	// appropriate decimal places.
	MaxOrderAmountLimitDisplay string `json:"max_order_amount_limit_display"`

	// Minimum order amount specified in advert, in `account_currency`.
	MinOrderAmount float64 `json:"min_order_amount"`

	// Minimum order amount specified in advert, in `account_currency`, formatted to
	// appropriate decimal places.
	MinOrderAmountDisplay string `json:"min_order_amount_display"`

	// Minimum order amount at this time, in `account_currency`.
	MinOrderAmountLimit float64 `json:"min_order_amount_limit"`

	// Minimum order amount at this time, in `account_currency`, formatted to
	// appropriate decimal places.
	MinOrderAmountLimitDisplay string `json:"min_order_amount_limit_display"`

	// Expiry period (seconds) for order created against this ad.
	OrderExpiryPeriod P2PAdvertCreateRespP2PAdvertCreateOrderExpiryPeriod `json:"order_expiry_period"`

	// Payment instructions. Only applicable for 'sell adverts'.
	PaymentInfo *string `json:"payment_info,omitempty"`

	// Payment method name (deprecated).
	PaymentMethod *string `json:"payment_method"`

	// Details of available payment methods (sell adverts only).
	PaymentMethodDetails P2PAdvertCreateRespP2PAdvertCreatePaymentMethodDetails `json:"payment_method_details,omitempty"`

	// Names of supported payment methods.
	PaymentMethodNames []string `json:"payment_method_names,omitempty"`

	// Cost of the advert in local currency.
	Price *float64 `json:"price"`

	// Cost of the advert in local currency, formatted to appropriate decimal places.
	PriceDisplay *string `json:"price_display"`

	// Conversion rate from advertiser's account currency to `local_currency`. An
	// absolute rate value (fixed), or percentage offset from current market rate
	// (floating).
	Rate float64 `json:"rate"`

	// Conversion rate formatted to appropriate decimal places.
	RateDisplay string `json:"rate_display"`

	// Type of rate, fixed or floating.
	RateType P2PAdvertCreateRespP2PAdvertCreateRateType `json:"rate_type"`

	// Amount currently available for orders, in `account_currency`.
	RemainingAmount float64 `json:"remaining_amount"`

	// Amount currently available for orders, in `account_currency`, formatted to
	// appropriate decimal places.
	RemainingAmountDisplay string `json:"remaining_amount_display"`

	// The type of advertisement in relation to the advertiser's Deriv account.
	Type P2PAdvertCreateRespP2PAdvertCreateType `json:"type"`

	// Reasons why an advert is not visible. Possible values:
	// - `advert_inactive`: the advert is set inactive.
	// - `advert_max_limit`: the minimum order amount exceeds the system maximum
	// order.
	// - `advert_min_limit`: the maximum order amount is too small to be shown on the
	// advert list.
	// - `advert_remaining`: the remaining amount of the advert is below the minimum
	// order.
	// - `advertiser_ads_paused`: the advertiser has paused all adverts.
	// - `advertiser_approval`: the advertiser's proof of identity is not verified.
	// - `advertiser_balance`: the advertiser's P2P balance is less than the minimum
	// order.
	// - `advertiser_block_trade_ineligible`: the advertiser is not currently eligible
	// for block trading.
	// - `advertiser_daily_limit`: the advertiser's remaining daily limit is less than
	// the minimum order.
	// - `advertiser_temp_ban`: the advertiser is temporarily banned from P2P.
	VisibilityStatus []P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem `json:"visibility_status,omitempty"`
}

const P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElemAdvertInactive P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem = "advert_inactive"
const P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElemAdvertMaxLimit P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem = "advert_max_limit"
const P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElemAdvertMinLimit P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem = "advert_min_limit"
const P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElemAdvertRemaining P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem = "advert_remaining"
const P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElemAdvertiserAdsPaused P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem = "advertiser_ads_paused"
const P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElemAdvertiserApproval P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem = "advertiser_approval"
const P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElemAdvertiserBalance P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem = "advertiser_balance"
const P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElemAdvertiserBlockTradeIneligible P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem = "advertiser_block_trade_ineligible"
const P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElemAdvertiserDailyLimit P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem = "advertiser_daily_limit"
const P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElemAdvertiserTempBan P2PAdvertCreateRespP2PAdvertCreateVisibilityStatusElem = "advertiser_temp_ban"

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreateRespP2PAdvertCreate) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["account_currency"]; !ok || v == nil {
		return fmt.Errorf("field account_currency in P2PAdvertCreateRespP2PAdvertCreate: required")
	}
	if v, ok := raw["active_orders"]; !ok || v == nil {
		return fmt.Errorf("field active_orders in P2PAdvertCreateRespP2PAdvertCreate: required")
	}
	if v, ok := raw["advertiser_details"]; !ok || v == nil {
		return fmt.Errorf("field advertiser_details in P2PAdvertCreateRespP2PAdvertCreate: required")
	}
	if v, ok := raw["amount"]; !ok || v == nil {
		return fmt.Errorf("field amount in P2PAdvertCreateRespP2PAdvertCreate: required")
	}
	if v, ok := raw["amount_display"]; !ok || v == nil {
		return fmt.Errorf("field amount_display in P2PAdvertCreateRespP2PAdvertCreate: required")
	}
	if v, ok := raw["block_trade"]; !ok || v == nil {
		return fmt.Errorf("field block_trade in P2PAdvertCreateRespP2PAdvertCreate: required")
	}
	if v, ok := raw["counterparty_type"]; !ok || v == nil {
		return fmt.Errorf("field counterparty_type in P2PAdvertCreateRespP2PAdvertCreate: required")
	}
	if v, ok := raw["country"]; !ok || v == nil {
		return fmt.Errorf("field country in P2PAdvertCreateRespP2PAdvertCreate: required")
	}
	if v, ok := raw["created_time"]; !ok || v == nil {
		return fmt.Errorf("field created_time in P2PAdvertCreateRespP2PAdvertCreate: required")
	}
	if v, ok := raw["description"]; !ok || v == nil {
		return fmt.Errorf("field description in P2PAdvertCreateRespP2PAdvertCreate: required")
	}
	if v, ok := raw["effective_rate"]; !ok || v == nil {
		return fmt.Errorf("field effective_rate in P2PAdvertCreateRespP2PAdvertCreate: required")
	}
	if v, ok := raw["effective_rate_display"]; !ok || v == nil {
		return fmt.Errorf("field effective_rate_display in P2PAdvertCreateRespP2PAdvertCreate: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id in P2PAdvertCreateRespP2PAdvertCreate: required")
	}
	if v, ok := raw["is_active"]; !ok || v == nil {
		return fmt.Errorf("field is_active in P2PAdvertCreateRespP2PAdvertCreate: required")
	}
	if v, ok := raw["local_currency"]; !ok || v == nil {
		return fmt.Errorf("field local_currency in P2PAdvertCreateRespP2PAdvertCreate: required")
	}
	if v, ok := raw["max_order_amount"]; !ok || v == nil {
		return fmt.Errorf("field max_order_amount in P2PAdvertCreateRespP2PAdvertCreate: required")
	}
	if v, ok := raw["max_order_amount_display"]; !ok || v == nil {
		return fmt.Errorf("field max_order_amount_display in P2PAdvertCreateRespP2PAdvertCreate: required")
	}
	if v, ok := raw["max_order_amount_limit"]; !ok || v == nil {
		return fmt.Errorf("field max_order_amount_limit in P2PAdvertCreateRespP2PAdvertCreate: required")
	}
	if v, ok := raw["max_order_amount_limit_display"]; !ok || v == nil {
		return fmt.Errorf("field max_order_amount_limit_display in P2PAdvertCreateRespP2PAdvertCreate: required")
	}
	if v, ok := raw["min_order_amount"]; !ok || v == nil {
		return fmt.Errorf("field min_order_amount in P2PAdvertCreateRespP2PAdvertCreate: required")
	}
	if v, ok := raw["min_order_amount_display"]; !ok || v == nil {
		return fmt.Errorf("field min_order_amount_display in P2PAdvertCreateRespP2PAdvertCreate: required")
	}
	if v, ok := raw["min_order_amount_limit"]; !ok || v == nil {
		return fmt.Errorf("field min_order_amount_limit in P2PAdvertCreateRespP2PAdvertCreate: required")
	}
	if v, ok := raw["min_order_amount_limit_display"]; !ok || v == nil {
		return fmt.Errorf("field min_order_amount_limit_display in P2PAdvertCreateRespP2PAdvertCreate: required")
	}
	if v, ok := raw["order_expiry_period"]; !ok || v == nil {
		return fmt.Errorf("field order_expiry_period in P2PAdvertCreateRespP2PAdvertCreate: required")
	}
	if v, ok := raw["payment_method"]; !ok || v == nil {
		return fmt.Errorf("field payment_method in P2PAdvertCreateRespP2PAdvertCreate: required")
	}
	if v, ok := raw["price"]; !ok || v == nil {
		return fmt.Errorf("field price in P2PAdvertCreateRespP2PAdvertCreate: required")
	}
	if v, ok := raw["price_display"]; !ok || v == nil {
		return fmt.Errorf("field price_display in P2PAdvertCreateRespP2PAdvertCreate: required")
	}
	if v, ok := raw["rate"]; !ok || v == nil {
		return fmt.Errorf("field rate in P2PAdvertCreateRespP2PAdvertCreate: required")
	}
	if v, ok := raw["rate_display"]; !ok || v == nil {
		return fmt.Errorf("field rate_display in P2PAdvertCreateRespP2PAdvertCreate: required")
	}
	if v, ok := raw["rate_type"]; !ok || v == nil {
		return fmt.Errorf("field rate_type in P2PAdvertCreateRespP2PAdvertCreate: required")
	}
	if v, ok := raw["remaining_amount"]; !ok || v == nil {
		return fmt.Errorf("field remaining_amount in P2PAdvertCreateRespP2PAdvertCreate: required")
	}
	if v, ok := raw["remaining_amount_display"]; !ok || v == nil {
		return fmt.Errorf("field remaining_amount_display in P2PAdvertCreateRespP2PAdvertCreate: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in P2PAdvertCreateRespP2PAdvertCreate: required")
	}
	type Plain P2PAdvertCreateRespP2PAdvertCreate
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["is_visible"]; !ok || v == nil {
		plain.IsVisible = 0.0
	}
	*j = P2PAdvertCreateRespP2PAdvertCreate(plain)
	return nil
}

// Returns the information of the created  P2P (Peer to Peer) advert.
type P2PAdvertCreateResp struct {
	// Echo of the request made.
	EchoReq P2PAdvertCreateRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType P2PAdvertCreateRespMsgType `json:"msg_type"`

	// The information of the created P2P advert.
	P2PAdvertCreate *P2PAdvertCreateRespP2PAdvertCreate `json:"p2p_advert_create,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *P2PAdvertCreateResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req in P2PAdvertCreateResp: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type in P2PAdvertCreateResp: required")
	}
	type Plain P2PAdvertCreateResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = P2PAdvertCreateResp(plain)
	return nil
}
