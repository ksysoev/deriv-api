// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package schema

import "fmt"
import "reflect"
import "encoding/json"

// Latest price and other details for a given contract
type ProposalResp struct {
	// Echo of the request made.
	EchoReq ProposalRespEchoReq `json:"echo_req"`

	// Action name of the request made.
	MsgType ProposalRespMsgType `json:"msg_type"`

	// Latest price and other details for a given contract
	Proposal *ProposalRespProposal `json:"proposal,omitempty"`

	// Optional field sent in request to map to response, present only when request
	// contains `req_id`.
	ReqId *int `json:"req_id,omitempty"`

	// For subscription requests only.
	Subscription *ProposalRespSubscription `json:"subscription,omitempty"`
}

// Echo of the request made.
type ProposalRespEchoReq map[string]interface{}

type ProposalRespMsgType string

const ProposalRespMsgTypeProposal ProposalRespMsgType = "proposal"

// Latest price and other details for a given contract
type ProposalRespProposal struct {
	// The ask price.
	AskPrice float64 `json:"ask_price"`

	// [Only for vanilla options] The choices of predefined strike price for client to
	// choose
	BarrierChoices []interface{} `json:"barrier_choices,omitempty"`

	// Contains information about contract cancellation option.
	Cancellation *ProposalRespProposalCancellation `json:"cancellation,omitempty"`

	// Commission changed in percentage (%).
	Commission interface{} `json:"commission,omitempty"`

	// Contains contract information.
	ContractDetails *ProposalRespProposalContractDetails `json:"contract_details,omitempty"`

	// The end date of the contract.
	DateExpiry *int `json:"date_expiry,omitempty"`

	// The start date of the contract.
	DateStart int `json:"date_start"`

	// [Only for vanilla or turbos options] The implied number of contracts
	DisplayNumberOfContracts *string `json:"display_number_of_contracts,omitempty"`

	// Same as `ask_price`.
	DisplayValue string `json:"display_value"`

	// A per-connection unique identifier. Can be passed to the `forget` API call to
	// unsubscribe.
	Id string `json:"id"`

	// Contains limit order information. (Only applicable for contract with limit
	// order).
	LimitOrder *ProposalRespProposalLimitOrder `json:"limit_order,omitempty"`

	// Example: Win payout if Random 100 Index is strictly higher than entry spot at
	// 15 minutes after contract start time.
	Longcode string `json:"longcode"`

	// [Only for vanilla or turbos options] Maximum stakes allowed
	MaxStake *float64 `json:"max_stake,omitempty"`

	// [Only for vanilla or turbos options] Minimum stakes allowed
	MinStake *float64 `json:"min_stake,omitempty"`

	// [Only for lookback trades] Multiplier applies when calculating the final payoff
	// for each type of lookback. e.g. (Exit spot - Lowest historical price) *
	// multiplier = Payout
	Multiplier *float64 `json:"multiplier,omitempty"`

	// [Only for vanilla or turbos options] The implied number of contracts
	NumberOfContracts *float64 `json:"number_of_contracts,omitempty"`

	// The payout amount of the contract.
	Payout float64 `json:"payout"`

	// Spot value (if there are no Exchange data-feed licensing restrictions for the
	// underlying symbol).
	Spot float64 `json:"spot"`

	// The corresponding time of the spot value.
	SpotTime int `json:"spot_time"`
}

// Contains information about contract cancellation option.
type ProposalRespProposalCancellation struct {
	// Ask price of contract cancellation option.
	AskPrice *float64 `json:"ask_price,omitempty"`

	// Expiry time in epoch for contract cancellation option.
	DateExpiry *int `json:"date_expiry,omitempty"`
}

// Contains contract information.
type ProposalRespProposalContractDetails struct {
	// Barrier of the contract.
	Barrier *string `json:"barrier,omitempty"`

	// Absolute difference between high/low barrier and spot
	BarrierSpotDistance *string `json:"barrier_spot_distance,omitempty"`

	// High barrier calculated based on current spot
	HighBarrier *string `json:"high_barrier,omitempty"`

	// Epoch of last tick considered for stat chart
	LastTickEpoch *int `json:"last_tick_epoch,omitempty"`

	// Low barrier calculated based on current spot
	LowBarrier *string `json:"low_barrier,omitempty"`

	// Maximum payout that user can get out of a contract, contract will close
	// automatically if payout reaches this number
	MaximumPayout *float64 `json:"maximum_payout,omitempty"`

	// Maximum duration that a contract can last, contract will close automatically
	// after this number of ticks
	MaximumTicks *int `json:"maximum_ticks,omitempty"`

	// Tick size barrier for Accumulator contracts
	TickSizeBarrier *float64 `json:"tick_size_barrier,omitempty"`

	// An array of numbers  to build a stat chart - each number represents the
	// duration that spot stayed between barries
	TicksStayedIn []int `json:"ticks_stayed_in,omitempty"`
}

// Contains limit order information. (Only applicable for contract with limit
// order).
type ProposalRespProposalLimitOrder struct {
	// Contains information where the contract will be closed automatically at the
	// loss specified by the user.
	StopLoss *ProposalRespProposalLimitOrderStopLoss `json:"stop_loss,omitempty"`

	// Contains information where the contract will be closed automatically when the
	// value of the contract is close to zero. This is set by the us.
	StopOut *ProposalRespProposalLimitOrderStopOut `json:"stop_out,omitempty"`

	// Contains information where the contract will be closed automatically at the
	// profit specified by the user.
	TakeProfit *ProposalRespProposalLimitOrderTakeProfit `json:"take_profit,omitempty"`
}

// Contains information where the contract will be closed automatically at the loss
// specified by the user.
type ProposalRespProposalLimitOrderStopLoss struct {
	// Localized display name
	DisplayName *string `json:"display_name,omitempty"`

	// Stop loss amount
	OrderAmount interface{} `json:"order_amount,omitempty"`

	// Stop loss order epoch
	OrderDate *int `json:"order_date,omitempty"`

	// Pip-sized barrier value
	Value interface{} `json:"value,omitempty"`
}

// Contains information where the contract will be closed automatically when the
// value of the contract is close to zero. This is set by the us.
type ProposalRespProposalLimitOrderStopOut struct {
	// Localized display name
	DisplayName *string `json:"display_name,omitempty"`

	// Stop out amount
	OrderAmount *float64 `json:"order_amount,omitempty"`

	// Stop out order epoch
	OrderDate *int `json:"order_date,omitempty"`

	// Pip-sized barrier value
	Value *string `json:"value,omitempty"`
}

// Contains information where the contract will be closed automatically at the
// profit specified by the user.
type ProposalRespProposalLimitOrderTakeProfit struct {
	// Localized display name
	DisplayName *string `json:"display_name,omitempty"`

	// Take profit amount
	OrderAmount interface{} `json:"order_amount,omitempty"`

	// Take profit order epoch
	OrderDate *int `json:"order_date,omitempty"`

	// Pip-sized barrier value
	Value interface{} `json:"value,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalRespMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ProposalRespMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ProposalRespMsgType, v)
	}
	*j = ProposalRespMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalRespProposal) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["ask_price"]; !ok || v == nil {
		return fmt.Errorf("field ask_price: required")
	}
	if v, ok := raw["date_start"]; !ok || v == nil {
		return fmt.Errorf("field date_start: required")
	}
	if v, ok := raw["display_value"]; !ok || v == nil {
		return fmt.Errorf("field display_value: required")
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	if v, ok := raw["longcode"]; !ok || v == nil {
		return fmt.Errorf("field longcode: required")
	}
	if v, ok := raw["payout"]; !ok || v == nil {
		return fmt.Errorf("field payout: required")
	}
	if v, ok := raw["spot"]; !ok || v == nil {
		return fmt.Errorf("field spot: required")
	}
	if v, ok := raw["spot_time"]; !ok || v == nil {
		return fmt.Errorf("field spot_time: required")
	}
	type Plain ProposalRespProposal
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ProposalRespProposal(plain)
	return nil
}

// For subscription requests only.
type ProposalRespSubscription struct {
	// A per-connection unique identifier. Can be passed to the `forget` API call to
	// unsubscribe.
	Id string `json:"id"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalRespSubscription) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id: required")
	}
	type Plain ProposalRespSubscription
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ProposalRespSubscription(plain)
	return nil
}

var enumValues_ProposalRespMsgType = []interface{}{
	"proposal",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProposalResp) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["echo_req"]; !ok || v == nil {
		return fmt.Errorf("field echo_req: required")
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		return fmt.Errorf("field msg_type: required")
	}
	type Plain ProposalResp
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ProposalResp(plain)
	return nil
}
